// Code generated by protoc-gen-go. DO NOT EDIT.
// source: peloton/api/v1alpha/job/stateless/stateless.proto

package stateless

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	peloton "github.com/uber/peloton/.gen/peloton/api/v1alpha/peloton"
	pod "github.com/uber/peloton/.gen/peloton/api/v1alpha/pod"
	query "github.com/uber/peloton/.gen/peloton/api/v1alpha/query"
	respool "github.com/uber/peloton/.gen/peloton/api/v1alpha/respool"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Runtime states of a Job.
type JobState int32

const (
	// Invalid job state.
	JobState_JOB_STATE_INVALID JobState = 0
	// The job has been initialized and persisted in DB.
	JobState_JOB_STATE_INITIALIZED JobState = 1
	// All tasks have been created and persisted in DB,
	// but no task is RUNNING yet.
	JobState_JOB_STATE_PENDING JobState = 2
	// Any of the tasks in the job is in RUNNING state.
	JobState_JOB_STATE_RUNNING JobState = 3
	// All tasks in the job are in SUCCEEDED state.
	JobState_JOB_STATE_SUCCEEDED JobState = 4
	// All tasks in the job are in terminated state and one or more
	// tasks is in FAILED state.
	JobState_JOB_STATE_FAILED JobState = 5
	// All tasks in the job are in terminated state and one or more
	// tasks in the job is killed by the user.
	JobState_JOB_STATE_KILLED JobState = 6
	// All tasks in the job have been requested to be killed by the user.
	JobState_JOB_STATE_KILLING JobState = 7
	// The job is partially created and is not ready to be scheduled
	JobState_JOB_STATE_UNINITIALIZED JobState = 8
	// The job has been deleted.
	JobState_JOB_STATE_DELETED JobState = 9
)

var JobState_name = map[int32]string{
	0: "JOB_STATE_INVALID",
	1: "JOB_STATE_INITIALIZED",
	2: "JOB_STATE_PENDING",
	3: "JOB_STATE_RUNNING",
	4: "JOB_STATE_SUCCEEDED",
	5: "JOB_STATE_FAILED",
	6: "JOB_STATE_KILLED",
	7: "JOB_STATE_KILLING",
	8: "JOB_STATE_UNINITIALIZED",
	9: "JOB_STATE_DELETED",
}

var JobState_value = map[string]int32{
	"JOB_STATE_INVALID":       0,
	"JOB_STATE_INITIALIZED":   1,
	"JOB_STATE_PENDING":       2,
	"JOB_STATE_RUNNING":       3,
	"JOB_STATE_SUCCEEDED":     4,
	"JOB_STATE_FAILED":        5,
	"JOB_STATE_KILLED":        6,
	"JOB_STATE_KILLING":       7,
	"JOB_STATE_UNINITIALIZED": 8,
	"JOB_STATE_DELETED":       9,
}

func (x JobState) String() string {
	return proto.EnumName(JobState_name, int32(x))
}

func (JobState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_859713a7fd7bfab2, []int{0}
}

// The different types of job rolling workflows supported.
type WorkflowType int32

const (
	// Invalid protobuf value.
	WorkflowType_WORKFLOW_TYPE_INVALID WorkflowType = 0
	// Job update workflow.
	WorkflowType_WORKFLOW_TYPE_UPDATE WorkflowType = 1
	// Restart pods in a job.
	WorkflowType_WORKFLOW_TYPE_RESTART WorkflowType = 2
)

var WorkflowType_name = map[int32]string{
	0: "WORKFLOW_TYPE_INVALID",
	1: "WORKFLOW_TYPE_UPDATE",
	2: "WORKFLOW_TYPE_RESTART",
}

var WorkflowType_value = map[string]int32{
	"WORKFLOW_TYPE_INVALID": 0,
	"WORKFLOW_TYPE_UPDATE":  1,
	"WORKFLOW_TYPE_RESTART": 2,
}

func (x WorkflowType) String() string {
	return proto.EnumName(WorkflowType_name, int32(x))
}

func (WorkflowType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_859713a7fd7bfab2, []int{1}
}

// Runtime state of a job workflow.
type WorkflowState int32

const (
	// Invalid protobuf value
	WorkflowState_WORKFLOW_STATE_INVALID WorkflowState = 0
	// The operation has been created but not started yet.
	WorkflowState_WORKFLOW_STATE_INITIALIZED WorkflowState = 1
	// The workflow is rolling forward
	WorkflowState_WORKFLOW_STATE_ROLLING_FORWARD WorkflowState = 2
	// The workflow has been paused
	WorkflowState_WORKFLOW_STATE_PAUSED WorkflowState = 3
	// The workflow has completed successfully
	WorkflowState_WORKFLOW_STATE_SUCCEEDED WorkflowState = 4
	// The update was aborted/cancelled
	WorkflowState_WORKFLOW_STATE_ABORTED WorkflowState = 5
	// The workflow has failed to complete.
	WorkflowState_WORKFLOW_STATE_FAILED WorkflowState = 6
	// The update is rolling backward
	WorkflowState_WORKFLOW_STATE_ROLLING_BACKWARD WorkflowState = 7
	// The update was rolled back due to failure
	WorkflowState_WORKFLOW_STATE_ROLLED_BACK WorkflowState = 8
)

var WorkflowState_name = map[int32]string{
	0: "WORKFLOW_STATE_INVALID",
	1: "WORKFLOW_STATE_INITIALIZED",
	2: "WORKFLOW_STATE_ROLLING_FORWARD",
	3: "WORKFLOW_STATE_PAUSED",
	4: "WORKFLOW_STATE_SUCCEEDED",
	5: "WORKFLOW_STATE_ABORTED",
	6: "WORKFLOW_STATE_FAILED",
	7: "WORKFLOW_STATE_ROLLING_BACKWARD",
	8: "WORKFLOW_STATE_ROLLED_BACK",
}

var WorkflowState_value = map[string]int32{
	"WORKFLOW_STATE_INVALID":          0,
	"WORKFLOW_STATE_INITIALIZED":      1,
	"WORKFLOW_STATE_ROLLING_FORWARD":  2,
	"WORKFLOW_STATE_PAUSED":           3,
	"WORKFLOW_STATE_SUCCEEDED":        4,
	"WORKFLOW_STATE_ABORTED":          5,
	"WORKFLOW_STATE_FAILED":           6,
	"WORKFLOW_STATE_ROLLING_BACKWARD": 7,
	"WORKFLOW_STATE_ROLLED_BACK":      8,
}

func (x WorkflowState) String() string {
	return proto.EnumName(WorkflowState_name, int32(x))
}

func (WorkflowState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_859713a7fd7bfab2, []int{2}
}

// SLA configuration for a stateless job
type SlaSpec struct {
	// Priority of a job. Higher value takes priority over lower value
	// when making scheduling decisions as well as preemption decisions.
	Priority uint32 `protobuf:"varint,1,opt,name=priority,proto3" json:"priority,omitempty"`
	// Whether all the job instances are preemptible. If so, it might
	// be scheduled elastic resources from other resource pools and
	// subject to preemption when the demands of other resource pools increase.
	// For stateless jobs, this field will overrule preemptible
	// configuration in the pod spec.
	Preemptible bool `protobuf:"varint,2,opt,name=preemptible,proto3" json:"preemptible,omitempty"`
	// Whether all the job instances are revocable. If so, it might
	// be scheduled using revocable resources and subject to preemption
	// when there is resource contention on the host.
	// For stateless jobs, this field will overrule revocable
	// configuration in the pod spec.
	Revocable bool `protobuf:"varint,3,opt,name=revocable,proto3" json:"revocable,omitempty"`
	// Maximum number of job instances which can be unavailable at a given time.
	MaximumUnavailableInstances uint32   `protobuf:"varint,4,opt,name=maximum_unavailable_instances,json=maximumUnavailableInstances,proto3" json:"maximum_unavailable_instances,omitempty"`
	XXX_NoUnkeyedLiteral        struct{} `json:"-"`
	XXX_unrecognized            []byte   `json:"-"`
	XXX_sizecache               int32    `json:"-"`
}

func (m *SlaSpec) Reset()         { *m = SlaSpec{} }
func (m *SlaSpec) String() string { return proto.CompactTextString(m) }
func (*SlaSpec) ProtoMessage()    {}
func (*SlaSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_859713a7fd7bfab2, []int{0}
}

func (m *SlaSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SlaSpec.Unmarshal(m, b)
}
func (m *SlaSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SlaSpec.Marshal(b, m, deterministic)
}
func (m *SlaSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlaSpec.Merge(m, src)
}
func (m *SlaSpec) XXX_Size() int {
	return xxx_messageInfo_SlaSpec.Size(m)
}
func (m *SlaSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SlaSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SlaSpec proto.InternalMessageInfo

func (m *SlaSpec) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *SlaSpec) GetPreemptible() bool {
	if m != nil {
		return m.Preemptible
	}
	return false
}

func (m *SlaSpec) GetRevocable() bool {
	if m != nil {
		return m.Revocable
	}
	return false
}

func (m *SlaSpec) GetMaximumUnavailableInstances() uint32 {
	if m != nil {
		return m.MaximumUnavailableInstances
	}
	return 0
}

// Stateless job configuration.
type JobSpec struct {
	// Revision of the job config
	Revision *peloton.Revision `protobuf:"bytes,1,opt,name=revision,proto3" json:"revision,omitempty"`
	// Name of the job
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Owner of the job
	Owner string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	// Owning team of the job
	OwningTeam string `protobuf:"bytes,4,opt,name=owning_team,json=owningTeam,proto3" json:"owning_team,omitempty"`
	// LDAP groups of the job
	LdapGroups []string `protobuf:"bytes,5,rep,name=ldap_groups,json=ldapGroups,proto3" json:"ldap_groups,omitempty"`
	// Description of the job
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	// List of user-defined labels for the job
	Labels []*peloton.Label `protobuf:"bytes,7,rep,name=labels,proto3" json:"labels,omitempty"`
	// Number of instances of the job
	InstanceCount uint32 `protobuf:"varint,8,opt,name=instance_count,json=instanceCount,proto3" json:"instance_count,omitempty"`
	// SLA config of the job
	Sla *SlaSpec `protobuf:"bytes,9,opt,name=sla,proto3" json:"sla,omitempty"`
	// Default pod configuration of the job
	DefaultSpec *pod.PodSpec `protobuf:"bytes,10,opt,name=default_spec,json=defaultSpec,proto3" json:"default_spec,omitempty"`
	// Instance specific pod config which overwrites the default one
	InstanceSpec map[uint32]*pod.PodSpec `protobuf:"bytes,11,rep,name=instance_spec,json=instanceSpec,proto3" json:"instance_spec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Resource Pool ID where this job belongs to
	RespoolId            *peloton.ResourcePoolID `protobuf:"bytes,12,opt,name=respool_id,json=respoolId,proto3" json:"respool_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *JobSpec) Reset()         { *m = JobSpec{} }
func (m *JobSpec) String() string { return proto.CompactTextString(m) }
func (*JobSpec) ProtoMessage()    {}
func (*JobSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_859713a7fd7bfab2, []int{1}
}

func (m *JobSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_JobSpec.Unmarshal(m, b)
}
func (m *JobSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_JobSpec.Marshal(b, m, deterministic)
}
func (m *JobSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobSpec.Merge(m, src)
}
func (m *JobSpec) XXX_Size() int {
	return xxx_messageInfo_JobSpec.Size(m)
}
func (m *JobSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_JobSpec.DiscardUnknown(m)
}

var xxx_messageInfo_JobSpec proto.InternalMessageInfo

func (m *JobSpec) GetRevision() *peloton.Revision {
	if m != nil {
		return m.Revision
	}
	return nil
}

func (m *JobSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *JobSpec) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *JobSpec) GetOwningTeam() string {
	if m != nil {
		return m.OwningTeam
	}
	return ""
}

func (m *JobSpec) GetLdapGroups() []string {
	if m != nil {
		return m.LdapGroups
	}
	return nil
}

func (m *JobSpec) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *JobSpec) GetLabels() []*peloton.Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *JobSpec) GetInstanceCount() uint32 {
	if m != nil {
		return m.InstanceCount
	}
	return 0
}

func (m *JobSpec) GetSla() *SlaSpec {
	if m != nil {
		return m.Sla
	}
	return nil
}

func (m *JobSpec) GetDefaultSpec() *pod.PodSpec {
	if m != nil {
		return m.DefaultSpec
	}
	return nil
}

func (m *JobSpec) GetInstanceSpec() map[uint32]*pod.PodSpec {
	if m != nil {
		return m.InstanceSpec
	}
	return nil
}

func (m *JobSpec) GetRespoolId() *peloton.ResourcePoolID {
	if m != nil {
		return m.RespoolId
	}
	return nil
}

// Runtime status of a job workflow.
type WorkflowStatus struct {
	// Workflow type.
	Type WorkflowType `protobuf:"varint,1,opt,name=type,proto3,enum=peloton.api.v1alpha.job.stateless.WorkflowType" json:"type,omitempty"`
	// Current runtime state of the workflow.
	State WorkflowState `protobuf:"varint,2,opt,name=state,proto3,enum=peloton.api.v1alpha.job.stateless.WorkflowState" json:"state,omitempty"`
	// Number of instances completed.
	NumInstancesCompleted uint32 `protobuf:"varint,3,opt,name=num_instances_completed,json=numInstancesCompleted,proto3" json:"num_instances_completed,omitempty"`
	// Number of instances remaining.
	NumInstancesRemaining uint32 `protobuf:"varint,4,opt,name=num_instances_remaining,json=numInstancesRemaining,proto3" json:"num_instances_remaining,omitempty"`
	// Number of instances which failed to come up after the workflow.
	NumInstancesFailed uint32 `protobuf:"varint,5,opt,name=num_instances_failed,json=numInstancesFailed,proto3" json:"num_instances_failed,omitempty"`
	// Current instances being operated on.
	InstancesCurrent []uint32 `protobuf:"varint,6,rep,packed,name=instances_current,json=instancesCurrent,proto3" json:"instances_current,omitempty"`
	// Job version the workflow moved the job object to.
	Version *peloton.EntityVersion `protobuf:"bytes,7,opt,name=version,proto3" json:"version,omitempty"`
	// Previous job version of the job object.
	PrevVersion *peloton.EntityVersion `protobuf:"bytes,8,opt,name=prev_version,json=prevVersion,proto3" json:"prev_version,omitempty"`
	// The time when the workflow was created. The time is represented in
	// RFC3339 form with UTC timezone.
	CreationTime string `protobuf:"bytes,9,opt,name=creation_time,json=creationTime,proto3" json:"creation_time,omitempty"`
	// The time when the workflow was last updated. The time is represented in
	// RFC3339 form with UTC timezone.
	UpdateTime string `protobuf:"bytes,10,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
	// Previous runtime state of the workflow.
	PrevState WorkflowState `protobuf:"varint,11,opt,name=prev_state,json=prevState,proto3,enum=peloton.api.v1alpha.job.stateless.WorkflowState" json:"prev_state,omitempty"`
	// The time when the workflow completed. The time is represented in
	// RFC3339 form with UTC timezone.
	CompletionTime       string   `protobuf:"bytes,12,opt,name=completion_time,json=completionTime,proto3" json:"completion_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkflowStatus) Reset()         { *m = WorkflowStatus{} }
func (m *WorkflowStatus) String() string { return proto.CompactTextString(m) }
func (*WorkflowStatus) ProtoMessage()    {}
func (*WorkflowStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_859713a7fd7bfab2, []int{2}
}

func (m *WorkflowStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WorkflowStatus.Unmarshal(m, b)
}
func (m *WorkflowStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WorkflowStatus.Marshal(b, m, deterministic)
}
func (m *WorkflowStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowStatus.Merge(m, src)
}
func (m *WorkflowStatus) XXX_Size() int {
	return xxx_messageInfo_WorkflowStatus.Size(m)
}
func (m *WorkflowStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowStatus proto.InternalMessageInfo

func (m *WorkflowStatus) GetType() WorkflowType {
	if m != nil {
		return m.Type
	}
	return WorkflowType_WORKFLOW_TYPE_INVALID
}

func (m *WorkflowStatus) GetState() WorkflowState {
	if m != nil {
		return m.State
	}
	return WorkflowState_WORKFLOW_STATE_INVALID
}

func (m *WorkflowStatus) GetNumInstancesCompleted() uint32 {
	if m != nil {
		return m.NumInstancesCompleted
	}
	return 0
}

func (m *WorkflowStatus) GetNumInstancesRemaining() uint32 {
	if m != nil {
		return m.NumInstancesRemaining
	}
	return 0
}

func (m *WorkflowStatus) GetNumInstancesFailed() uint32 {
	if m != nil {
		return m.NumInstancesFailed
	}
	return 0
}

func (m *WorkflowStatus) GetInstancesCurrent() []uint32 {
	if m != nil {
		return m.InstancesCurrent
	}
	return nil
}

func (m *WorkflowStatus) GetVersion() *peloton.EntityVersion {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *WorkflowStatus) GetPrevVersion() *peloton.EntityVersion {
	if m != nil {
		return m.PrevVersion
	}
	return nil
}

func (m *WorkflowStatus) GetCreationTime() string {
	if m != nil {
		return m.CreationTime
	}
	return ""
}

func (m *WorkflowStatus) GetUpdateTime() string {
	if m != nil {
		return m.UpdateTime
	}
	return ""
}

func (m *WorkflowStatus) GetPrevState() WorkflowState {
	if m != nil {
		return m.PrevState
	}
	return WorkflowState_WORKFLOW_STATE_INVALID
}

func (m *WorkflowStatus) GetCompletionTime() string {
	if m != nil {
		return m.CompletionTime
	}
	return ""
}

// The current runtime status of a Job.
type JobStatus struct {
	// Revision of the current job status. Version in the revision is incremented
	// every time job status changes. Thus, it can be used to order the different
	// job status updates.
	Revision *peloton.Revision `protobuf:"bytes,1,opt,name=revision,proto3" json:"revision,omitempty"`
	// State of the job
	State JobState `protobuf:"varint,2,opt,name=state,proto3,enum=peloton.api.v1alpha.job.stateless.JobState" json:"state,omitempty"`
	// The time when the job was created. The time is represented in
	// RFC3339 form with UTC timezone.
	CreationTime string `protobuf:"bytes,3,opt,name=creation_time,json=creationTime,proto3" json:"creation_time,omitempty"`
	// The number of pods grouped by each pod state. The map key is
	// the pod.PodState in string format and the map value is the number
	// of tasks in the particular state.
	PodStats map[string]uint32 `protobuf:"bytes,4,rep,name=pod_stats,json=podStats,proto3" json:"pod_stats,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// Goal state of the job.
	DesiredState JobState `protobuf:"varint,5,opt,name=desired_state,json=desiredState,proto3,enum=peloton.api.v1alpha.job.stateless.JobState" json:"desired_state,omitempty"`
	// The current version of the job. It is used to implement optimistic
	// concurrency control for all job write APIs. The current job
	// configuration can be fetched based on the current resource version.
	Version *peloton.EntityVersion `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty"`
	// Status of ongoing update/restart workflow.
	WorkflowStatus *WorkflowStatus `protobuf:"bytes,7,opt,name=workflow_status,json=workflowStatus,proto3" json:"workflow_status,omitempty"`
	// DEPRECATED, will remove in the next release
	// The number of tasks grouped by which configuration version they are on.
	// The map key is the job configuration version and the map value is the
	// number of tasks using that particular job configuration version.
	// The job configuration version in the map key can be fed as the value of
	// the entity version in the GetJobRequest to fetch the job configuration.
	PodConfigurationVersionStats map[string]uint32 `protobuf:"bytes,8,rep,name=pod_configuration_version_stats,json=podConfigurationVersionStats,proto3" json:"pod_configuration_version_stats,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// The number of pods grouped by which entity version and the state
	// they are on.
	// The map key is the entity version (which can be used to fetch
	// the job configuration) and the map value is PodStateStats.
	PodStatsByConfigurationVersion map[string]*JobStatus_PodStateStats `protobuf:"bytes,9,rep,name=pod_stats_by_configuration_version,json=podStatsByConfigurationVersion,proto3" json:"pod_stats_by_configuration_version,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral           struct{}                            `json:"-"`
	XXX_unrecognized               []byte                              `json:"-"`
	XXX_sizecache                  int32                               `json:"-"`
}

func (m *JobStatus) Reset()         { *m = JobStatus{} }
func (m *JobStatus) String() string { return proto.CompactTextString(m) }
func (*JobStatus) ProtoMessage()    {}
func (*JobStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_859713a7fd7bfab2, []int{3}
}

func (m *JobStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_JobStatus.Unmarshal(m, b)
}
func (m *JobStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_JobStatus.Marshal(b, m, deterministic)
}
func (m *JobStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobStatus.Merge(m, src)
}
func (m *JobStatus) XXX_Size() int {
	return xxx_messageInfo_JobStatus.Size(m)
}
func (m *JobStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_JobStatus.DiscardUnknown(m)
}

var xxx_messageInfo_JobStatus proto.InternalMessageInfo

func (m *JobStatus) GetRevision() *peloton.Revision {
	if m != nil {
		return m.Revision
	}
	return nil
}

func (m *JobStatus) GetState() JobState {
	if m != nil {
		return m.State
	}
	return JobState_JOB_STATE_INVALID
}

func (m *JobStatus) GetCreationTime() string {
	if m != nil {
		return m.CreationTime
	}
	return ""
}

func (m *JobStatus) GetPodStats() map[string]uint32 {
	if m != nil {
		return m.PodStats
	}
	return nil
}

func (m *JobStatus) GetDesiredState() JobState {
	if m != nil {
		return m.DesiredState
	}
	return JobState_JOB_STATE_INVALID
}

func (m *JobStatus) GetVersion() *peloton.EntityVersion {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *JobStatus) GetWorkflowStatus() *WorkflowStatus {
	if m != nil {
		return m.WorkflowStatus
	}
	return nil
}

func (m *JobStatus) GetPodConfigurationVersionStats() map[string]uint32 {
	if m != nil {
		return m.PodConfigurationVersionStats
	}
	return nil
}

func (m *JobStatus) GetPodStatsByConfigurationVersion() map[string]*JobStatus_PodStateStats {
	if m != nil {
		return m.PodStatsByConfigurationVersion
	}
	return nil
}

// PodStateStats indicates the number of tasks of a particular state in a job
type JobStatus_PodStateStats struct {
	// The map key is pod state, the value
	// is number of pods running in that state.
	StateStats           map[string]uint32 `protobuf:"bytes,1,rep,name=state_stats,json=stateStats,proto3" json:"state_stats,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *JobStatus_PodStateStats) Reset()         { *m = JobStatus_PodStateStats{} }
func (m *JobStatus_PodStateStats) String() string { return proto.CompactTextString(m) }
func (*JobStatus_PodStateStats) ProtoMessage()    {}
func (*JobStatus_PodStateStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_859713a7fd7bfab2, []int{3, 0}
}

func (m *JobStatus_PodStateStats) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_JobStatus_PodStateStats.Unmarshal(m, b)
}
func (m *JobStatus_PodStateStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_JobStatus_PodStateStats.Marshal(b, m, deterministic)
}
func (m *JobStatus_PodStateStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobStatus_PodStateStats.Merge(m, src)
}
func (m *JobStatus_PodStateStats) XXX_Size() int {
	return xxx_messageInfo_JobStatus_PodStateStats.Size(m)
}
func (m *JobStatus_PodStateStats) XXX_DiscardUnknown() {
	xxx_messageInfo_JobStatus_PodStateStats.DiscardUnknown(m)
}

var xxx_messageInfo_JobStatus_PodStateStats proto.InternalMessageInfo

func (m *JobStatus_PodStateStats) GetStateStats() map[string]uint32 {
	if m != nil {
		return m.StateStats
	}
	return nil
}

// Information of a job, such as job spec and status
type JobInfo struct {
	// Job ID
	JobId *peloton.JobID `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// Job configuration
	Spec *JobSpec `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
	// Job runtime status
	Status               *JobStatus `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *JobInfo) Reset()         { *m = JobInfo{} }
func (m *JobInfo) String() string { return proto.CompactTextString(m) }
func (*JobInfo) ProtoMessage()    {}
func (*JobInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_859713a7fd7bfab2, []int{4}
}

func (m *JobInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_JobInfo.Unmarshal(m, b)
}
func (m *JobInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_JobInfo.Marshal(b, m, deterministic)
}
func (m *JobInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobInfo.Merge(m, src)
}
func (m *JobInfo) XXX_Size() int {
	return xxx_messageInfo_JobInfo.Size(m)
}
func (m *JobInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_JobInfo.DiscardUnknown(m)
}

var xxx_messageInfo_JobInfo proto.InternalMessageInfo

func (m *JobInfo) GetJobId() *peloton.JobID {
	if m != nil {
		return m.JobId
	}
	return nil
}

func (m *JobInfo) GetSpec() *JobSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *JobInfo) GetStatus() *JobStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Summary of job spec and status. The summary will be returned by List
// or Query API calls. These calls will return a large number of jobs,
// so the content in the job summary has to be kept minimal.
type JobSummary struct {
	// Job ID
	JobId *peloton.JobID `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// Name of the job
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Owner of the job
	Owner string `protobuf:"bytes,4,opt,name=owner,proto3" json:"owner,omitempty"`
	// Owning team of the job
	OwningTeam string `protobuf:"bytes,5,opt,name=owning_team,json=owningTeam,proto3" json:"owning_team,omitempty"`
	// List of user-defined labels for the job
	Labels []*peloton.Label `protobuf:"bytes,6,rep,name=labels,proto3" json:"labels,omitempty"`
	// Number of instances of the job
	InstanceCount uint32 `protobuf:"varint,7,opt,name=instance_count,json=instanceCount,proto3" json:"instance_count,omitempty"`
	// Resource Pool ID where this job belongs to
	RespoolId *peloton.ResourcePoolID `protobuf:"bytes,8,opt,name=respool_id,json=respoolId,proto3" json:"respool_id,omitempty"`
	// Job runtime status
	Status *JobStatus `protobuf:"bytes,9,opt,name=status,proto3" json:"status,omitempty"`
	// Job SLA Spec
	Sla                  *SlaSpec `protobuf:"bytes,10,opt,name=sla,proto3" json:"sla,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JobSummary) Reset()         { *m = JobSummary{} }
func (m *JobSummary) String() string { return proto.CompactTextString(m) }
func (*JobSummary) ProtoMessage()    {}
func (*JobSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_859713a7fd7bfab2, []int{5}
}

func (m *JobSummary) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_JobSummary.Unmarshal(m, b)
}
func (m *JobSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_JobSummary.Marshal(b, m, deterministic)
}
func (m *JobSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobSummary.Merge(m, src)
}
func (m *JobSummary) XXX_Size() int {
	return xxx_messageInfo_JobSummary.Size(m)
}
func (m *JobSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_JobSummary.DiscardUnknown(m)
}

var xxx_messageInfo_JobSummary proto.InternalMessageInfo

func (m *JobSummary) GetJobId() *peloton.JobID {
	if m != nil {
		return m.JobId
	}
	return nil
}

func (m *JobSummary) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *JobSummary) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *JobSummary) GetOwningTeam() string {
	if m != nil {
		return m.OwningTeam
	}
	return ""
}

func (m *JobSummary) GetLabels() []*peloton.Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *JobSummary) GetInstanceCount() uint32 {
	if m != nil {
		return m.InstanceCount
	}
	return 0
}

func (m *JobSummary) GetRespoolId() *peloton.ResourcePoolID {
	if m != nil {
		return m.RespoolId
	}
	return nil
}

func (m *JobSummary) GetStatus() *JobStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *JobSummary) GetSla() *SlaSpec {
	if m != nil {
		return m.Sla
	}
	return nil
}

// QuerySpec specifies the list of query criteria for jobs. All
// indexed fields should be part of this message. And all fields
// in this message have to be indexed too.
type QuerySpec struct {
	// The spec of how to do pagination for the query results.
	Pagination *query.PaginationSpec `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
	// List of labels to query the jobs. Will match all jobs if the
	// list is empty.
	Labels []*peloton.Label `protobuf:"bytes,2,rep,name=labels,proto3" json:"labels,omitempty"`
	// List of keywords to query the jobs. Will match all jobs if
	// the list is empty. When set, will do a wildcard match on
	// owner, name, labels, description.
	Keywords []string `protobuf:"bytes,3,rep,name=keywords,proto3" json:"keywords,omitempty"`
	// List of job states to query the jobs. Will match all jobs if
	// the list is empty.
	JobStates []JobState `protobuf:"varint,4,rep,packed,name=job_states,json=jobStates,proto3,enum=peloton.api.v1alpha.job.stateless.JobState" json:"job_states,omitempty"`
	// The resource pool to query the jobs. Will match jobs from all
	// resource pools if unset.
	Respool *respool.ResourcePoolPath `protobuf:"bytes,5,opt,name=respool,proto3" json:"respool,omitempty"`
	// Query jobs by owner. This is case sensitive and will
	// look for jobs with owner matching the exact owner string.
	// Will match all jobs if owner is unset.
	Owner string `protobuf:"bytes,6,opt,name=owner,proto3" json:"owner,omitempty"`
	// Query jobs by name. This is case sensitive and will
	// look for jobs with name matching the name string. Will
	// support partial name match. Will match all jobs if
	// name is unset.
	Name string `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty"`
	// Query jobs by creation time range. This will look for all jobs
	// that were created within a specified time range. This
	// search will operate based on job creation time.
	CreationTimeRange *peloton.TimeRange `protobuf:"bytes,8,opt,name=creation_time_range,json=creationTimeRange,proto3" json:"creation_time_range,omitempty"`
	// Query jobs by completion time range. This will look for all jobs
	// that were completed within a specified time range. This
	// search will operate based on job completion time.
	CompletionTimeRange  *peloton.TimeRange `protobuf:"bytes,9,opt,name=completion_time_range,json=completionTimeRange,proto3" json:"completion_time_range,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *QuerySpec) Reset()         { *m = QuerySpec{} }
func (m *QuerySpec) String() string { return proto.CompactTextString(m) }
func (*QuerySpec) ProtoMessage()    {}
func (*QuerySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_859713a7fd7bfab2, []int{6}
}

func (m *QuerySpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QuerySpec.Unmarshal(m, b)
}
func (m *QuerySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QuerySpec.Marshal(b, m, deterministic)
}
func (m *QuerySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySpec.Merge(m, src)
}
func (m *QuerySpec) XXX_Size() int {
	return xxx_messageInfo_QuerySpec.Size(m)
}
func (m *QuerySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySpec.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySpec proto.InternalMessageInfo

func (m *QuerySpec) GetPagination() *query.PaginationSpec {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func (m *QuerySpec) GetLabels() []*peloton.Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *QuerySpec) GetKeywords() []string {
	if m != nil {
		return m.Keywords
	}
	return nil
}

func (m *QuerySpec) GetJobStates() []JobState {
	if m != nil {
		return m.JobStates
	}
	return nil
}

func (m *QuerySpec) GetRespool() *respool.ResourcePoolPath {
	if m != nil {
		return m.Respool
	}
	return nil
}

func (m *QuerySpec) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *QuerySpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QuerySpec) GetCreationTimeRange() *peloton.TimeRange {
	if m != nil {
		return m.CreationTimeRange
	}
	return nil
}

func (m *QuerySpec) GetCompletionTimeRange() *peloton.TimeRange {
	if m != nil {
		return m.CompletionTimeRange
	}
	return nil
}

// Configuration of a job update.
type UpdateSpec struct {
	// Batch size for the update which controls how many
	// instances may be updated at the same time.
	BatchSize uint32 `protobuf:"varint,1,opt,name=batch_size,json=batchSize,proto3" json:"batch_size,omitempty"`
	// If configured, the update be automatically rolled back
	// to the previous job configuration on failure.
	RollbackOnFailure bool `protobuf:"varint,2,opt,name=rollback_on_failure,json=rollbackOnFailure,proto3" json:"rollback_on_failure,omitempty"`
	// Maximum number of times a failing instance will
	// be retried during the update.
	// If the value is 0, the instance can be retried for infinite
	// times.
	MaxInstanceRetries uint32 `protobuf:"varint,3,opt,name=max_instance_retries,json=maxInstanceRetries,proto3" json:"max_instance_retries,omitempty"`
	// Maximum number of instance failures before
	// the update is declared to be failed.
	// If the value is 0, there is no limit for max failure instances
	// and the update is marked successful even if all of the instances
	// fail.
	MaxTolerableInstanceFailures uint32 `protobuf:"varint,4,opt,name=max_tolerable_instance_failures,json=maxTolerableInstanceFailures,proto3" json:"max_tolerable_instance_failures,omitempty"`
	// If set to true, indicates that the update should start
	// in the paused state, requiring an explicit resume to roll forward.
	StartPaused bool `protobuf:"varint,5,opt,name=start_paused,json=startPaused,proto3" json:"start_paused,omitempty"`
	// If set to true, peloton would try to place the task
	// updated on the host it previously run on.
	// It is best effort, and has no guarantee of success.
	InPlace bool `protobuf:"varint,6,opt,name=in_place,json=inPlace,proto3" json:"in_place,omitempty"`
	// Experimental: this flag is for experimental purpose and
	// will be removed in the future release.
	// When set to true, peloton would start pods updated,
	// if the pods are killed previously.
	// By default, killed pods would remain killed, and
	// run with new version when running again.
	StartPods            bool     `protobuf:"varint,7,opt,name=start_pods,json=startPods,proto3" json:"start_pods,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateSpec) Reset()         { *m = UpdateSpec{} }
func (m *UpdateSpec) String() string { return proto.CompactTextString(m) }
func (*UpdateSpec) ProtoMessage()    {}
func (*UpdateSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_859713a7fd7bfab2, []int{7}
}

func (m *UpdateSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UpdateSpec.Unmarshal(m, b)
}
func (m *UpdateSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UpdateSpec.Marshal(b, m, deterministic)
}
func (m *UpdateSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSpec.Merge(m, src)
}
func (m *UpdateSpec) XXX_Size() int {
	return xxx_messageInfo_UpdateSpec.Size(m)
}
func (m *UpdateSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSpec.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSpec proto.InternalMessageInfo

func (m *UpdateSpec) GetBatchSize() uint32 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

func (m *UpdateSpec) GetRollbackOnFailure() bool {
	if m != nil {
		return m.RollbackOnFailure
	}
	return false
}

func (m *UpdateSpec) GetMaxInstanceRetries() uint32 {
	if m != nil {
		return m.MaxInstanceRetries
	}
	return 0
}

func (m *UpdateSpec) GetMaxTolerableInstanceFailures() uint32 {
	if m != nil {
		return m.MaxTolerableInstanceFailures
	}
	return 0
}

func (m *UpdateSpec) GetStartPaused() bool {
	if m != nil {
		return m.StartPaused
	}
	return false
}

func (m *UpdateSpec) GetInPlace() bool {
	if m != nil {
		return m.InPlace
	}
	return false
}

func (m *UpdateSpec) GetStartPods() bool {
	if m != nil {
		return m.StartPods
	}
	return false
}

// Configuration of a job creation.
type CreateSpec struct {
	// Batch size for the creation which controls how many
	// instances may be created at the same time.
	BatchSize uint32 `protobuf:"varint,1,opt,name=batch_size,json=batchSize,proto3" json:"batch_size,omitempty"`
	// Maximum number of times a failing instance will
	// be retried during the creation.
	// If the value is 0, the instance can be retried for infinite
	// times.
	MaxInstanceRetries uint32 `protobuf:"varint,2,opt,name=max_instance_retries,json=maxInstanceRetries,proto3" json:"max_instance_retries,omitempty"`
	// Maximum number of instance failures before
	// the creation is declared to be failed.
	// If the value is 0, there is no limit for max failure instances
	// and the creation is marked successful even if all of the instances
	// fail.
	MaxTolerableInstanceFailures uint32 `protobuf:"varint,3,opt,name=max_tolerable_instance_failures,json=maxTolerableInstanceFailures,proto3" json:"max_tolerable_instance_failures,omitempty"`
	// If set to true, indicates that the creation should start
	// in the paused state, requiring an explicit resume to roll forward.
	StartPaused          bool     `protobuf:"varint,4,opt,name=start_paused,json=startPaused,proto3" json:"start_paused,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateSpec) Reset()         { *m = CreateSpec{} }
func (m *CreateSpec) String() string { return proto.CompactTextString(m) }
func (*CreateSpec) ProtoMessage()    {}
func (*CreateSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_859713a7fd7bfab2, []int{8}
}

func (m *CreateSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateSpec.Unmarshal(m, b)
}
func (m *CreateSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateSpec.Marshal(b, m, deterministic)
}
func (m *CreateSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpec.Merge(m, src)
}
func (m *CreateSpec) XXX_Size() int {
	return xxx_messageInfo_CreateSpec.Size(m)
}
func (m *CreateSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpec proto.InternalMessageInfo

func (m *CreateSpec) GetBatchSize() uint32 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

func (m *CreateSpec) GetMaxInstanceRetries() uint32 {
	if m != nil {
		return m.MaxInstanceRetries
	}
	return 0
}

func (m *CreateSpec) GetMaxTolerableInstanceFailures() uint32 {
	if m != nil {
		return m.MaxTolerableInstanceFailures
	}
	return 0
}

func (m *CreateSpec) GetStartPaused() bool {
	if m != nil {
		return m.StartPaused
	}
	return false
}

// Configuration of a job restart
type RestartSpec struct {
	// Batch size for the restart which controls how many
	// instances may be restarted at the same time.
	BatchSize uint32 `protobuf:"varint,1,opt,name=batch_size,json=batchSize,proto3" json:"batch_size,omitempty"`
	// The pods to restart, default to all.
	Ranges []*pod.InstanceIDRange `protobuf:"bytes,2,rep,name=ranges,proto3" json:"ranges,omitempty"`
	// If set to true, peloton would try to place the task
	// restarted on the host it previously run on.
	// It is best effort, and has no guarantee of success.
	InPlace              bool     `protobuf:"varint,3,opt,name=in_place,json=inPlace,proto3" json:"in_place,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RestartSpec) Reset()         { *m = RestartSpec{} }
func (m *RestartSpec) String() string { return proto.CompactTextString(m) }
func (*RestartSpec) ProtoMessage()    {}
func (*RestartSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_859713a7fd7bfab2, []int{9}
}

func (m *RestartSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RestartSpec.Unmarshal(m, b)
}
func (m *RestartSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RestartSpec.Marshal(b, m, deterministic)
}
func (m *RestartSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestartSpec.Merge(m, src)
}
func (m *RestartSpec) XXX_Size() int {
	return xxx_messageInfo_RestartSpec.Size(m)
}
func (m *RestartSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RestartSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RestartSpec proto.InternalMessageInfo

func (m *RestartSpec) GetBatchSize() uint32 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

func (m *RestartSpec) GetRanges() []*pod.InstanceIDRange {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *RestartSpec) GetInPlace() bool {
	if m != nil {
		return m.InPlace
	}
	return false
}

// Information about a workflow including its status and specification
type WorkflowInfo struct {
	// Workflow status
	Status *WorkflowStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// Update specification for update workflow
	UpdateSpec *UpdateSpec `protobuf:"bytes,2,opt,name=update_spec,json=updateSpec,proto3" json:"update_spec,omitempty"`
	// Restart specification provided for restart workflow
	RestartSpec *RestartSpec `protobuf:"bytes,3,opt,name=restart_spec,json=restartSpec,proto3" json:"restart_spec,omitempty"`
	// Opaque data supplied by the client
	OpaqueData *peloton.OpaqueData `protobuf:"bytes,6,opt,name=opaque_data,json=opaqueData,proto3" json:"opaque_data,omitempty"`
	// job workflow events represents update state changes
	Events []*WorkflowEvent `protobuf:"bytes,7,rep,name=events,proto3" json:"events,omitempty"`
	// Instances added by update workflow
	InstancesAdded []*pod.InstanceIDRange `protobuf:"bytes,8,rep,name=instances_added,json=instancesAdded,proto3" json:"instances_added,omitempty"`
	// Instances removed by update workflow
	InstancesRemoved []*pod.InstanceIDRange `protobuf:"bytes,9,rep,name=instances_removed,json=instancesRemoved,proto3" json:"instances_removed,omitempty"`
	// Instances updated by update workflow
	InstancesUpdated     []*pod.InstanceIDRange                `protobuf:"bytes,10,rep,name=instances_updated,json=instancesUpdated,proto3" json:"instances_updated,omitempty"`
	InstanceEvents       []*WorkflowInfoInstanceWorkflowEvents `protobuf:"bytes,11,rep,name=instance_events,json=instanceEvents,proto3" json:"instance_events,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *WorkflowInfo) Reset()         { *m = WorkflowInfo{} }
func (m *WorkflowInfo) String() string { return proto.CompactTextString(m) }
func (*WorkflowInfo) ProtoMessage()    {}
func (*WorkflowInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_859713a7fd7bfab2, []int{10}
}

func (m *WorkflowInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WorkflowInfo.Unmarshal(m, b)
}
func (m *WorkflowInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WorkflowInfo.Marshal(b, m, deterministic)
}
func (m *WorkflowInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowInfo.Merge(m, src)
}
func (m *WorkflowInfo) XXX_Size() int {
	return xxx_messageInfo_WorkflowInfo.Size(m)
}
func (m *WorkflowInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowInfo.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowInfo proto.InternalMessageInfo

func (m *WorkflowInfo) GetStatus() *WorkflowStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *WorkflowInfo) GetUpdateSpec() *UpdateSpec {
	if m != nil {
		return m.UpdateSpec
	}
	return nil
}

func (m *WorkflowInfo) GetRestartSpec() *RestartSpec {
	if m != nil {
		return m.RestartSpec
	}
	return nil
}

func (m *WorkflowInfo) GetOpaqueData() *peloton.OpaqueData {
	if m != nil {
		return m.OpaqueData
	}
	return nil
}

func (m *WorkflowInfo) GetEvents() []*WorkflowEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *WorkflowInfo) GetInstancesAdded() []*pod.InstanceIDRange {
	if m != nil {
		return m.InstancesAdded
	}
	return nil
}

func (m *WorkflowInfo) GetInstancesRemoved() []*pod.InstanceIDRange {
	if m != nil {
		return m.InstancesRemoved
	}
	return nil
}

func (m *WorkflowInfo) GetInstancesUpdated() []*pod.InstanceIDRange {
	if m != nil {
		return m.InstancesUpdated
	}
	return nil
}

func (m *WorkflowInfo) GetInstanceEvents() []*WorkflowInfoInstanceWorkflowEvents {
	if m != nil {
		return m.InstanceEvents
	}
	return nil
}

type WorkflowInfoInstanceWorkflowEvents struct {
	// The instance ID
	InstanceId uint32 `protobuf:"varint,1,opt,name=instance_id,json=instanceId,proto3" json:"instance_id,omitempty"`
	// Instance workflow events
	Events               []*WorkflowEvent `protobuf:"bytes,2,rep,name=events,proto3" json:"events,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *WorkflowInfoInstanceWorkflowEvents) Reset()         { *m = WorkflowInfoInstanceWorkflowEvents{} }
func (m *WorkflowInfoInstanceWorkflowEvents) String() string { return proto.CompactTextString(m) }
func (*WorkflowInfoInstanceWorkflowEvents) ProtoMessage()    {}
func (*WorkflowInfoInstanceWorkflowEvents) Descriptor() ([]byte, []int) {
	return fileDescriptor_859713a7fd7bfab2, []int{10, 0}
}

func (m *WorkflowInfoInstanceWorkflowEvents) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WorkflowInfoInstanceWorkflowEvents.Unmarshal(m, b)
}
func (m *WorkflowInfoInstanceWorkflowEvents) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WorkflowInfoInstanceWorkflowEvents.Marshal(b, m, deterministic)
}
func (m *WorkflowInfoInstanceWorkflowEvents) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowInfoInstanceWorkflowEvents.Merge(m, src)
}
func (m *WorkflowInfoInstanceWorkflowEvents) XXX_Size() int {
	return xxx_messageInfo_WorkflowInfoInstanceWorkflowEvents.Size(m)
}
func (m *WorkflowInfoInstanceWorkflowEvents) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowInfoInstanceWorkflowEvents.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowInfoInstanceWorkflowEvents proto.InternalMessageInfo

func (m *WorkflowInfoInstanceWorkflowEvents) GetInstanceId() uint32 {
	if m != nil {
		return m.InstanceId
	}
	return 0
}

func (m *WorkflowInfoInstanceWorkflowEvents) GetEvents() []*WorkflowEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

// WorkflowEvents are workflow state change events for a job or pod
// on workflow operations
type WorkflowEvent struct {
	// Workflow type.
	Type WorkflowType `protobuf:"varint,1,opt,name=type,proto3,enum=peloton.api.v1alpha.job.stateless.WorkflowType" json:"type,omitempty"`
	// Timestamp of the event represented in RFC3339
	// form with UTC timezone.
	Timestamp string `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Current runtime state of the workflow.
	State                WorkflowState `protobuf:"varint,3,opt,name=state,proto3,enum=peloton.api.v1alpha.job.stateless.WorkflowState" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *WorkflowEvent) Reset()         { *m = WorkflowEvent{} }
func (m *WorkflowEvent) String() string { return proto.CompactTextString(m) }
func (*WorkflowEvent) ProtoMessage()    {}
func (*WorkflowEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_859713a7fd7bfab2, []int{11}
}

func (m *WorkflowEvent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WorkflowEvent.Unmarshal(m, b)
}
func (m *WorkflowEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WorkflowEvent.Marshal(b, m, deterministic)
}
func (m *WorkflowEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowEvent.Merge(m, src)
}
func (m *WorkflowEvent) XXX_Size() int {
	return xxx_messageInfo_WorkflowEvent.Size(m)
}
func (m *WorkflowEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowEvent.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowEvent proto.InternalMessageInfo

func (m *WorkflowEvent) GetType() WorkflowType {
	if m != nil {
		return m.Type
	}
	return WorkflowType_WORKFLOW_TYPE_INVALID
}

func (m *WorkflowEvent) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *WorkflowEvent) GetState() WorkflowState {
	if m != nil {
		return m.State
	}
	return WorkflowState_WORKFLOW_STATE_INVALID
}

func init() {
	proto.RegisterEnum("peloton.api.v1alpha.job.stateless.JobState", JobState_name, JobState_value)
	proto.RegisterEnum("peloton.api.v1alpha.job.stateless.WorkflowType", WorkflowType_name, WorkflowType_value)
	proto.RegisterEnum("peloton.api.v1alpha.job.stateless.WorkflowState", WorkflowState_name, WorkflowState_value)
	proto.RegisterType((*SlaSpec)(nil), "peloton.api.v1alpha.job.stateless.SlaSpec")
	proto.RegisterType((*JobSpec)(nil), "peloton.api.v1alpha.job.stateless.JobSpec")
	proto.RegisterMapType((map[uint32]*pod.PodSpec)(nil), "peloton.api.v1alpha.job.stateless.JobSpec.InstanceSpecEntry")
	proto.RegisterType((*WorkflowStatus)(nil), "peloton.api.v1alpha.job.stateless.WorkflowStatus")
	proto.RegisterType((*JobStatus)(nil), "peloton.api.v1alpha.job.stateless.JobStatus")
	proto.RegisterMapType((map[string]uint32)(nil), "peloton.api.v1alpha.job.stateless.JobStatus.PodConfigurationVersionStatsEntry")
	proto.RegisterMapType((map[string]*JobStatus_PodStateStats)(nil), "peloton.api.v1alpha.job.stateless.JobStatus.PodStatsByConfigurationVersionEntry")
	proto.RegisterMapType((map[string]uint32)(nil), "peloton.api.v1alpha.job.stateless.JobStatus.PodStatsEntry")
	proto.RegisterType((*JobStatus_PodStateStats)(nil), "peloton.api.v1alpha.job.stateless.JobStatus.PodStateStats")
	proto.RegisterMapType((map[string]uint32)(nil), "peloton.api.v1alpha.job.stateless.JobStatus.PodStateStats.StateStatsEntry")
	proto.RegisterType((*JobInfo)(nil), "peloton.api.v1alpha.job.stateless.JobInfo")
	proto.RegisterType((*JobSummary)(nil), "peloton.api.v1alpha.job.stateless.JobSummary")
	proto.RegisterType((*QuerySpec)(nil), "peloton.api.v1alpha.job.stateless.QuerySpec")
	proto.RegisterType((*UpdateSpec)(nil), "peloton.api.v1alpha.job.stateless.UpdateSpec")
	proto.RegisterType((*CreateSpec)(nil), "peloton.api.v1alpha.job.stateless.CreateSpec")
	proto.RegisterType((*RestartSpec)(nil), "peloton.api.v1alpha.job.stateless.RestartSpec")
	proto.RegisterType((*WorkflowInfo)(nil), "peloton.api.v1alpha.job.stateless.WorkflowInfo")
	proto.RegisterType((*WorkflowInfoInstanceWorkflowEvents)(nil), "peloton.api.v1alpha.job.stateless.WorkflowInfo.instance_workflow_events")
	proto.RegisterType((*WorkflowEvent)(nil), "peloton.api.v1alpha.job.stateless.WorkflowEvent")
}

func init() {
	proto.RegisterFile("peloton/api/v1alpha/job/stateless/stateless.proto", fileDescriptor_859713a7fd7bfab2)
}

var fileDescriptor_859713a7fd7bfab2 = []byte{
	// 2033 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x59, 0xcb, 0x73, 0x1b, 0x49,
	0x19, 0x47, 0x92, 0xf5, 0xfa, 0x24, 0x39, 0x4a, 0x27, 0x61, 0xb5, 0xda, 0x6c, 0xe2, 0x28, 0x15,
	0xd6, 0x9b, 0xb0, 0xf2, 0xc6, 0x54, 0x6d, 0x41, 0x58, 0x28, 0x64, 0x49, 0x4e, 0x94, 0x18, 0x4b,
	0x69, 0xcb, 0x71, 0x91, 0x03, 0x53, 0x2d, 0x4d, 0xdb, 0x19, 0x7b, 0x5e, 0x99, 0x87, 0x1c, 0xed,
	0x9d, 0x03, 0x55, 0x70, 0x84, 0x13, 0x17, 0xaa, 0xb8, 0x70, 0xe4, 0x0a, 0x27, 0x0e, 0x14, 0x55,
	0x1c, 0xf9, 0x73, 0x38, 0x51, 0xfd, 0x98, 0x97, 0x2d, 0xdb, 0x92, 0x9c, 0x43, 0xe2, 0x99, 0xef,
	0xd5, 0x5f, 0xff, 0xbe, 0xaf, 0xbb, 0x7f, 0x3d, 0x82, 0xa7, 0x36, 0xd5, 0x2d, 0xcf, 0x32, 0x37,
	0x88, 0xad, 0x6d, 0x4c, 0x9e, 0x12, 0xdd, 0x7e, 0x47, 0x36, 0x8e, 0xad, 0xd1, 0x86, 0xeb, 0x11,
	0x8f, 0xea, 0xd4, 0x75, 0xa3, 0xa7, 0xa6, 0xed, 0x58, 0x9e, 0x85, 0x1e, 0x48, 0x97, 0x26, 0xb1,
	0xb5, 0xa6, 0x74, 0x69, 0x1e, 0x5b, 0xa3, 0x66, 0x68, 0x58, 0x7f, 0x30, 0x2b, 0x6a, 0xe0, 0xc6,
	0xa3, 0x5c, 0x60, 0x62, 0xa9, 0xec, 0x9f, 0x34, 0x79, 0x34, 0xcb, 0xe4, 0xbd, 0x4f, 0x9d, 0xa9,
	0xf8, 0x5f, 0x9a, 0x7d, 0x39, 0xcb, 0xcc, 0xa1, 0xae, 0x6d, 0x59, 0x7a, 0xf0, 0x57, 0x98, 0x36,
	0xfe, 0x9a, 0x82, 0xfc, 0x9e, 0x4e, 0xf6, 0x6c, 0x3a, 0x46, 0x75, 0x28, 0xd8, 0x8e, 0x66, 0x39,
	0x9a, 0x37, 0xad, 0xa5, 0xd6, 0x52, 0xeb, 0x15, 0x1c, 0xbe, 0xa3, 0x35, 0x28, 0xd9, 0x0e, 0xa5,
	0x86, 0xed, 0x69, 0x23, 0x9d, 0xd6, 0xd2, 0x6b, 0xa9, 0xf5, 0x02, 0x8e, 0x8b, 0xd0, 0x5d, 0x28,
	0x3a, 0x74, 0x62, 0x8d, 0x09, 0xd3, 0x67, 0xb8, 0x3e, 0x12, 0xa0, 0x2d, 0xf8, 0xdc, 0x20, 0x1f,
	0x34, 0xc3, 0x37, 0x14, 0xdf, 0x24, 0x13, 0xa2, 0xe9, 0x4c, 0xac, 0x68, 0xa6, 0xeb, 0x11, 0x73,
	0x4c, 0xdd, 0xda, 0x0a, 0x1f, 0xf0, 0x33, 0x69, 0xb4, 0x1f, 0xd9, 0xf4, 0x02, 0x93, 0xc6, 0x7f,
	0xb3, 0x90, 0x7f, 0x69, 0x8d, 0x78, 0xae, 0x2d, 0x28, 0x38, 0x74, 0xa2, 0xb9, 0x9a, 0x65, 0xf2,
	0x5c, 0x4b, 0x9b, 0x8f, 0x9a, 0xb3, 0xaa, 0x10, 0xc8, 0xb0, 0x34, 0xc6, 0xa1, 0x1b, 0x42, 0xb0,
	0x62, 0x12, 0x43, 0xcc, 0xa5, 0x88, 0xf9, 0x33, 0xba, 0x0d, 0x59, 0xeb, 0xd4, 0xa4, 0x0e, 0x9f,
	0x40, 0x11, 0x8b, 0x17, 0x74, 0x1f, 0x4a, 0xd6, 0xa9, 0xa9, 0x99, 0x47, 0x8a, 0x47, 0x89, 0xc1,
	0x53, 0x2d, 0x62, 0x10, 0xa2, 0x21, 0x25, 0x06, 0x33, 0xd0, 0x55, 0x62, 0x2b, 0x47, 0x8e, 0xe5,
	0xdb, 0x6e, 0x2d, 0xbb, 0x96, 0x61, 0x06, 0x4c, 0xf4, 0x9c, 0x4b, 0x18, 0x7c, 0x2a, 0x75, 0xc7,
	0x8e, 0x66, 0x7b, 0x2c, 0xe3, 0x1c, 0x8f, 0x10, 0x17, 0xa1, 0x67, 0x90, 0xd3, 0xc9, 0x88, 0xea,
	0x6e, 0x2d, 0xbf, 0x96, 0x59, 0x2f, 0x6d, 0x36, 0x2e, 0x9d, 0xce, 0x0e, 0x33, 0xc5, 0xd2, 0x03,
	0x3d, 0x82, 0xd5, 0x00, 0x48, 0x65, 0x6c, 0xf9, 0xa6, 0x57, 0x2b, 0x70, 0x34, 0x2b, 0x81, 0xb4,
	0xcd, 0x84, 0xe8, 0x5b, 0xc8, 0xb8, 0x3a, 0xa9, 0x15, 0x39, 0x5c, 0x8f, 0x9b, 0x57, 0x36, 0x6d,
	0x53, 0x36, 0x06, 0x66, 0x6e, 0xa8, 0x0d, 0x65, 0x95, 0x1e, 0x12, 0x5f, 0xf7, 0x14, 0xd7, 0xa6,
	0xe3, 0x1a, 0xf0, 0x30, 0x6b, 0xb3, 0xd3, 0xb4, 0xd4, 0xe6, 0xc0, 0x52, 0xb9, 0x73, 0x49, 0x7a,
	0xf1, 0xb2, 0x11, 0x08, 0x73, 0x12, 0x51, 0x4a, 0x7c, 0xb2, 0xdf, 0xce, 0x91, 0x8c, 0xac, 0x7c,
	0x33, 0xe8, 0x07, 0xf6, 0xd2, 0x35, 0x3d, 0x67, 0x8a, 0xcb, 0x5a, 0x4c, 0x84, 0x5e, 0x02, 0xc8,
	0x16, 0x57, 0x34, 0xb5, 0x56, 0xe6, 0x59, 0x3e, 0xb9, 0xa2, 0x37, 0x5c, 0xcb, 0x77, 0xc6, 0x74,
	0x60, 0x59, 0x7a, 0xaf, 0xc3, 0xba, 0x96, 0xbb, 0xf7, 0xd4, 0x3a, 0x81, 0x9b, 0xe7, 0x86, 0x43,
	0x55, 0xc8, 0x9c, 0xd0, 0x60, 0x85, 0xb0, 0x47, 0xf4, 0x0d, 0x64, 0x27, 0x44, 0xf7, 0x45, 0x2b,
	0xcd, 0x83, 0x89, 0x30, 0x7f, 0x96, 0xfe, 0x71, 0xaa, 0xf1, 0xcf, 0x2c, 0xac, 0x1e, 0x58, 0xce,
	0xc9, 0xa1, 0x6e, 0x9d, 0xee, 0x79, 0xc4, 0xf3, 0x5d, 0xd4, 0x86, 0x15, 0x6f, 0x6a, 0x53, 0x3e,
	0xc2, 0xea, 0xe6, 0xc6, 0x1c, 0xd8, 0x04, 0x01, 0x86, 0x53, 0x9b, 0x62, 0xee, 0x8c, 0xb6, 0x21,
	0xcb, 0xf5, 0x3c, 0xa7, 0xd5, 0xcd, 0xaf, 0x17, 0x88, 0xc2, 0xd2, 0xa0, 0x58, 0xb8, 0xa3, 0x6f,
	0xe0, 0x13, 0xd3, 0x37, 0xa2, 0x85, 0xaa, 0x8c, 0x2d, 0xc3, 0xd6, 0xa9, 0x47, 0x55, 0xbe, 0x46,
	0x2a, 0xf8, 0x8e, 0xe9, 0x1b, 0xe1, 0x1a, 0x6d, 0x07, 0xca, 0xf3, 0x7e, 0x0e, 0x35, 0x88, 0xc6,
	0x56, 0x8c, 0x5c, 0xea, 0x09, 0x3f, 0x1c, 0x28, 0xd1, 0xd7, 0x70, 0x3b, 0xe9, 0x77, 0x48, 0x34,
	0x9d, 0xaa, 0xb5, 0x2c, 0x77, 0x42, 0x71, 0xa7, 0x6d, 0xae, 0x41, 0x4f, 0xe0, 0x66, 0x2c, 0x3b,
	0xdf, 0x71, 0xa8, 0xe9, 0xd5, 0x72, 0x6b, 0x99, 0xf5, 0x0a, 0xae, 0x86, 0x8a, 0xb6, 0x90, 0xa3,
	0x0e, 0xe4, 0x27, 0xd4, 0xe1, 0xdb, 0x46, 0xfe, 0x92, 0x75, 0x10, 0xc8, 0xba, 0xa6, 0xa7, 0x79,
	0xd3, 0x37, 0xc2, 0x03, 0x07, 0xae, 0xe8, 0x97, 0x50, 0xb6, 0x1d, 0x3a, 0x51, 0x82, 0x50, 0x85,
	0x85, 0x43, 0xb1, 0xad, 0x73, 0x22, 0x5f, 0xd0, 0x43, 0xa8, 0x8c, 0x1d, 0x4a, 0xd8, 0x3e, 0xa0,
	0x78, 0x9a, 0x41, 0xf9, 0x12, 0x2d, 0xe2, 0x72, 0x20, 0x1c, 0x6a, 0x06, 0x65, 0x7b, 0x8c, 0x6f,
	0xab, 0xc4, 0xa3, 0xc2, 0x04, 0xc4, 0x26, 0x24, 0x44, 0xdc, 0xa0, 0x0f, 0xc0, 0x93, 0x12, 0x65,
	0x2f, 0x2d, 0x59, 0xf6, 0x22, 0x8b, 0xc1, 0x1f, 0xd1, 0x17, 0x70, 0x43, 0x16, 0x3b, 0x4c, 0xac,
	0xcc, 0x47, 0x5d, 0x8d, 0xc4, 0x6c, 0xe4, 0xc6, 0x1f, 0x01, 0x8a, 0x6c, 0x79, 0x8a, 0xf6, 0xfd,
	0x08, 0x5b, 0x73, 0x2b, 0xd9, 0xbc, 0x4f, 0xe6, 0xdc, 0x1e, 0xe2, 0x7d, 0x7b, 0x0e, 0xd3, 0xcc,
	0x0c, 0x4c, 0x0f, 0xa0, 0x68, 0x5b, 0x2a, 0x47, 0x8c, 0x9d, 0x40, 0x6c, 0x2b, 0x7a, 0x36, 0xff,
	0x58, 0xbe, 0xcb, 0x17, 0x34, 0x73, 0x16, 0x1b, 0x51, 0xc1, 0x96, 0xaf, 0x68, 0x00, 0x15, 0x95,
	0xba, 0x9a, 0x43, 0x55, 0x59, 0x8e, 0xec, 0xe2, 0x13, 0x29, 0xcb, 0x08, 0xa2, 0x18, 0xb1, 0xc6,
	0xcd, 0x2d, 0xdf, 0xb8, 0x6f, 0xe1, 0xc6, 0xa9, 0x2c, 0x37, 0x4f, 0xcc, 0x77, 0xe5, 0x32, 0x78,
	0xba, 0x60, 0xa3, 0xf8, 0x2e, 0x5e, 0x3d, 0x4d, 0x6e, 0x5b, 0x7f, 0x48, 0xc1, 0x7d, 0x86, 0xe6,
	0xd8, 0x32, 0x0f, 0xb5, 0x23, 0xdf, 0x11, 0xd8, 0xcb, 0x91, 0x25, 0xc6, 0x05, 0x8e, 0xf1, 0xee,
	0xa2, 0x18, 0xb7, 0xe3, 0x21, 0xe5, 0xa4, 0x62, 0xb8, 0xdf, 0xb5, 0x2f, 0x31, 0x41, 0x7f, 0x4a,
	0x41, 0x23, 0xac, 0xb2, 0x32, 0x9a, 0xce, 0x4e, 0xb0, 0x56, 0xe4, 0xa9, 0x0d, 0x96, 0x2a, 0xff,
	0xd6, 0x74, 0xd6, 0xf0, 0x22, 0xb9, 0x7b, 0xf6, 0xa5, 0x46, 0xf5, 0x7f, 0xa4, 0xa0, 0x22, 0xe3,
	0x50, 0x91, 0xf0, 0x09, 0x94, 0xf8, 0x60, 0x12, 0xb3, 0x14, 0x4f, 0xec, 0xe5, 0x32, 0x89, 0x89,
	0x80, 0xcd, 0xe8, 0x51, 0xa4, 0x04, 0x6e, 0x28, 0xa8, 0xff, 0x0c, 0x6e, 0x9c, 0x51, 0xc7, 0x0f,
	0xb8, 0xa2, 0x38, 0xe0, 0x6e, 0xc7, 0x0f, 0xb8, 0x4a, 0xec, 0xf8, 0xaa, 0xff, 0x34, 0x4c, 0x7e,
	0x09, 0xe7, 0x3e, 0x3c, 0xb8, 0xb2, 0xb8, 0x0b, 0x05, 0xfc, 0x7d, 0x0a, 0x1e, 0xce, 0x51, 0x93,
	0x19, 0x31, 0x07, 0xc9, 0x23, 0xfc, 0xd9, 0xf2, 0x68, 0xc7, 0x0f, 0xf7, 0xff, 0xa4, 0x38, 0x63,
	0xed, 0x99, 0x87, 0x16, 0xfa, 0x09, 0xe4, 0x8e, 0xad, 0x11, 0xe3, 0x24, 0x62, 0x53, 0xbc, 0x9c,
	0xe0, 0x31, 0xaf, 0x0e, 0xce, 0x1e, 0x5b, 0xa3, 0x9e, 0x8a, 0x7e, 0x0e, 0x2b, 0x9c, 0x2c, 0xa5,
	0xe7, 0x66, 0x6e, 0x92, 0x2c, 0x61, 0xee, 0x87, 0x3a, 0x90, 0x93, 0x8b, 0x3d, 0xc3, 0x23, 0xfc,
	0x70, 0x91, 0xd9, 0x61, 0xe9, 0xdb, 0xf8, 0x57, 0x06, 0x80, 0x49, 0x7d, 0xc3, 0x20, 0xce, 0xf4,
	0x3a, 0xf3, 0xb9, 0x94, 0x79, 0xaf, 0x5c, 0xc2, 0xbc, 0xb3, 0xe7, 0x98, 0x77, 0x44, 0x9b, 0x73,
	0x1f, 0x81, 0x36, 0xe7, 0x67, 0xd1, 0xe6, 0x24, 0xa1, 0x2c, 0x5c, 0x87, 0x50, 0xc6, 0x2a, 0x51,
	0x5c, 0xbe, 0x12, 0x01, 0x91, 0x87, 0xa5, 0x88, 0x7c, 0xe3, 0xcf, 0x2b, 0x50, 0x7c, 0xcd, 0x6e,
	0x8b, 0x9c, 0x2e, 0xf7, 0x00, 0x6c, 0x72, 0xa4, 0x99, 0x7c, 0x91, 0xc8, 0x52, 0x7e, 0x39, 0x33,
	0xa4, 0xb8, 0x61, 0x0e, 0x42, 0x63, 0x1e, 0x31, 0xe6, 0x1c, 0xab, 0x45, 0x7a, 0xe1, 0x5a, 0xd4,
	0xa1, 0x70, 0x42, 0xa7, 0xa7, 0x96, 0xa3, 0xb2, 0x26, 0x65, 0xd7, 0xa7, 0xf0, 0x9d, 0x15, 0x80,
	0x75, 0x1a, 0x9f, 0x8e, 0x38, 0xa6, 0x17, 0x3c, 0x49, 0x8b, 0xc7, 0xf2, 0xc9, 0x45, 0xcf, 0x21,
	0x2f, 0xab, 0xc1, 0x9b, 0xa9, 0xb4, 0xf9, 0xd5, 0xcc, 0x40, 0xc1, 0x25, 0x39, 0x5e, 0xc9, 0x01,
	0xf1, 0xde, 0xe1, 0xc0, 0x3b, 0xea, 0xd7, 0x5c, 0xbc, 0x5f, 0x83, 0xce, 0xce, 0xc7, 0x3a, 0xfb,
	0x0d, 0xdc, 0x4a, 0x30, 0x11, 0xc5, 0x21, 0xe6, 0x11, 0x95, 0x8d, 0xf4, 0x83, 0x4b, 0x31, 0x62,
	0x24, 0x05, 0x33, 0x6b, 0x7c, 0x33, 0xce, 0x5b, 0xb8, 0x08, 0xbd, 0x85, 0x3b, 0x67, 0xe8, 0x99,
	0x8c, 0x5c, 0x5c, 0x28, 0xf2, 0xad, 0x24, 0x99, 0xe3, 0xc2, 0xc6, 0xdf, 0xd2, 0x00, 0xfb, 0x9c,
	0x5a, 0xf2, 0x26, 0xf9, 0x1c, 0x60, 0x44, 0xbc, 0xf1, 0x3b, 0xc5, 0xd5, 0xbe, 0xa3, 0xf2, 0xe6,
	0x53, 0xe4, 0x92, 0x3d, 0xed, 0x3b, 0x8a, 0x9a, 0x70, 0xcb, 0xb1, 0x74, 0x7d, 0x44, 0xc6, 0x27,
	0x8a, 0x65, 0x72, 0xc6, 0xee, 0x3b, 0xc1, 0x47, 0x82, 0x9b, 0x81, 0xaa, 0x6f, 0x6e, 0x0b, 0x05,
	0xe3, 0xf8, 0x06, 0xf9, 0x10, 0x72, 0x7c, 0xc5, 0xa1, 0x9e, 0xa3, 0x51, 0x57, 0x5e, 0x28, 0x90,
	0x41, 0x3e, 0x04, 0x1c, 0x1f, 0x0b, 0x0d, 0xea, 0xc2, 0x7d, 0xe6, 0xe1, 0x59, 0x3a, 0x75, 0x12,
	0x1f, 0x0e, 0x82, 0xc1, 0x82, 0x0f, 0x08, 0x77, 0x0d, 0xf2, 0x61, 0x18, 0x58, 0x05, 0x51, 0xe4,
	0xb8, 0x2e, 0x7a, 0x00, 0x65, 0xd7, 0x23, 0x8e, 0xa7, 0xd8, 0xc4, 0x77, 0xe5, 0xa5, 0xa2, 0x80,
	0x4b, 0x5c, 0x36, 0xe0, 0x22, 0xf4, 0x29, 0x14, 0x34, 0x53, 0xb1, 0x75, 0x32, 0xa6, 0xbc, 0xb4,
	0x05, 0x9c, 0xd7, 0xcc, 0x01, 0x7b, 0x65, 0x28, 0x48, 0x6f, 0x4b, 0x15, 0xbc, 0xa9, 0x80, 0x8b,
	0xc2, 0xd7, 0x52, 0xdd, 0xc6, 0xbf, 0x53, 0x00, 0x6d, 0x56, 0xa5, 0xb9, 0x30, 0xbb, 0x08, 0x83,
	0xf4, 0x75, 0x30, 0xc8, 0x2c, 0x81, 0xc1, 0xca, 0x39, 0x0c, 0x1a, 0xbf, 0x4d, 0x41, 0x09, 0x53,
	0x2e, 0x99, 0x67, 0x2a, 0xbf, 0x80, 0x1c, 0x6f, 0xbc, 0x60, 0xdd, 0xaf, 0x5f, 0x78, 0xff, 0x0d,
	0x92, 0xe9, 0x75, 0x44, 0xef, 0x49, 0xbf, 0x04, 0xe8, 0x99, 0x04, 0xe8, 0x8d, 0xdf, 0xe5, 0xa1,
	0x1c, 0x10, 0x4f, 0x7e, 0x8e, 0xf6, 0xc2, 0x2d, 0x34, 0xb5, 0x2c, 0x73, 0x0d, 0xf6, 0xd1, 0xdd,
	0xf0, 0x4a, 0x15, 0x3b, 0x5e, 0xbf, 0x9a, 0x23, 0x5e, 0xb4, 0x34, 0x82, 0x1b, 0x18, 0xc7, 0xe9,
	0x35, 0x94, 0x1d, 0x01, 0x9b, 0x08, 0x28, 0x4e, 0xdb, 0xe6, 0x1c, 0x01, 0x63, 0x68, 0xe3, 0x92,
	0x13, 0x83, 0xfe, 0x05, 0x94, 0x2c, 0x9b, 0xbc, 0xf7, 0xa9, 0xa2, 0x12, 0x8f, 0x48, 0xea, 0xff,
	0xc5, 0xa5, 0x4b, 0xbb, 0xcf, 0xed, 0x3b, 0xc4, 0x23, 0x18, 0xac, 0xf0, 0x19, 0xbd, 0x80, 0x1c,
	0x9d, 0x50, 0xd3, 0x0b, 0x3e, 0x30, 0x2d, 0x72, 0x35, 0xec, 0x32, 0x47, 0x2c, 0xfd, 0xd1, 0x6b,
	0xb8, 0x11, 0x5d, 0xb8, 0x89, 0xaa, 0x52, 0x55, 0xf2, 0xfa, 0xf9, 0x0b, 0x1f, 0x1e, 0xbc, 0x6e,
	0x8b, 0xf9, 0xa3, 0xfd, 0xf8, 0x1d, 0xde, 0xa1, 0x86, 0x35, 0xa1, 0xaa, 0x64, 0xe4, 0xf3, 0x07,
	0x8d, 0x6e, 0xfb, 0x58, 0x44, 0x48, 0x86, 0x15, 0x85, 0x52, 0x6b, 0xb0, 0x74, 0x58, 0x51, 0x76,
	0x15, 0xbd, 0x8f, 0x00, 0x50, 0x24, 0xa6, 0xe2, 0x3b, 0xd6, 0x8b, 0x05, 0x30, 0x65, 0xcd, 0xdc,
	0x0c, 0xc3, 0x84, 0xb7, 0x32, 0x11, 0x2f, 0x02, 0x88, 0x43, 0xef, 0xd6, 0x7f, 0x93, 0x82, 0xda,
	0x45, 0xc6, 0x8c, 0x25, 0x85, 0x3a, 0xc9, 0xc7, 0x2a, 0x18, 0x02, 0x51, 0x4f, 0x8d, 0xd5, 0x3e,
	0x7d, 0xbd, 0xda, 0x37, 0xfe, 0x9e, 0x82, 0x4a, 0x42, 0xf3, 0x71, 0xbe, 0x56, 0xdd, 0x85, 0x22,
	0x3b, 0xc0, 0x5c, 0x8f, 0x18, 0xb6, 0xa4, 0x85, 0x91, 0x20, 0xfa, 0x96, 0x95, 0xb9, 0xd6, 0xb7,
	0xac, 0xc7, 0xff, 0x4b, 0x41, 0x21, 0x20, 0x05, 0xe8, 0x0e, 0xdc, 0x7c, 0xd9, 0xdf, 0x52, 0xf6,
	0x86, 0xad, 0x61, 0x57, 0xe9, 0xed, 0xbe, 0x69, 0xed, 0xf4, 0x3a, 0xd5, 0xef, 0xa1, 0x4f, 0xe1,
	0x4e, 0x5c, 0xdc, 0x1b, 0xf6, 0x5a, 0x3b, 0xbd, 0xb7, 0xdd, 0x4e, 0x35, 0x95, 0xf4, 0x18, 0x74,
	0x77, 0x3b, 0xbd, 0xdd, 0xe7, 0xd5, 0x74, 0x52, 0x8c, 0xf7, 0x77, 0x77, 0x99, 0x38, 0x83, 0x3e,
	0x81, 0x5b, 0x91, 0x78, 0x6f, 0xbf, 0xdd, 0xee, 0x76, 0x3b, 0xdd, 0x4e, 0x75, 0x05, 0xdd, 0x86,
	0x6a, 0xa4, 0xd8, 0x6e, 0xf5, 0x76, 0xba, 0x9d, 0x6a, 0x36, 0x29, 0x7d, 0xd5, 0xdb, 0x61, 0xd2,
	0x5c, 0x32, 0x36, 0x93, 0xb2, 0xd8, 0x79, 0xf4, 0x19, 0x7c, 0x12, 0x89, 0xf7, 0x77, 0xe3, 0x69,
	0x16, 0x92, 0x3e, 0x9d, 0xee, 0x4e, 0x77, 0xd8, 0xed, 0x54, 0x8b, 0x8f, 0x7f, 0x1d, 0xed, 0xa3,
	0x0c, 0x78, 0x36, 0xd1, 0x83, 0x3e, 0x7e, 0xb5, 0xbd, 0xd3, 0x3f, 0x50, 0x86, 0xbf, 0x1a, 0xc4,
	0x31, 0xa8, 0xc1, 0xed, 0xa4, 0x6a, 0x7f, 0xd0, 0x69, 0x0d, 0xbb, 0xd5, 0xd4, 0x79, 0x27, 0xdc,
	0xdd, 0x1b, 0xb6, 0xf0, 0xb0, 0x9a, 0x7e, 0xfc, 0x97, 0x74, 0xd4, 0x19, 0x02, 0xe1, 0x3a, 0x7c,
	0x3f, 0x34, 0x3e, 0x0b, 0xf3, 0x3d, 0xa8, 0x9f, 0xd3, 0xc5, 0xb1, 0x6e, 0xc0, 0xbd, 0x33, 0x7a,
	0xdc, 0xe7, 0xb3, 0x57, 0xb6, 0xfb, 0xf8, 0xa0, 0x85, 0x3b, 0xd5, 0x74, 0x22, 0x19, 0x59, 0x94,
	0xd6, 0xfe, 0x5e, 0xb7, 0x53, 0xcd, 0xa0, 0xbb, 0x50, 0x3b, 0xa3, 0x8a, 0x57, 0xe0, 0x7c, 0x62,
	0xad, 0xad, 0x3e, 0x1e, 0xf2, 0x3a, 0x9c, 0x0f, 0x2a, 0x4b, 0x94, 0x43, 0x0f, 0xe1, 0xfe, 0x05,
	0x39, 0x6d, 0xb5, 0xda, 0xaf, 0x78, 0x52, 0xf9, 0x19, 0x13, 0x63, 0x46, 0xdd, 0x0e, 0xb7, 0xa9,
	0x16, 0xb6, 0xb6, 0xe1, 0xea, 0x5f, 0x8b, 0xde, 0x3e, 0xb8, 0xf2, 0x37, 0xa8, 0x51, 0x8e, 0xff,
	0x7e, 0xf3, 0xa3, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0xc7, 0x6a, 0x3f, 0x8e, 0xaf, 0x1a, 0x00,
	0x00,
}

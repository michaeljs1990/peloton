// Code generated by protoc-gen-go. DO NOT EDIT.
// source: peloton/api/v1alpha/pod/apachemesos/apachemesos.proto

package apachemesos

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type PodSpec_ContainerType int32

const (
	// Invalid container type
	PodSpec_CONTAINER_TYPE_INVALID PodSpec_ContainerType = 0
	// Use Docker containerizer
	PodSpec_CONTAINER_TYPE_DOCKER PodSpec_ContainerType = 1
	// Use Mesos containerizer
	PodSpec_CONTAINER_TYPE_MESOS PodSpec_ContainerType = 2
)

var PodSpec_ContainerType_name = map[int32]string{
	0: "CONTAINER_TYPE_INVALID",
	1: "CONTAINER_TYPE_DOCKER",
	2: "CONTAINER_TYPE_MESOS",
}

var PodSpec_ContainerType_value = map[string]int32{
	"CONTAINER_TYPE_INVALID": 0,
	"CONTAINER_TYPE_DOCKER":  1,
	"CONTAINER_TYPE_MESOS":   2,
}

func (x PodSpec_ContainerType) String() string {
	return proto.EnumName(PodSpec_ContainerType_name, int32(x))
}

func (PodSpec_ContainerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4e469d46b339c16c, []int{0, 0}
}

type PodSpec_ExecutorSpec_ExecutorType int32

const (
	PodSpec_ExecutorSpec_EXECUTOR_TYPE_INVALID PodSpec_ExecutorSpec_ExecutorType = 0
	// Mesos default executor
	PodSpec_ExecutorSpec_EXECUTOR_TYPE_DEFAULT PodSpec_ExecutorSpec_ExecutorType = 1
	// Custom Mesos executor like Thermos
	PodSpec_ExecutorSpec_EXECUTOR_TYPE_CUSTOM PodSpec_ExecutorSpec_ExecutorType = 2
)

var PodSpec_ExecutorSpec_ExecutorType_name = map[int32]string{
	0: "EXECUTOR_TYPE_INVALID",
	1: "EXECUTOR_TYPE_DEFAULT",
	2: "EXECUTOR_TYPE_CUSTOM",
}

var PodSpec_ExecutorSpec_ExecutorType_value = map[string]int32{
	"EXECUTOR_TYPE_INVALID": 0,
	"EXECUTOR_TYPE_DEFAULT": 1,
	"EXECUTOR_TYPE_CUSTOM":  2,
}

func (x PodSpec_ExecutorSpec_ExecutorType) String() string {
	return proto.EnumName(PodSpec_ExecutorSpec_ExecutorType_name, int32(x))
}

func (PodSpec_ExecutorSpec_ExecutorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4e469d46b339c16c, []int{0, 2, 0}
}

// Extra configuration only supported in the Mesos runtime.
type PodSpec struct {
	// Type of containerizer to use.
	Type PodSpec_ContainerType `protobuf:"varint,1,opt,name=type,proto3,enum=peloton.api.v1alpha.pod.apachemesos.PodSpec_ContainerType" json:"type,omitempty"`
	// Parameters to be passed to the Docker cli.
	DockerParameters []*PodSpec_DockerParameter `protobuf:"bytes,2,rep,name=docker_parameters,json=dockerParameters,proto3" json:"docker_parameters,omitempty"`
	// URIs fetched before executing the command.
	Uris []*PodSpec_URI `protobuf:"bytes,3,rep,name=uris,proto3" json:"uris,omitempty"`
	// If shell is set to true, then the command will be launched via shell.
	// TBD After this is supported by Kubelet runtime, move to pod.CommandSpec.
	Shell bool `protobuf:"varint,4,opt,name=shell,proto3" json:"shell,omitempty"`
	// The executor configuration
	ExecutorSpec         *PodSpec_ExecutorSpec `protobuf:"bytes,5,opt,name=executor_spec,json=executorSpec,proto3" json:"executor_spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *PodSpec) Reset()         { *m = PodSpec{} }
func (m *PodSpec) String() string { return proto.CompactTextString(m) }
func (*PodSpec) ProtoMessage()    {}
func (*PodSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e469d46b339c16c, []int{0}
}

func (m *PodSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PodSpec.Unmarshal(m, b)
}
func (m *PodSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PodSpec.Marshal(b, m, deterministic)
}
func (m *PodSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodSpec.Merge(m, src)
}
func (m *PodSpec) XXX_Size() int {
	return xxx_messageInfo_PodSpec.Size(m)
}
func (m *PodSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PodSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PodSpec proto.InternalMessageInfo

func (m *PodSpec) GetType() PodSpec_ContainerType {
	if m != nil {
		return m.Type
	}
	return PodSpec_CONTAINER_TYPE_INVALID
}

func (m *PodSpec) GetDockerParameters() []*PodSpec_DockerParameter {
	if m != nil {
		return m.DockerParameters
	}
	return nil
}

func (m *PodSpec) GetUris() []*PodSpec_URI {
	if m != nil {
		return m.Uris
	}
	return nil
}

func (m *PodSpec) GetShell() bool {
	if m != nil {
		return m.Shell
	}
	return false
}

func (m *PodSpec) GetExecutorSpec() *PodSpec_ExecutorSpec {
	if m != nil {
		return m.ExecutorSpec
	}
	return nil
}

// Arbitrary parameters to be passed to Docker CLI.
type PodSpec_DockerParameter struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PodSpec_DockerParameter) Reset()         { *m = PodSpec_DockerParameter{} }
func (m *PodSpec_DockerParameter) String() string { return proto.CompactTextString(m) }
func (*PodSpec_DockerParameter) ProtoMessage()    {}
func (*PodSpec_DockerParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e469d46b339c16c, []int{0, 0}
}

func (m *PodSpec_DockerParameter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PodSpec_DockerParameter.Unmarshal(m, b)
}
func (m *PodSpec_DockerParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PodSpec_DockerParameter.Marshal(b, m, deterministic)
}
func (m *PodSpec_DockerParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodSpec_DockerParameter.Merge(m, src)
}
func (m *PodSpec_DockerParameter) XXX_Size() int {
	return xxx_messageInfo_PodSpec_DockerParameter.Size(m)
}
func (m *PodSpec_DockerParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_PodSpec_DockerParameter.DiscardUnknown(m)
}

var xxx_messageInfo_PodSpec_DockerParameter proto.InternalMessageInfo

func (m *PodSpec_DockerParameter) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *PodSpec_DockerParameter) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// URIs specified are fetched before executing the command. If the
// executable field for an uri is set, executable file permission is set
// on the downloaded file. Otherwise, if the downloaded file has a recognized
// archive extension (currently [compressed] tar and zip) it is extracted into
// the executor's working directory. This extraction can be disabled by setting
// `extract` to false. In addition, any environment variables are set before
// executing the command (so they can be used to "parameterize" the command).
// This used to fetch binaries in stateless workloads and data bundles in batch workloads.
// TBD After this is supported by Kubelet runtime, it should be moved to pod.ContainerSpec.
type PodSpec_URI struct {
	Value      string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Executable bool   `protobuf:"varint,2,opt,name=executable,proto3" json:"executable,omitempty"`
	// In case the fetched file is recognized as an archive, extract
	// its contents into the sandbox. Note that a cached archive is
	// not copied from the cache to the sandbox in case extraction
	// originates from an archive in the cache.
	Extract bool `protobuf:"varint,3,opt,name=extract,proto3" json:"extract,omitempty"`
	// If this field is "true", the fetcher cache will be used. If not,
	// fetching bypasses the cache and downloads directly into the
	// sandbox directory, no matter whether a suitable cache file is
	// available or not. The former directs the fetcher to download to
	// the file cache, then copy from there to the sandbox. Subsequent
	// fetch attempts with the same URI will omit downloading and copy
	// from the cache as long as the file is resident there. Cache files
	// may get evicted at any time, which then leads to renewed downloading.
	Cache bool `protobuf:"varint,4,opt,name=cache,proto3" json:"cache,omitempty"`
	// The fetcher's default behavior is to use the URI string's basename to
	// name the local copy. If this field is provided, the local copy will be
	// named with its value instead. If there is a directory component (which
	// must be a relative path), the local copy will be stored in that
	// subdirectory inside the sandbox.
	OutputFile           string   `protobuf:"bytes,5,opt,name=output_file,json=outputFile,proto3" json:"output_file,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PodSpec_URI) Reset()         { *m = PodSpec_URI{} }
func (m *PodSpec_URI) String() string { return proto.CompactTextString(m) }
func (*PodSpec_URI) ProtoMessage()    {}
func (*PodSpec_URI) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e469d46b339c16c, []int{0, 1}
}

func (m *PodSpec_URI) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PodSpec_URI.Unmarshal(m, b)
}
func (m *PodSpec_URI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PodSpec_URI.Marshal(b, m, deterministic)
}
func (m *PodSpec_URI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodSpec_URI.Merge(m, src)
}
func (m *PodSpec_URI) XXX_Size() int {
	return xxx_messageInfo_PodSpec_URI.Size(m)
}
func (m *PodSpec_URI) XXX_DiscardUnknown() {
	xxx_messageInfo_PodSpec_URI.DiscardUnknown(m)
}

var xxx_messageInfo_PodSpec_URI proto.InternalMessageInfo

func (m *PodSpec_URI) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *PodSpec_URI) GetExecutable() bool {
	if m != nil {
		return m.Executable
	}
	return false
}

func (m *PodSpec_URI) GetExtract() bool {
	if m != nil {
		return m.Extract
	}
	return false
}

func (m *PodSpec_URI) GetCache() bool {
	if m != nil {
		return m.Cache
	}
	return false
}

func (m *PodSpec_URI) GetOutputFile() string {
	if m != nil {
		return m.OutputFile
	}
	return ""
}

// Configuration for the mesos executor.
type PodSpec_ExecutorSpec struct {
	// Executor type
	Type PodSpec_ExecutorSpec_ExecutorType `protobuf:"varint,1,opt,name=type,proto3,enum=peloton.api.v1alpha.pod.apachemesos.PodSpec_ExecutorSpec_ExecutorType" json:"type,omitempty"`
	// The executor identifier
	ExecutorId string `protobuf:"bytes,2,opt,name=executor_id,json=executorId,proto3" json:"executor_id,omitempty"`
	// Executor data
	Data                 []byte   `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PodSpec_ExecutorSpec) Reset()         { *m = PodSpec_ExecutorSpec{} }
func (m *PodSpec_ExecutorSpec) String() string { return proto.CompactTextString(m) }
func (*PodSpec_ExecutorSpec) ProtoMessage()    {}
func (*PodSpec_ExecutorSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e469d46b339c16c, []int{0, 2}
}

func (m *PodSpec_ExecutorSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PodSpec_ExecutorSpec.Unmarshal(m, b)
}
func (m *PodSpec_ExecutorSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PodSpec_ExecutorSpec.Marshal(b, m, deterministic)
}
func (m *PodSpec_ExecutorSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodSpec_ExecutorSpec.Merge(m, src)
}
func (m *PodSpec_ExecutorSpec) XXX_Size() int {
	return xxx_messageInfo_PodSpec_ExecutorSpec.Size(m)
}
func (m *PodSpec_ExecutorSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PodSpec_ExecutorSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PodSpec_ExecutorSpec proto.InternalMessageInfo

func (m *PodSpec_ExecutorSpec) GetType() PodSpec_ExecutorSpec_ExecutorType {
	if m != nil {
		return m.Type
	}
	return PodSpec_ExecutorSpec_EXECUTOR_TYPE_INVALID
}

func (m *PodSpec_ExecutorSpec) GetExecutorId() string {
	if m != nil {
		return m.ExecutorId
	}
	return ""
}

func (m *PodSpec_ExecutorSpec) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterEnum("peloton.api.v1alpha.pod.apachemesos.PodSpec_ContainerType", PodSpec_ContainerType_name, PodSpec_ContainerType_value)
	proto.RegisterEnum("peloton.api.v1alpha.pod.apachemesos.PodSpec_ExecutorSpec_ExecutorType", PodSpec_ExecutorSpec_ExecutorType_name, PodSpec_ExecutorSpec_ExecutorType_value)
	proto.RegisterType((*PodSpec)(nil), "peloton.api.v1alpha.pod.apachemesos.PodSpec")
	proto.RegisterType((*PodSpec_DockerParameter)(nil), "peloton.api.v1alpha.pod.apachemesos.PodSpec.DockerParameter")
	proto.RegisterType((*PodSpec_URI)(nil), "peloton.api.v1alpha.pod.apachemesos.PodSpec.URI")
	proto.RegisterType((*PodSpec_ExecutorSpec)(nil), "peloton.api.v1alpha.pod.apachemesos.PodSpec.ExecutorSpec")
}

func init() {
	proto.RegisterFile("peloton/api/v1alpha/pod/apachemesos/apachemesos.proto", fileDescriptor_4e469d46b339c16c)
}

var fileDescriptor_4e469d46b339c16c = []byte{
	// 503 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xcf, 0x73, 0xd2, 0x40,
	0x14, 0x36, 0x40, 0xa5, 0x7d, 0x50, 0x8d, 0x3b, 0xd5, 0x89, 0x1c, 0x2c, 0x43, 0x2f, 0x9c, 0x82,
	0xe2, 0x78, 0xa8, 0xe3, 0x05, 0x21, 0xcc, 0x44, 0x5b, 0x60, 0x96, 0xe0, 0x68, 0x0f, 0x8d, 0xdb,
	0xe4, 0x39, 0x64, 0x9a, 0xb2, 0x3b, 0xc9, 0xa6, 0x53, 0xfe, 0x07, 0xff, 0x16, 0xff, 0x45, 0x9d,
	0x6c, 0x42, 0x1b, 0xd0, 0x03, 0x78, 0x7b, 0xdf, 0xfb, 0xf6, 0xfb, 0xde, 0xbe, 0xb7, 0x3f, 0xe0,
	0x9d, 0xc0, 0x90, 0x4b, 0xbe, 0xe8, 0x30, 0x11, 0x74, 0x6e, 0xdf, 0xb0, 0x50, 0xcc, 0x59, 0x47,
	0x70, 0xbf, 0xc3, 0x04, 0xf3, 0xe6, 0x78, 0x83, 0x31, 0x8f, 0x8b, 0xb1, 0x29, 0x22, 0x2e, 0x39,
	0x39, 0xc9, 0x65, 0x26, 0x13, 0x81, 0x99, 0xcb, 0x4c, 0xc1, 0x7d, 0xb3, 0xb0, 0xb4, 0xf5, 0xab,
	0x0a, 0xd5, 0x09, 0xf7, 0xa7, 0x02, 0x3d, 0x32, 0x82, 0x8a, 0x5c, 0x0a, 0x34, 0xb4, 0xa6, 0xd6,
	0x7e, 0xd2, 0x7d, 0x6f, 0x6e, 0xa1, 0x37, 0x73, 0xad, 0xd9, 0xe7, 0x0b, 0xc9, 0x82, 0x05, 0x46,
	0xce, 0x52, 0x20, 0x55, 0x3e, 0x24, 0x80, 0x67, 0x3e, 0xf7, 0xae, 0x31, 0x72, 0x05, 0x8b, 0xd8,
	0x0d, 0x4a, 0x8c, 0x62, 0xa3, 0xd4, 0x2c, 0xb7, 0x6b, 0xdd, 0x0f, 0x3b, 0x99, 0x0f, 0x94, 0xcb,
	0x64, 0x65, 0x42, 0x75, 0x7f, 0x3d, 0x11, 0x93, 0x01, 0x54, 0x92, 0x28, 0x88, 0x8d, 0xb2, 0x72,
	0x7f, 0xbd, 0x93, 0xfb, 0x8c, 0xda, 0x54, 0xa9, 0xc9, 0x11, 0xec, 0xc5, 0x73, 0x0c, 0x43, 0xa3,
	0xd2, 0xd4, 0xda, 0xfb, 0x34, 0x03, 0xe4, 0x12, 0x0e, 0xf1, 0x0e, 0xbd, 0x44, 0xf2, 0xc8, 0x8d,
	0x05, 0x7a, 0xc6, 0x5e, 0x53, 0x6b, 0xd7, 0xba, 0xa7, 0x3b, 0x15, 0xb1, 0x72, 0x87, 0x14, 0xd0,
	0x3a, 0x16, 0x50, 0xe3, 0x14, 0x9e, 0x6e, 0x34, 0x48, 0x74, 0x28, 0x5f, 0xe3, 0x52, 0x1d, 0xc4,
	0x01, 0x4d, 0xc3, 0x74, 0x6b, 0xb7, 0x2c, 0x4c, 0xd0, 0x28, 0xa9, 0x5c, 0x06, 0x1a, 0x3f, 0x35,
	0x28, 0xcf, 0xa8, 0xfd, 0xc0, 0x6a, 0x05, 0x96, 0xbc, 0x02, 0xc8, 0x0a, 0xb1, 0xab, 0x30, 0x13,
	0xee, 0xd3, 0x42, 0x86, 0x18, 0x50, 0xc5, 0x3b, 0x19, 0x31, 0x4f, 0x1a, 0x65, 0x45, 0xae, 0x60,
	0xea, 0xe7, 0xa5, 0x3d, 0xac, 0x06, 0xa1, 0x00, 0x39, 0x86, 0x1a, 0x4f, 0xa4, 0x48, 0xa4, 0xfb,
	0x23, 0x08, 0x51, 0x8d, 0xe1, 0x80, 0x42, 0x96, 0x1a, 0x06, 0x21, 0x36, 0x7e, 0x6b, 0x50, 0x2f,
	0x36, 0x4a, 0x2e, 0xd6, 0x6e, 0xd4, 0xf0, 0xbf, 0x27, 0x76, 0x0f, 0x0a, 0xb7, 0xeb, 0x18, 0x6a,
	0xf7, 0xc7, 0x12, 0xf8, 0xf9, 0x5c, 0x60, 0x95, 0xb2, 0x7d, 0x42, 0xa0, 0xe2, 0x33, 0xc9, 0x54,
	0x6f, 0x75, 0xaa, 0xe2, 0xd6, 0xe5, 0xc3, 0x06, 0x53, 0x2b, 0xf2, 0x12, 0x9e, 0x5b, 0x5f, 0xad,
	0xfe, 0xcc, 0x19, 0x53, 0xd7, 0xf9, 0x36, 0xb1, 0x5c, 0x7b, 0xf4, 0xa5, 0x77, 0x66, 0x0f, 0xf4,
	0x47, 0x7f, 0x53, 0x03, 0x6b, 0xd8, 0x9b, 0x9d, 0x39, 0xba, 0x46, 0x0c, 0x38, 0x5a, 0xa7, 0xfa,
	0xb3, 0xa9, 0x33, 0x3e, 0xd7, 0x4b, 0xad, 0xef, 0x70, 0xb8, 0xf6, 0x12, 0x48, 0x03, 0x5e, 0xf4,
	0xc7, 0x23, 0xa7, 0x67, 0x8f, 0xac, 0x7f, 0x55, 0xd8, 0xe0, 0x06, 0xe3, 0xfe, 0x67, 0x8b, 0x66,
	0x15, 0x36, 0xa8, 0x73, 0x6b, 0x3a, 0x9e, 0xea, 0xa5, 0x8f, 0x9f, 0x60, 0x9b, 0x77, 0x7d, 0x71,
	0xb2, 0xc5, 0x9f, 0x71, 0xf5, 0x58, 0x7d, 0x14, 0x6f, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0xe4,
	0x18, 0x98, 0x47, 0x61, 0x04, 0x00, 0x00,
}

// Code generated by thriftrw-plugin-yarpc
// @generated

package readonlyschedulertest

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	api "github.com/uber/peloton/.gen/thrift/aurora/api"
	readonlyschedulerclient "github.com/uber/peloton/.gen/thrift/aurora/api/readonlyschedulerclient"
	yarpc "go.uber.org/yarpc"
)

// MockClient implements a gomock-compatible mock client for service
// ReadOnlyScheduler.
type MockClient struct {
	ctrl     *gomock.Controller
	recorder *_MockClientRecorder
}

var _ readonlyschedulerclient.Interface = (*MockClient)(nil)

type _MockClientRecorder struct {
	mock *MockClient
}

// Build a new mock client for service ReadOnlyScheduler.
//
// 	mockCtrl := gomock.NewController(t)
// 	client := readonlyschedulertest.NewMockClient(mockCtrl)
//
// Use EXPECT() to set expectations on the mock.
func NewMockClient(ctrl *gomock.Controller) *MockClient {
	mock := &MockClient{ctrl: ctrl}
	mock.recorder = &_MockClientRecorder{mock}
	return mock
}

// EXPECT returns an object that allows you to define an expectation on the
// ReadOnlyScheduler mock client.
func (m *MockClient) EXPECT() *_MockClientRecorder {
	return m.recorder
}

// GetConfigSummary responds to a GetConfigSummary call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetConfigSummary(gomock.Any(), ...).Return(...)
// 	... := client.GetConfigSummary(...)
func (m *MockClient) GetConfigSummary(
	ctx context.Context,
	_Job *api.JobKey,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Job}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetConfigSummary", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetConfigSummary(
	ctx interface{},
	_Job interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Job}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetConfigSummary", args...)
}

// GetJobSummary responds to a GetJobSummary call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetJobSummary(gomock.Any(), ...).Return(...)
// 	... := client.GetJobSummary(...)
func (m *MockClient) GetJobSummary(
	ctx context.Context,
	_Role *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Role}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetJobSummary", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetJobSummary(
	ctx interface{},
	_Role interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Role}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetJobSummary", args...)
}

// GetJobUpdateDetails responds to a GetJobUpdateDetails call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetJobUpdateDetails(gomock.Any(), ...).Return(...)
// 	... := client.GetJobUpdateDetails(...)
func (m *MockClient) GetJobUpdateDetails(
	ctx context.Context,
	_Key *api.JobUpdateKey,
	_Query *api.JobUpdateQuery,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Key, _Query}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetJobUpdateDetails", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetJobUpdateDetails(
	ctx interface{},
	_Key interface{},
	_Query interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Key, _Query}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetJobUpdateDetails", args...)
}

// GetJobUpdateDiff responds to a GetJobUpdateDiff call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetJobUpdateDiff(gomock.Any(), ...).Return(...)
// 	... := client.GetJobUpdateDiff(...)
func (m *MockClient) GetJobUpdateDiff(
	ctx context.Context,
	_Request *api.JobUpdateRequest,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Request}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetJobUpdateDiff", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetJobUpdateDiff(
	ctx interface{},
	_Request interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Request}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetJobUpdateDiff", args...)
}

// GetJobUpdateSummaries responds to a GetJobUpdateSummaries call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetJobUpdateSummaries(gomock.Any(), ...).Return(...)
// 	... := client.GetJobUpdateSummaries(...)
func (m *MockClient) GetJobUpdateSummaries(
	ctx context.Context,
	_JobUpdateQuery *api.JobUpdateQuery,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _JobUpdateQuery}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetJobUpdateSummaries", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetJobUpdateSummaries(
	ctx interface{},
	_JobUpdateQuery interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _JobUpdateQuery}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetJobUpdateSummaries", args...)
}

// GetJobs responds to a GetJobs call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetJobs(gomock.Any(), ...).Return(...)
// 	... := client.GetJobs(...)
func (m *MockClient) GetJobs(
	ctx context.Context,
	_OwnerRole *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _OwnerRole}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetJobs", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetJobs(
	ctx interface{},
	_OwnerRole interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _OwnerRole}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetJobs", args...)
}

// GetPendingReason responds to a GetPendingReason call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetPendingReason(gomock.Any(), ...).Return(...)
// 	... := client.GetPendingReason(...)
func (m *MockClient) GetPendingReason(
	ctx context.Context,
	_Query *api.TaskQuery,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Query}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetPendingReason", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetPendingReason(
	ctx interface{},
	_Query interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Query}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetPendingReason", args...)
}

// GetQuota responds to a GetQuota call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetQuota(gomock.Any(), ...).Return(...)
// 	... := client.GetQuota(...)
func (m *MockClient) GetQuota(
	ctx context.Context,
	_OwnerRole *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _OwnerRole}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetQuota", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetQuota(
	ctx interface{},
	_OwnerRole interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _OwnerRole}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetQuota", args...)
}

// GetRoleSummary responds to a GetRoleSummary call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetRoleSummary(gomock.Any(), ...).Return(...)
// 	... := client.GetRoleSummary(...)
func (m *MockClient) GetRoleSummary(
	ctx context.Context,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetRoleSummary", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetRoleSummary(
	ctx interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetRoleSummary", args...)
}

// GetTasksStatus responds to a GetTasksStatus call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetTasksStatus(gomock.Any(), ...).Return(...)
// 	... := client.GetTasksStatus(...)
func (m *MockClient) GetTasksStatus(
	ctx context.Context,
	_Query *api.TaskQuery,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Query}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetTasksStatus", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetTasksStatus(
	ctx interface{},
	_Query interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Query}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetTasksStatus", args...)
}

// GetTasksWithoutConfigs responds to a GetTasksWithoutConfigs call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetTasksWithoutConfigs(gomock.Any(), ...).Return(...)
// 	... := client.GetTasksWithoutConfigs(...)
func (m *MockClient) GetTasksWithoutConfigs(
	ctx context.Context,
	_Query *api.TaskQuery,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Query}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetTasksWithoutConfigs", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetTasksWithoutConfigs(
	ctx interface{},
	_Query interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Query}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetTasksWithoutConfigs", args...)
}

// GetTierConfigs responds to a GetTierConfigs call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetTierConfigs(gomock.Any(), ...).Return(...)
// 	... := client.GetTierConfigs(...)
func (m *MockClient) GetTierConfigs(
	ctx context.Context,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetTierConfigs", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetTierConfigs(
	ctx interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetTierConfigs", args...)
}

// PopulateJobConfig responds to a PopulateJobConfig call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().PopulateJobConfig(gomock.Any(), ...).Return(...)
// 	... := client.PopulateJobConfig(...)
func (m *MockClient) PopulateJobConfig(
	ctx context.Context,
	_Description *api.JobConfiguration,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Description}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "PopulateJobConfig", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) PopulateJobConfig(
	ctx interface{},
	_Description interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Description}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "PopulateJobConfig", args...)
}

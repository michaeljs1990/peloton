// Code generated by thriftrw-plugin-yarpc
// @generated

package auroraschedulermanagerserver

import (
	context "context"
	api "github.com/uber/peloton/.gen/thrift/aurora/api"
	readonlyschedulerserver "github.com/uber/peloton/.gen/thrift/aurora/api/readonlyschedulerserver"
	wire "go.uber.org/thriftrw/wire"
	transport "go.uber.org/yarpc/api/transport"
	thrift "go.uber.org/yarpc/encoding/thrift"
)

// Interface is the server-side interface for the AuroraSchedulerManager service.
type Interface interface {
	readonlyschedulerserver.Interface

	AbortJobUpdate(
		ctx context.Context,
		Key *api.JobUpdateKey,
		Message *string,
	) (*api.Response, error)

	AddInstances(
		ctx context.Context,
		Key *api.InstanceKey,
		Count *int32,
	) (*api.Response, error)

	CreateJob(
		ctx context.Context,
		Description *api.JobConfiguration,
	) (*api.Response, error)

	DescheduleCronJob(
		ctx context.Context,
		Job *api.JobKey,
	) (*api.Response, error)

	KillTasks(
		ctx context.Context,
		Job *api.JobKey,
		Instances map[int32]struct{},
		Message *string,
	) (*api.Response, error)

	PauseJobUpdate(
		ctx context.Context,
		Key *api.JobUpdateKey,
		Message *string,
	) (*api.Response, error)

	PulseJobUpdate(
		ctx context.Context,
		Key *api.JobUpdateKey,
	) (*api.Response, error)

	ReplaceCronTemplate(
		ctx context.Context,
		Config *api.JobConfiguration,
	) (*api.Response, error)

	RestartShards(
		ctx context.Context,
		Job *api.JobKey,
		ShardIds map[int32]struct{},
	) (*api.Response, error)

	ResumeJobUpdate(
		ctx context.Context,
		Key *api.JobUpdateKey,
		Message *string,
	) (*api.Response, error)

	RollbackJobUpdate(
		ctx context.Context,
		Key *api.JobUpdateKey,
		Message *string,
	) (*api.Response, error)

	ScheduleCronJob(
		ctx context.Context,
		Description *api.JobConfiguration,
	) (*api.Response, error)

	StartCronJob(
		ctx context.Context,
		Job *api.JobKey,
	) (*api.Response, error)

	StartJobUpdate(
		ctx context.Context,
		Request *api.JobUpdateRequest,
		Message *string,
	) (*api.Response, error)
}

// New prepares an implementation of the AuroraSchedulerManager service for
// registration.
//
// 	handler := AuroraSchedulerManagerHandler{}
// 	dispatcher.Register(auroraschedulermanagerserver.New(handler))
func New(impl Interface, opts ...thrift.RegisterOption) []transport.Procedure {
	h := handler{impl}
	service := thrift.Service{
		Name: "AuroraSchedulerManager",
		Methods: []thrift.Method{

			thrift.Method{
				Name: "abortJobUpdate",
				HandlerSpec: thrift.HandlerSpec{

					Type:  transport.Unary,
					Unary: thrift.UnaryHandler(h.AbortJobUpdate),
				},
				Signature:    "AbortJobUpdate(Key *api.JobUpdateKey, Message *string) (*api.Response)",
				ThriftModule: api.ThriftModule,
			},

			thrift.Method{
				Name: "addInstances",
				HandlerSpec: thrift.HandlerSpec{

					Type:  transport.Unary,
					Unary: thrift.UnaryHandler(h.AddInstances),
				},
				Signature:    "AddInstances(Key *api.InstanceKey, Count *int32) (*api.Response)",
				ThriftModule: api.ThriftModule,
			},

			thrift.Method{
				Name: "createJob",
				HandlerSpec: thrift.HandlerSpec{

					Type:  transport.Unary,
					Unary: thrift.UnaryHandler(h.CreateJob),
				},
				Signature:    "CreateJob(Description *api.JobConfiguration) (*api.Response)",
				ThriftModule: api.ThriftModule,
			},

			thrift.Method{
				Name: "descheduleCronJob",
				HandlerSpec: thrift.HandlerSpec{

					Type:  transport.Unary,
					Unary: thrift.UnaryHandler(h.DescheduleCronJob),
				},
				Signature:    "DescheduleCronJob(Job *api.JobKey) (*api.Response)",
				ThriftModule: api.ThriftModule,
			},

			thrift.Method{
				Name: "killTasks",
				HandlerSpec: thrift.HandlerSpec{

					Type:  transport.Unary,
					Unary: thrift.UnaryHandler(h.KillTasks),
				},
				Signature:    "KillTasks(Job *api.JobKey, Instances map[int32]struct{}, Message *string) (*api.Response)",
				ThriftModule: api.ThriftModule,
			},

			thrift.Method{
				Name: "pauseJobUpdate",
				HandlerSpec: thrift.HandlerSpec{

					Type:  transport.Unary,
					Unary: thrift.UnaryHandler(h.PauseJobUpdate),
				},
				Signature:    "PauseJobUpdate(Key *api.JobUpdateKey, Message *string) (*api.Response)",
				ThriftModule: api.ThriftModule,
			},

			thrift.Method{
				Name: "pulseJobUpdate",
				HandlerSpec: thrift.HandlerSpec{

					Type:  transport.Unary,
					Unary: thrift.UnaryHandler(h.PulseJobUpdate),
				},
				Signature:    "PulseJobUpdate(Key *api.JobUpdateKey) (*api.Response)",
				ThriftModule: api.ThriftModule,
			},

			thrift.Method{
				Name: "replaceCronTemplate",
				HandlerSpec: thrift.HandlerSpec{

					Type:  transport.Unary,
					Unary: thrift.UnaryHandler(h.ReplaceCronTemplate),
				},
				Signature:    "ReplaceCronTemplate(Config *api.JobConfiguration) (*api.Response)",
				ThriftModule: api.ThriftModule,
			},

			thrift.Method{
				Name: "restartShards",
				HandlerSpec: thrift.HandlerSpec{

					Type:  transport.Unary,
					Unary: thrift.UnaryHandler(h.RestartShards),
				},
				Signature:    "RestartShards(Job *api.JobKey, ShardIds map[int32]struct{}) (*api.Response)",
				ThriftModule: api.ThriftModule,
			},

			thrift.Method{
				Name: "resumeJobUpdate",
				HandlerSpec: thrift.HandlerSpec{

					Type:  transport.Unary,
					Unary: thrift.UnaryHandler(h.ResumeJobUpdate),
				},
				Signature:    "ResumeJobUpdate(Key *api.JobUpdateKey, Message *string) (*api.Response)",
				ThriftModule: api.ThriftModule,
			},

			thrift.Method{
				Name: "rollbackJobUpdate",
				HandlerSpec: thrift.HandlerSpec{

					Type:  transport.Unary,
					Unary: thrift.UnaryHandler(h.RollbackJobUpdate),
				},
				Signature:    "RollbackJobUpdate(Key *api.JobUpdateKey, Message *string) (*api.Response)",
				ThriftModule: api.ThriftModule,
			},

			thrift.Method{
				Name: "scheduleCronJob",
				HandlerSpec: thrift.HandlerSpec{

					Type:  transport.Unary,
					Unary: thrift.UnaryHandler(h.ScheduleCronJob),
				},
				Signature:    "ScheduleCronJob(Description *api.JobConfiguration) (*api.Response)",
				ThriftModule: api.ThriftModule,
			},

			thrift.Method{
				Name: "startCronJob",
				HandlerSpec: thrift.HandlerSpec{

					Type:  transport.Unary,
					Unary: thrift.UnaryHandler(h.StartCronJob),
				},
				Signature:    "StartCronJob(Job *api.JobKey) (*api.Response)",
				ThriftModule: api.ThriftModule,
			},

			thrift.Method{
				Name: "startJobUpdate",
				HandlerSpec: thrift.HandlerSpec{

					Type:  transport.Unary,
					Unary: thrift.UnaryHandler(h.StartJobUpdate),
				},
				Signature:    "StartJobUpdate(Request *api.JobUpdateRequest, Message *string) (*api.Response)",
				ThriftModule: api.ThriftModule,
			},
		},
	}

	procedures := make([]transport.Procedure, 0, 14)

	procedures = append(
		procedures,
		readonlyschedulerserver.New(
			impl,
			append(
				opts,
				thrift.Named("AuroraSchedulerManager"),
			)...,
		)...,
	)
	procedures = append(procedures, thrift.BuildProcedures(service, opts...)...)
	return procedures
}

type handler struct{ impl Interface }

func (h handler) AbortJobUpdate(ctx context.Context, body wire.Value) (thrift.Response, error) {
	var args api.AuroraSchedulerManager_AbortJobUpdate_Args
	if err := args.FromWire(body); err != nil {
		return thrift.Response{}, err
	}

	success, err := h.impl.AbortJobUpdate(ctx, args.Key, args.Message)

	hadError := err != nil
	result, err := api.AuroraSchedulerManager_AbortJobUpdate_Helper.WrapResponse(success, err)

	var response thrift.Response
	if err == nil {
		response.IsApplicationError = hadError
		response.Body = result
	}
	return response, err
}

func (h handler) AddInstances(ctx context.Context, body wire.Value) (thrift.Response, error) {
	var args api.AuroraSchedulerManager_AddInstances_Args
	if err := args.FromWire(body); err != nil {
		return thrift.Response{}, err
	}

	success, err := h.impl.AddInstances(ctx, args.Key, args.Count)

	hadError := err != nil
	result, err := api.AuroraSchedulerManager_AddInstances_Helper.WrapResponse(success, err)

	var response thrift.Response
	if err == nil {
		response.IsApplicationError = hadError
		response.Body = result
	}
	return response, err
}

func (h handler) CreateJob(ctx context.Context, body wire.Value) (thrift.Response, error) {
	var args api.AuroraSchedulerManager_CreateJob_Args
	if err := args.FromWire(body); err != nil {
		return thrift.Response{}, err
	}

	success, err := h.impl.CreateJob(ctx, args.Description)

	hadError := err != nil
	result, err := api.AuroraSchedulerManager_CreateJob_Helper.WrapResponse(success, err)

	var response thrift.Response
	if err == nil {
		response.IsApplicationError = hadError
		response.Body = result
	}
	return response, err
}

func (h handler) DescheduleCronJob(ctx context.Context, body wire.Value) (thrift.Response, error) {
	var args api.AuroraSchedulerManager_DescheduleCronJob_Args
	if err := args.FromWire(body); err != nil {
		return thrift.Response{}, err
	}

	success, err := h.impl.DescheduleCronJob(ctx, args.Job)

	hadError := err != nil
	result, err := api.AuroraSchedulerManager_DescheduleCronJob_Helper.WrapResponse(success, err)

	var response thrift.Response
	if err == nil {
		response.IsApplicationError = hadError
		response.Body = result
	}
	return response, err
}

func (h handler) KillTasks(ctx context.Context, body wire.Value) (thrift.Response, error) {
	var args api.AuroraSchedulerManager_KillTasks_Args
	if err := args.FromWire(body); err != nil {
		return thrift.Response{}, err
	}

	success, err := h.impl.KillTasks(ctx, args.Job, args.Instances, args.Message)

	hadError := err != nil
	result, err := api.AuroraSchedulerManager_KillTasks_Helper.WrapResponse(success, err)

	var response thrift.Response
	if err == nil {
		response.IsApplicationError = hadError
		response.Body = result
	}
	return response, err
}

func (h handler) PauseJobUpdate(ctx context.Context, body wire.Value) (thrift.Response, error) {
	var args api.AuroraSchedulerManager_PauseJobUpdate_Args
	if err := args.FromWire(body); err != nil {
		return thrift.Response{}, err
	}

	success, err := h.impl.PauseJobUpdate(ctx, args.Key, args.Message)

	hadError := err != nil
	result, err := api.AuroraSchedulerManager_PauseJobUpdate_Helper.WrapResponse(success, err)

	var response thrift.Response
	if err == nil {
		response.IsApplicationError = hadError
		response.Body = result
	}
	return response, err
}

func (h handler) PulseJobUpdate(ctx context.Context, body wire.Value) (thrift.Response, error) {
	var args api.AuroraSchedulerManager_PulseJobUpdate_Args
	if err := args.FromWire(body); err != nil {
		return thrift.Response{}, err
	}

	success, err := h.impl.PulseJobUpdate(ctx, args.Key)

	hadError := err != nil
	result, err := api.AuroraSchedulerManager_PulseJobUpdate_Helper.WrapResponse(success, err)

	var response thrift.Response
	if err == nil {
		response.IsApplicationError = hadError
		response.Body = result
	}
	return response, err
}

func (h handler) ReplaceCronTemplate(ctx context.Context, body wire.Value) (thrift.Response, error) {
	var args api.AuroraSchedulerManager_ReplaceCronTemplate_Args
	if err := args.FromWire(body); err != nil {
		return thrift.Response{}, err
	}

	success, err := h.impl.ReplaceCronTemplate(ctx, args.Config)

	hadError := err != nil
	result, err := api.AuroraSchedulerManager_ReplaceCronTemplate_Helper.WrapResponse(success, err)

	var response thrift.Response
	if err == nil {
		response.IsApplicationError = hadError
		response.Body = result
	}
	return response, err
}

func (h handler) RestartShards(ctx context.Context, body wire.Value) (thrift.Response, error) {
	var args api.AuroraSchedulerManager_RestartShards_Args
	if err := args.FromWire(body); err != nil {
		return thrift.Response{}, err
	}

	success, err := h.impl.RestartShards(ctx, args.Job, args.ShardIds)

	hadError := err != nil
	result, err := api.AuroraSchedulerManager_RestartShards_Helper.WrapResponse(success, err)

	var response thrift.Response
	if err == nil {
		response.IsApplicationError = hadError
		response.Body = result
	}
	return response, err
}

func (h handler) ResumeJobUpdate(ctx context.Context, body wire.Value) (thrift.Response, error) {
	var args api.AuroraSchedulerManager_ResumeJobUpdate_Args
	if err := args.FromWire(body); err != nil {
		return thrift.Response{}, err
	}

	success, err := h.impl.ResumeJobUpdate(ctx, args.Key, args.Message)

	hadError := err != nil
	result, err := api.AuroraSchedulerManager_ResumeJobUpdate_Helper.WrapResponse(success, err)

	var response thrift.Response
	if err == nil {
		response.IsApplicationError = hadError
		response.Body = result
	}
	return response, err
}

func (h handler) RollbackJobUpdate(ctx context.Context, body wire.Value) (thrift.Response, error) {
	var args api.AuroraSchedulerManager_RollbackJobUpdate_Args
	if err := args.FromWire(body); err != nil {
		return thrift.Response{}, err
	}

	success, err := h.impl.RollbackJobUpdate(ctx, args.Key, args.Message)

	hadError := err != nil
	result, err := api.AuroraSchedulerManager_RollbackJobUpdate_Helper.WrapResponse(success, err)

	var response thrift.Response
	if err == nil {
		response.IsApplicationError = hadError
		response.Body = result
	}
	return response, err
}

func (h handler) ScheduleCronJob(ctx context.Context, body wire.Value) (thrift.Response, error) {
	var args api.AuroraSchedulerManager_ScheduleCronJob_Args
	if err := args.FromWire(body); err != nil {
		return thrift.Response{}, err
	}

	success, err := h.impl.ScheduleCronJob(ctx, args.Description)

	hadError := err != nil
	result, err := api.AuroraSchedulerManager_ScheduleCronJob_Helper.WrapResponse(success, err)

	var response thrift.Response
	if err == nil {
		response.IsApplicationError = hadError
		response.Body = result
	}
	return response, err
}

func (h handler) StartCronJob(ctx context.Context, body wire.Value) (thrift.Response, error) {
	var args api.AuroraSchedulerManager_StartCronJob_Args
	if err := args.FromWire(body); err != nil {
		return thrift.Response{}, err
	}

	success, err := h.impl.StartCronJob(ctx, args.Job)

	hadError := err != nil
	result, err := api.AuroraSchedulerManager_StartCronJob_Helper.WrapResponse(success, err)

	var response thrift.Response
	if err == nil {
		response.IsApplicationError = hadError
		response.Body = result
	}
	return response, err
}

func (h handler) StartJobUpdate(ctx context.Context, body wire.Value) (thrift.Response, error) {
	var args api.AuroraSchedulerManager_StartJobUpdate_Args
	if err := args.FromWire(body); err != nil {
		return thrift.Response{}, err
	}

	success, err := h.impl.StartJobUpdate(ctx, args.Request, args.Message)

	hadError := err != nil
	result, err := api.AuroraSchedulerManager_StartJobUpdate_Helper.WrapResponse(success, err)

	var response thrift.Response
	if err == nil {
		response.IsApplicationError = hadError
		response.Body = result
	}
	return response, err
}

// Code generated by thriftrw v1.19.1. DO NOT EDIT.
// @generated

package api

import (
	bytes "bytes"
	json "encoding/json"
	fmt "fmt"
	multierr "go.uber.org/multierr"
	wire "go.uber.org/thriftrw/wire"
	zapcore "go.uber.org/zap/zapcore"
	math "math"
	strconv "strconv"
	strings "strings"
)

// Describes an image for use with the Mesos unified containerizer in the AppC format
type AppcImage struct {
	// The name of the image to run
	Name *string `json:"name,omitempty"`
	// The appc image id identifying the image
	ImageId *string `json:"imageId,omitempty"`
}

// ToWire translates a AppcImage struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *AppcImage) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ImageId != nil {
		w, err = wire.NewValueString(*(v.ImageId)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a AppcImage struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a AppcImage struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v AppcImage
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *AppcImage) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ImageId = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a AppcImage
// struct.
func (v *AppcImage) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.ImageId != nil {
		fields[i] = fmt.Sprintf("ImageId: %v", *(v.ImageId))
		i++
	}

	return fmt.Sprintf("AppcImage{%v}", strings.Join(fields[:i], ", "))
}

func _String_EqualsPtr(lhs, rhs *string) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this AppcImage match the
// provided AppcImage.
//
// This function performs a deep comparison.
func (v *AppcImage) Equals(rhs *AppcImage) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !_String_EqualsPtr(v.ImageId, rhs.ImageId) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of AppcImage.
func (v *AppcImage) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.ImageId != nil {
		enc.AddString("imageId", *v.ImageId)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *AppcImage) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *AppcImage) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetImageId returns the value of ImageId if it is set or its
// zero value if it is unset.
func (v *AppcImage) GetImageId() (o string) {
	if v != nil && v.ImageId != nil {
		return *v.ImageId
	}

	return
}

// IsSetImageId returns true if ImageId is not nil.
func (v *AppcImage) IsSetImageId() bool {
	return v != nil && v.ImageId != nil
}

// A task assignment that is provided to an executor.
type AssignedTask struct {
	// The mesos task ID for this task.  Guaranteed to be globally unique
	TaskId *string `json:"taskId,omitempty"`
	// The mesos slave ID that this task has been assigned to.
	// This will not be populated for a PENDING task.
	SlaveId *string `json:"slaveId,omitempty"`
	// The name of the machine that this task has been assigned to.
	// This will not be populated for a PENDING task.
	SlaveHost *string `json:"slaveHost,omitempty"`
	// Information about how to run this task.
	Task *TaskConfig `json:"task,omitempty"`
	// Ports reserved on the machine while this task is running.
	AssignedPorts map[string]int32 `json:"assignedPorts,omitempty"`
	// The instance ID assigned to this task. Instance IDs must be unique and contiguous within a
	// job, and will be in the range [0, N-1] (inclusive) for a job that has N instances.
	InstanceId *int32 `json:"instanceId,omitempty"`
}

type _Map_String_I32_MapItemList map[string]int32

func (m _Map_String_I32_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueI32(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_I32_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_I32_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_I32_MapItemList) ValueType() wire.Type {
	return wire.TI32
}

func (_Map_String_I32_MapItemList) Close() {}

// ToWire translates a AssignedTask struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *AssignedTask) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.TaskId != nil {
		w, err = wire.NewValueString(*(v.TaskId)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.SlaveId != nil {
		w, err = wire.NewValueString(*(v.SlaveId)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.SlaveHost != nil {
		w, err = wire.NewValueString(*(v.SlaveHost)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Task != nil {
		w, err = v.Task.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.AssignedPorts != nil {
		w, err = wire.NewValueMap(_Map_String_I32_MapItemList(v.AssignedPorts)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.InstanceId != nil {
		w, err = wire.NewValueI32(*(v.InstanceId)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _TaskConfig_Read(w wire.Value) (*TaskConfig, error) {
	var v TaskConfig
	err := v.FromWire(w)
	return &v, err
}

func _Map_String_I32_Read(m wire.MapItemList) (map[string]int32, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make(map[string]int32, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetI32(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a AssignedTask struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a AssignedTask struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v AssignedTask
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *AssignedTask) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.TaskId = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.SlaveId = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.SlaveHost = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TStruct {
				v.Task, err = _TaskConfig_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TMap {
				v.AssignedPorts, err = _Map_String_I32_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.InstanceId = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a AssignedTask
// struct.
func (v *AssignedTask) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	if v.TaskId != nil {
		fields[i] = fmt.Sprintf("TaskId: %v", *(v.TaskId))
		i++
	}
	if v.SlaveId != nil {
		fields[i] = fmt.Sprintf("SlaveId: %v", *(v.SlaveId))
		i++
	}
	if v.SlaveHost != nil {
		fields[i] = fmt.Sprintf("SlaveHost: %v", *(v.SlaveHost))
		i++
	}
	if v.Task != nil {
		fields[i] = fmt.Sprintf("Task: %v", v.Task)
		i++
	}
	if v.AssignedPorts != nil {
		fields[i] = fmt.Sprintf("AssignedPorts: %v", v.AssignedPorts)
		i++
	}
	if v.InstanceId != nil {
		fields[i] = fmt.Sprintf("InstanceId: %v", *(v.InstanceId))
		i++
	}

	return fmt.Sprintf("AssignedTask{%v}", strings.Join(fields[:i], ", "))
}

func _Map_String_I32_Equals(lhs, rhs map[string]int32) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

func _I32_EqualsPtr(lhs, rhs *int32) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this AssignedTask match the
// provided AssignedTask.
//
// This function performs a deep comparison.
func (v *AssignedTask) Equals(rhs *AssignedTask) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.TaskId, rhs.TaskId) {
		return false
	}
	if !_String_EqualsPtr(v.SlaveId, rhs.SlaveId) {
		return false
	}
	if !_String_EqualsPtr(v.SlaveHost, rhs.SlaveHost) {
		return false
	}
	if !((v.Task == nil && rhs.Task == nil) || (v.Task != nil && rhs.Task != nil && v.Task.Equals(rhs.Task))) {
		return false
	}
	if !((v.AssignedPorts == nil && rhs.AssignedPorts == nil) || (v.AssignedPorts != nil && rhs.AssignedPorts != nil && _Map_String_I32_Equals(v.AssignedPorts, rhs.AssignedPorts))) {
		return false
	}
	if !_I32_EqualsPtr(v.InstanceId, rhs.InstanceId) {
		return false
	}

	return true
}

type _Map_String_I32_Zapper map[string]int32

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_I32_Zapper.
func (m _Map_String_I32_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		enc.AddInt32((string)(k), v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of AssignedTask.
func (v *AssignedTask) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.TaskId != nil {
		enc.AddString("taskId", *v.TaskId)
	}
	if v.SlaveId != nil {
		enc.AddString("slaveId", *v.SlaveId)
	}
	if v.SlaveHost != nil {
		enc.AddString("slaveHost", *v.SlaveHost)
	}
	if v.Task != nil {
		err = multierr.Append(err, enc.AddObject("task", v.Task))
	}
	if v.AssignedPorts != nil {
		err = multierr.Append(err, enc.AddObject("assignedPorts", (_Map_String_I32_Zapper)(v.AssignedPorts)))
	}
	if v.InstanceId != nil {
		enc.AddInt32("instanceId", *v.InstanceId)
	}
	return err
}

// GetTaskId returns the value of TaskId if it is set or its
// zero value if it is unset.
func (v *AssignedTask) GetTaskId() (o string) {
	if v != nil && v.TaskId != nil {
		return *v.TaskId
	}

	return
}

// IsSetTaskId returns true if TaskId is not nil.
func (v *AssignedTask) IsSetTaskId() bool {
	return v != nil && v.TaskId != nil
}

// GetSlaveId returns the value of SlaveId if it is set or its
// zero value if it is unset.
func (v *AssignedTask) GetSlaveId() (o string) {
	if v != nil && v.SlaveId != nil {
		return *v.SlaveId
	}

	return
}

// IsSetSlaveId returns true if SlaveId is not nil.
func (v *AssignedTask) IsSetSlaveId() bool {
	return v != nil && v.SlaveId != nil
}

// GetSlaveHost returns the value of SlaveHost if it is set or its
// zero value if it is unset.
func (v *AssignedTask) GetSlaveHost() (o string) {
	if v != nil && v.SlaveHost != nil {
		return *v.SlaveHost
	}

	return
}

// IsSetSlaveHost returns true if SlaveHost is not nil.
func (v *AssignedTask) IsSetSlaveHost() bool {
	return v != nil && v.SlaveHost != nil
}

// GetTask returns the value of Task if it is set or its
// zero value if it is unset.
func (v *AssignedTask) GetTask() (o *TaskConfig) {
	if v != nil && v.Task != nil {
		return v.Task
	}

	return
}

// IsSetTask returns true if Task is not nil.
func (v *AssignedTask) IsSetTask() bool {
	return v != nil && v.Task != nil
}

// GetAssignedPorts returns the value of AssignedPorts if it is set or its
// zero value if it is unset.
func (v *AssignedTask) GetAssignedPorts() (o map[string]int32) {
	if v != nil && v.AssignedPorts != nil {
		return v.AssignedPorts
	}

	return
}

// IsSetAssignedPorts returns true if AssignedPorts is not nil.
func (v *AssignedTask) IsSetAssignedPorts() bool {
	return v != nil && v.AssignedPorts != nil
}

// GetInstanceId returns the value of InstanceId if it is set or its
// zero value if it is unset.
func (v *AssignedTask) GetInstanceId() (o int32) {
	if v != nil && v.InstanceId != nil {
		return *v.InstanceId
	}

	return
}

// IsSetInstanceId returns true if InstanceId is not nil.
func (v *AssignedTask) IsSetInstanceId() bool {
	return v != nil && v.InstanceId != nil
}

// A single host attribute.
type Attribute struct {
	Name   *string             `json:"name,omitempty"`
	Values map[string]struct{} `json:"values,omitempty"`
}

type _Set_String_mapType_ValueList map[string]struct{}

func (v _Set_String_mapType_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_String_mapType_ValueList) Size() int {
	return len(v)
}

func (_Set_String_mapType_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Set_String_mapType_ValueList) Close() {}

// ToWire translates a Attribute struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Attribute) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Values != nil {
		w, err = wire.NewValueSet(_Set_String_mapType_ValueList(v.Values)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Set_String_mapType_Read(s wire.ValueList) (map[string]struct{}, error) {
	if s.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string]struct{}, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}

		o[i] = struct{}{}
		return nil
	})
	s.Close()
	return o, err
}

// FromWire deserializes a Attribute struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Attribute struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Attribute
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Attribute) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TSet {
				v.Values, err = _Set_String_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Attribute
// struct.
func (v *Attribute) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Values != nil {
		fields[i] = fmt.Sprintf("Values: %v", v.Values)
		i++
	}

	return fmt.Sprintf("Attribute{%v}", strings.Join(fields[:i], ", "))
}

func _Set_String_mapType_Equals(lhs, rhs map[string]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for x := range rhs {
		if _, ok := lhs[x]; !ok {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this Attribute match the
// provided Attribute.
//
// This function performs a deep comparison.
func (v *Attribute) Equals(rhs *Attribute) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !((v.Values == nil && rhs.Values == nil) || (v.Values != nil && rhs.Values != nil && _Set_String_mapType_Equals(v.Values, rhs.Values))) {
		return false
	}

	return true
}

type _Set_String_mapType_Zapper map[string]struct{}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_String_mapType_Zapper.
func (s _Set_String_mapType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for v := range s {
		enc.AppendString(v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Attribute.
func (v *Attribute) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.Values != nil {
		err = multierr.Append(err, enc.AddArray("values", (_Set_String_mapType_Zapper)(v.Values)))
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *Attribute) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *Attribute) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetValues returns the value of Values if it is set or its
// zero value if it is unset.
func (v *Attribute) GetValues() (o map[string]struct{}) {
	if v != nil && v.Values != nil {
		return v.Values
	}

	return
}

// IsSetValues returns true if Values is not nil.
func (v *Attribute) IsSetValues() bool {
	return v != nil && v.Values != nil
}

type ConfigGroup struct {
	Config    *TaskConfig `json:"config,omitempty"`
	Instances []*Range    `json:"instances,omitempty"`
}

type _Set_Range_sliceType_ValueList []*Range

func (v _Set_Range_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_Range_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_Range_sliceType_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_Range_sliceType_ValueList) Close() {}

// ToWire translates a ConfigGroup struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ConfigGroup) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Config != nil {
		w, err = v.Config.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Instances != nil {
		w, err = wire.NewValueSet(_Set_Range_sliceType_ValueList(v.Instances)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Range_Read(w wire.Value) (*Range, error) {
	var v Range
	err := v.FromWire(w)
	return &v, err
}

func _Set_Range_sliceType_Read(s wire.ValueList) ([]*Range, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Range, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _Range_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

// FromWire deserializes a ConfigGroup struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ConfigGroup struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ConfigGroup
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ConfigGroup) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Config, err = _TaskConfig_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TSet {
				v.Instances, err = _Set_Range_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ConfigGroup
// struct.
func (v *ConfigGroup) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Config != nil {
		fields[i] = fmt.Sprintf("Config: %v", v.Config)
		i++
	}
	if v.Instances != nil {
		fields[i] = fmt.Sprintf("Instances: %v", v.Instances)
		i++
	}

	return fmt.Sprintf("ConfigGroup{%v}", strings.Join(fields[:i], ", "))
}

func _Set_Range_sliceType_Equals(lhs, rhs []*Range) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this ConfigGroup match the
// provided ConfigGroup.
//
// This function performs a deep comparison.
func (v *ConfigGroup) Equals(rhs *ConfigGroup) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Config == nil && rhs.Config == nil) || (v.Config != nil && rhs.Config != nil && v.Config.Equals(rhs.Config))) {
		return false
	}
	if !((v.Instances == nil && rhs.Instances == nil) || (v.Instances != nil && rhs.Instances != nil && _Set_Range_sliceType_Equals(v.Instances, rhs.Instances))) {
		return false
	}

	return true
}

type _Set_Range_sliceType_Zapper []*Range

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_Range_sliceType_Zapper.
func (s _Set_Range_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ConfigGroup.
func (v *ConfigGroup) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Config != nil {
		err = multierr.Append(err, enc.AddObject("config", v.Config))
	}
	if v.Instances != nil {
		err = multierr.Append(err, enc.AddArray("instances", (_Set_Range_sliceType_Zapper)(v.Instances)))
	}
	return err
}

// GetConfig returns the value of Config if it is set or its
// zero value if it is unset.
func (v *ConfigGroup) GetConfig() (o *TaskConfig) {
	if v != nil && v.Config != nil {
		return v.Config
	}

	return
}

// IsSetConfig returns true if Config is not nil.
func (v *ConfigGroup) IsSetConfig() bool {
	return v != nil && v.Config != nil
}

// GetInstances returns the value of Instances if it is set or its
// zero value if it is unset.
func (v *ConfigGroup) GetInstances() (o []*Range) {
	if v != nil && v.Instances != nil {
		return v.Instances
	}

	return
}

// IsSetInstances returns true if Instances is not nil.
func (v *ConfigGroup) IsSetInstances() bool {
	return v != nil && v.Instances != nil
}

type ConfigSummary struct {
	Key    *JobKey        `json:"key,omitempty"`
	Groups []*ConfigGroup `json:"groups,omitempty"`
}

type _Set_ConfigGroup_sliceType_ValueList []*ConfigGroup

func (v _Set_ConfigGroup_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_ConfigGroup_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_ConfigGroup_sliceType_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_ConfigGroup_sliceType_ValueList) Close() {}

// ToWire translates a ConfigSummary struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ConfigSummary) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Key != nil {
		w, err = v.Key.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Groups != nil {
		w, err = wire.NewValueSet(_Set_ConfigGroup_sliceType_ValueList(v.Groups)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _JobKey_Read(w wire.Value) (*JobKey, error) {
	var v JobKey
	err := v.FromWire(w)
	return &v, err
}

func _ConfigGroup_Read(w wire.Value) (*ConfigGroup, error) {
	var v ConfigGroup
	err := v.FromWire(w)
	return &v, err
}

func _Set_ConfigGroup_sliceType_Read(s wire.ValueList) ([]*ConfigGroup, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*ConfigGroup, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _ConfigGroup_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

// FromWire deserializes a ConfigSummary struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ConfigSummary struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ConfigSummary
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ConfigSummary) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Key, err = _JobKey_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TSet {
				v.Groups, err = _Set_ConfigGroup_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ConfigSummary
// struct.
func (v *ConfigSummary) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Key != nil {
		fields[i] = fmt.Sprintf("Key: %v", v.Key)
		i++
	}
	if v.Groups != nil {
		fields[i] = fmt.Sprintf("Groups: %v", v.Groups)
		i++
	}

	return fmt.Sprintf("ConfigSummary{%v}", strings.Join(fields[:i], ", "))
}

func _Set_ConfigGroup_sliceType_Equals(lhs, rhs []*ConfigGroup) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this ConfigSummary match the
// provided ConfigSummary.
//
// This function performs a deep comparison.
func (v *ConfigSummary) Equals(rhs *ConfigSummary) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Key == nil && rhs.Key == nil) || (v.Key != nil && rhs.Key != nil && v.Key.Equals(rhs.Key))) {
		return false
	}
	if !((v.Groups == nil && rhs.Groups == nil) || (v.Groups != nil && rhs.Groups != nil && _Set_ConfigGroup_sliceType_Equals(v.Groups, rhs.Groups))) {
		return false
	}

	return true
}

type _Set_ConfigGroup_sliceType_Zapper []*ConfigGroup

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_ConfigGroup_sliceType_Zapper.
func (s _Set_ConfigGroup_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ConfigSummary.
func (v *ConfigSummary) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Key != nil {
		err = multierr.Append(err, enc.AddObject("key", v.Key))
	}
	if v.Groups != nil {
		err = multierr.Append(err, enc.AddArray("groups", (_Set_ConfigGroup_sliceType_Zapper)(v.Groups)))
	}
	return err
}

// GetKey returns the value of Key if it is set or its
// zero value if it is unset.
func (v *ConfigSummary) GetKey() (o *JobKey) {
	if v != nil && v.Key != nil {
		return v.Key
	}

	return
}

// IsSetKey returns true if Key is not nil.
func (v *ConfigSummary) IsSetKey() bool {
	return v != nil && v.Key != nil
}

// GetGroups returns the value of Groups if it is set or its
// zero value if it is unset.
func (v *ConfigSummary) GetGroups() (o []*ConfigGroup) {
	if v != nil && v.Groups != nil {
		return v.Groups
	}

	return
}

// IsSetGroups returns true if Groups is not nil.
func (v *ConfigSummary) IsSetGroups() bool {
	return v != nil && v.Groups != nil
}

type ConfigSummaryResult struct {
	Summary *ConfigSummary `json:"summary,omitempty"`
}

// ToWire translates a ConfigSummaryResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ConfigSummaryResult) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Summary != nil {
		w, err = v.Summary.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ConfigSummary_Read(w wire.Value) (*ConfigSummary, error) {
	var v ConfigSummary
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a ConfigSummaryResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ConfigSummaryResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ConfigSummaryResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ConfigSummaryResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Summary, err = _ConfigSummary_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ConfigSummaryResult
// struct.
func (v *ConfigSummaryResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Summary != nil {
		fields[i] = fmt.Sprintf("Summary: %v", v.Summary)
		i++
	}

	return fmt.Sprintf("ConfigSummaryResult{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ConfigSummaryResult match the
// provided ConfigSummaryResult.
//
// This function performs a deep comparison.
func (v *ConfigSummaryResult) Equals(rhs *ConfigSummaryResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Summary == nil && rhs.Summary == nil) || (v.Summary != nil && rhs.Summary != nil && v.Summary.Equals(rhs.Summary))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ConfigSummaryResult.
func (v *ConfigSummaryResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Summary != nil {
		err = multierr.Append(err, enc.AddObject("summary", v.Summary))
	}
	return err
}

// GetSummary returns the value of Summary if it is set or its
// zero value if it is unset.
func (v *ConfigSummaryResult) GetSummary() (o *ConfigSummary) {
	if v != nil && v.Summary != nil {
		return v.Summary
	}

	return
}

// IsSetSummary returns true if Summary is not nil.
func (v *ConfigSummaryResult) IsSetSummary() bool {
	return v != nil && v.Summary != nil
}

// A constraint that defines whether a task may be scheduled on a host.
type Constraint struct {
	// Mesos slave attribute that the constraint is matched against.
	Name       *string         `json:"name,omitempty"`
	Constraint *TaskConstraint `json:"constraint,omitempty"`
}

// ToWire translates a Constraint struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Constraint) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Constraint != nil {
		w, err = v.Constraint.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _TaskConstraint_Read(w wire.Value) (*TaskConstraint, error) {
	var v TaskConstraint
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Constraint struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Constraint struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Constraint
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Constraint) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Constraint, err = _TaskConstraint_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Constraint
// struct.
func (v *Constraint) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Constraint != nil {
		fields[i] = fmt.Sprintf("Constraint: %v", v.Constraint)
		i++
	}

	return fmt.Sprintf("Constraint{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Constraint match the
// provided Constraint.
//
// This function performs a deep comparison.
func (v *Constraint) Equals(rhs *Constraint) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !((v.Constraint == nil && rhs.Constraint == nil) || (v.Constraint != nil && rhs.Constraint != nil && v.Constraint.Equals(rhs.Constraint))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Constraint.
func (v *Constraint) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.Constraint != nil {
		err = multierr.Append(err, enc.AddObject("constraint", v.Constraint))
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *Constraint) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *Constraint) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetConstraint returns the value of Constraint if it is set or its
// zero value if it is unset.
func (v *Constraint) GetConstraint() (o *TaskConstraint) {
	if v != nil && v.Constraint != nil {
		return v.Constraint
	}

	return
}

// IsSetConstraint returns true if Constraint is not nil.
func (v *Constraint) IsSetConstraint() bool {
	return v != nil && v.Constraint != nil
}

// Describes a container to be used in a task
type Container struct {
	Mesos  *MesosContainer  `json:"mesos,omitempty"`
	Docker *DockerContainer `json:"docker,omitempty"`
}

// ToWire translates a Container struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Container) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Mesos != nil {
		w, err = v.Mesos.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Docker != nil {
		w, err = v.Docker.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Container should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _MesosContainer_Read(w wire.Value) (*MesosContainer, error) {
	var v MesosContainer
	err := v.FromWire(w)
	return &v, err
}

func _DockerContainer_Read(w wire.Value) (*DockerContainer, error) {
	var v DockerContainer
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Container struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Container struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Container
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Container) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Mesos, err = _MesosContainer_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Docker, err = _DockerContainer_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Mesos != nil {
		count++
	}
	if v.Docker != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Container should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Container
// struct.
func (v *Container) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Mesos != nil {
		fields[i] = fmt.Sprintf("Mesos: %v", v.Mesos)
		i++
	}
	if v.Docker != nil {
		fields[i] = fmt.Sprintf("Docker: %v", v.Docker)
		i++
	}

	return fmt.Sprintf("Container{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Container match the
// provided Container.
//
// This function performs a deep comparison.
func (v *Container) Equals(rhs *Container) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Mesos == nil && rhs.Mesos == nil) || (v.Mesos != nil && rhs.Mesos != nil && v.Mesos.Equals(rhs.Mesos))) {
		return false
	}
	if !((v.Docker == nil && rhs.Docker == nil) || (v.Docker != nil && rhs.Docker != nil && v.Docker.Equals(rhs.Docker))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Container.
func (v *Container) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Mesos != nil {
		err = multierr.Append(err, enc.AddObject("mesos", v.Mesos))
	}
	if v.Docker != nil {
		err = multierr.Append(err, enc.AddObject("docker", v.Docker))
	}
	return err
}

// GetMesos returns the value of Mesos if it is set or its
// zero value if it is unset.
func (v *Container) GetMesos() (o *MesosContainer) {
	if v != nil && v.Mesos != nil {
		return v.Mesos
	}

	return
}

// IsSetMesos returns true if Mesos is not nil.
func (v *Container) IsSetMesos() bool {
	return v != nil && v.Mesos != nil
}

// GetDocker returns the value of Docker if it is set or its
// zero value if it is unset.
func (v *Container) GetDocker() (o *DockerContainer) {
	if v != nil && v.Docker != nil {
		return v.Docker
	}

	return
}

// IsSetDocker returns true if Docker is not nil.
func (v *Container) IsSetDocker() bool {
	return v != nil && v.Docker != nil
}

// Defines the policy for launching a new cron job when one is already running.
type CronCollisionPolicy int32

const (
	// Kills the existing job with the colliding name, and runs the new cron job.
	CronCollisionPolicyKillExisting CronCollisionPolicy = 0
	// Cancels execution of the new job, leaving the running job in tact.
	CronCollisionPolicyCancelNew CronCollisionPolicy = 1
	// DEPRECATED. For existing jobs, treated the same as CANCEL_NEW.
	// createJob will reject jobs with this policy.
	CronCollisionPolicyRunOverlap CronCollisionPolicy = 2
)

// CronCollisionPolicy_Values returns all recognized values of CronCollisionPolicy.
func CronCollisionPolicy_Values() []CronCollisionPolicy {
	return []CronCollisionPolicy{
		CronCollisionPolicyKillExisting,
		CronCollisionPolicyCancelNew,
		CronCollisionPolicyRunOverlap,
	}
}

// UnmarshalText tries to decode CronCollisionPolicy from a byte slice
// containing its name.
//
//   var v CronCollisionPolicy
//   err := v.UnmarshalText([]byte("KILL_EXISTING"))
func (v *CronCollisionPolicy) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "KILL_EXISTING":
		*v = CronCollisionPolicyKillExisting
		return nil
	case "CANCEL_NEW":
		*v = CronCollisionPolicyCancelNew
		return nil
	case "RUN_OVERLAP":
		*v = CronCollisionPolicyRunOverlap
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "CronCollisionPolicy", err)
		}
		*v = CronCollisionPolicy(val)
		return nil
	}
}

// MarshalText encodes CronCollisionPolicy to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v CronCollisionPolicy) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("KILL_EXISTING"), nil
	case 1:
		return []byte("CANCEL_NEW"), nil
	case 2:
		return []byte("RUN_OVERLAP"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of CronCollisionPolicy.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v CronCollisionPolicy) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "KILL_EXISTING")
	case 1:
		enc.AddString("name", "CANCEL_NEW")
	case 2:
		enc.AddString("name", "RUN_OVERLAP")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v CronCollisionPolicy) Ptr() *CronCollisionPolicy {
	return &v
}

// ToWire translates CronCollisionPolicy into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v CronCollisionPolicy) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes CronCollisionPolicy from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return CronCollisionPolicy(0), err
//   }
//
//   var v CronCollisionPolicy
//   if err := v.FromWire(x); err != nil {
//     return CronCollisionPolicy(0), err
//   }
//   return v, nil
func (v *CronCollisionPolicy) FromWire(w wire.Value) error {
	*v = (CronCollisionPolicy)(w.GetI32())
	return nil
}

// String returns a readable string representation of CronCollisionPolicy.
func (v CronCollisionPolicy) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "KILL_EXISTING"
	case 1:
		return "CANCEL_NEW"
	case 2:
		return "RUN_OVERLAP"
	}
	return fmt.Sprintf("CronCollisionPolicy(%d)", w)
}

// Equals returns true if this CronCollisionPolicy value matches the provided
// value.
func (v CronCollisionPolicy) Equals(rhs CronCollisionPolicy) bool {
	return v == rhs
}

// MarshalJSON serializes CronCollisionPolicy into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v CronCollisionPolicy) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"KILL_EXISTING\""), nil
	case 1:
		return ([]byte)("\"CANCEL_NEW\""), nil
	case 2:
		return ([]byte)("\"RUN_OVERLAP\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode CronCollisionPolicy from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *CronCollisionPolicy) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "CronCollisionPolicy")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "CronCollisionPolicy")
		}
		*v = (CronCollisionPolicy)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "CronCollisionPolicy")
	}
}

// Describes a docker container
type DockerContainer struct {
	// The container image to be run
	Image *string `json:"image,omitempty"`
	// The arbitrary parameters to pass to container
	Parameters []*DockerParameter `json:"parameters,omitempty"`
}

type _List_DockerParameter_ValueList []*DockerParameter

func (v _List_DockerParameter_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_DockerParameter_ValueList) Size() int {
	return len(v)
}

func (_List_DockerParameter_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_DockerParameter_ValueList) Close() {}

// ToWire translates a DockerContainer struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *DockerContainer) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Image != nil {
		w, err = wire.NewValueString(*(v.Image)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Parameters != nil {
		w, err = wire.NewValueList(_List_DockerParameter_ValueList(v.Parameters)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _DockerParameter_Read(w wire.Value) (*DockerParameter, error) {
	var v DockerParameter
	err := v.FromWire(w)
	return &v, err
}

func _List_DockerParameter_Read(l wire.ValueList) ([]*DockerParameter, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*DockerParameter, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _DockerParameter_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a DockerContainer struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a DockerContainer struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v DockerContainer
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *DockerContainer) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Image = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TList {
				v.Parameters, err = _List_DockerParameter_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a DockerContainer
// struct.
func (v *DockerContainer) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Image != nil {
		fields[i] = fmt.Sprintf("Image: %v", *(v.Image))
		i++
	}
	if v.Parameters != nil {
		fields[i] = fmt.Sprintf("Parameters: %v", v.Parameters)
		i++
	}

	return fmt.Sprintf("DockerContainer{%v}", strings.Join(fields[:i], ", "))
}

func _List_DockerParameter_Equals(lhs, rhs []*DockerParameter) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this DockerContainer match the
// provided DockerContainer.
//
// This function performs a deep comparison.
func (v *DockerContainer) Equals(rhs *DockerContainer) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Image, rhs.Image) {
		return false
	}
	if !((v.Parameters == nil && rhs.Parameters == nil) || (v.Parameters != nil && rhs.Parameters != nil && _List_DockerParameter_Equals(v.Parameters, rhs.Parameters))) {
		return false
	}

	return true
}

type _List_DockerParameter_Zapper []*DockerParameter

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_DockerParameter_Zapper.
func (l _List_DockerParameter_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DockerContainer.
func (v *DockerContainer) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Image != nil {
		enc.AddString("image", *v.Image)
	}
	if v.Parameters != nil {
		err = multierr.Append(err, enc.AddArray("parameters", (_List_DockerParameter_Zapper)(v.Parameters)))
	}
	return err
}

// GetImage returns the value of Image if it is set or its
// zero value if it is unset.
func (v *DockerContainer) GetImage() (o string) {
	if v != nil && v.Image != nil {
		return *v.Image
	}

	return
}

// IsSetImage returns true if Image is not nil.
func (v *DockerContainer) IsSetImage() bool {
	return v != nil && v.Image != nil
}

// GetParameters returns the value of Parameters if it is set or its
// zero value if it is unset.
func (v *DockerContainer) GetParameters() (o []*DockerParameter) {
	if v != nil && v.Parameters != nil {
		return v.Parameters
	}

	return
}

// IsSetParameters returns true if Parameters is not nil.
func (v *DockerContainer) IsSetParameters() bool {
	return v != nil && v.Parameters != nil
}

// Describes an image for use with the Mesos unified containerizer in the Docker format
type DockerImage struct {
	// The name of the image to run
	Name *string `json:"name,omitempty"`
	// The Docker tag identifying the image
	Tag *string `json:"tag,omitempty"`
}

// ToWire translates a DockerImage struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *DockerImage) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Tag != nil {
		w, err = wire.NewValueString(*(v.Tag)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a DockerImage struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a DockerImage struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v DockerImage
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *DockerImage) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Tag = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a DockerImage
// struct.
func (v *DockerImage) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Tag != nil {
		fields[i] = fmt.Sprintf("Tag: %v", *(v.Tag))
		i++
	}

	return fmt.Sprintf("DockerImage{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this DockerImage match the
// provided DockerImage.
//
// This function performs a deep comparison.
func (v *DockerImage) Equals(rhs *DockerImage) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !_String_EqualsPtr(v.Tag, rhs.Tag) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DockerImage.
func (v *DockerImage) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.Tag != nil {
		enc.AddString("tag", *v.Tag)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *DockerImage) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *DockerImage) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetTag returns the value of Tag if it is set or its
// zero value if it is unset.
func (v *DockerImage) GetTag() (o string) {
	if v != nil && v.Tag != nil {
		return *v.Tag
	}

	return
}

// IsSetTag returns true if Tag is not nil.
func (v *DockerImage) IsSetTag() bool {
	return v != nil && v.Tag != nil
}

// Describes a parameter passed to docker cli
type DockerParameter struct {
	// a parameter to pass to docker. (e.g. volume)
	Name *string `json:"name,omitempty"`
	// the value to pass to a parameter (e.g. /src/webapp:/opt/webapp)
	Value *string `json:"value,omitempty"`
}

// ToWire translates a DockerParameter struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *DockerParameter) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Value != nil {
		w, err = wire.NewValueString(*(v.Value)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a DockerParameter struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a DockerParameter struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v DockerParameter
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *DockerParameter) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Value = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a DockerParameter
// struct.
func (v *DockerParameter) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Value != nil {
		fields[i] = fmt.Sprintf("Value: %v", *(v.Value))
		i++
	}

	return fmt.Sprintf("DockerParameter{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this DockerParameter match the
// provided DockerParameter.
//
// This function performs a deep comparison.
func (v *DockerParameter) Equals(rhs *DockerParameter) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !_String_EqualsPtr(v.Value, rhs.Value) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DockerParameter.
func (v *DockerParameter) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.Value != nil {
		enc.AddString("value", *v.Value)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *DockerParameter) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *DockerParameter) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetValue returns the value of Value if it is set or its
// zero value if it is unset.
func (v *DockerParameter) GetValue() (o string) {
	if v != nil && v.Value != nil {
		return *v.Value
	}

	return
}

// IsSetValue returns true if Value is not nil.
func (v *DockerParameter) IsSetValue() bool {
	return v != nil && v.Value != nil
}

type DrainHostsResult struct {
	Statuses []*HostStatus `json:"statuses,omitempty"`
}

type _Set_HostStatus_sliceType_ValueList []*HostStatus

func (v _Set_HostStatus_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_HostStatus_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_HostStatus_sliceType_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_HostStatus_sliceType_ValueList) Close() {}

// ToWire translates a DrainHostsResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *DrainHostsResult) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Statuses != nil {
		w, err = wire.NewValueSet(_Set_HostStatus_sliceType_ValueList(v.Statuses)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _HostStatus_Read(w wire.Value) (*HostStatus, error) {
	var v HostStatus
	err := v.FromWire(w)
	return &v, err
}

func _Set_HostStatus_sliceType_Read(s wire.ValueList) ([]*HostStatus, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*HostStatus, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _HostStatus_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

// FromWire deserializes a DrainHostsResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a DrainHostsResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v DrainHostsResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *DrainHostsResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TSet {
				v.Statuses, err = _Set_HostStatus_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a DrainHostsResult
// struct.
func (v *DrainHostsResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Statuses != nil {
		fields[i] = fmt.Sprintf("Statuses: %v", v.Statuses)
		i++
	}

	return fmt.Sprintf("DrainHostsResult{%v}", strings.Join(fields[:i], ", "))
}

func _Set_HostStatus_sliceType_Equals(lhs, rhs []*HostStatus) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this DrainHostsResult match the
// provided DrainHostsResult.
//
// This function performs a deep comparison.
func (v *DrainHostsResult) Equals(rhs *DrainHostsResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Statuses == nil && rhs.Statuses == nil) || (v.Statuses != nil && rhs.Statuses != nil && _Set_HostStatus_sliceType_Equals(v.Statuses, rhs.Statuses))) {
		return false
	}

	return true
}

type _Set_HostStatus_sliceType_Zapper []*HostStatus

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_HostStatus_sliceType_Zapper.
func (s _Set_HostStatus_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DrainHostsResult.
func (v *DrainHostsResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Statuses != nil {
		err = multierr.Append(err, enc.AddArray("statuses", (_Set_HostStatus_sliceType_Zapper)(v.Statuses)))
	}
	return err
}

// GetStatuses returns the value of Statuses if it is set or its
// zero value if it is unset.
func (v *DrainHostsResult) GetStatuses() (o []*HostStatus) {
	if v != nil && v.Statuses != nil {
		return v.Statuses
	}

	return
}

// IsSetStatuses returns true if Statuses is not nil.
func (v *DrainHostsResult) IsSetStatuses() bool {
	return v != nil && v.Statuses != nil
}

type EndMaintenanceResult struct {
	Statuses []*HostStatus `json:"statuses,omitempty"`
}

// ToWire translates a EndMaintenanceResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *EndMaintenanceResult) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Statuses != nil {
		w, err = wire.NewValueSet(_Set_HostStatus_sliceType_ValueList(v.Statuses)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a EndMaintenanceResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a EndMaintenanceResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v EndMaintenanceResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *EndMaintenanceResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TSet {
				v.Statuses, err = _Set_HostStatus_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a EndMaintenanceResult
// struct.
func (v *EndMaintenanceResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Statuses != nil {
		fields[i] = fmt.Sprintf("Statuses: %v", v.Statuses)
		i++
	}

	return fmt.Sprintf("EndMaintenanceResult{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this EndMaintenanceResult match the
// provided EndMaintenanceResult.
//
// This function performs a deep comparison.
func (v *EndMaintenanceResult) Equals(rhs *EndMaintenanceResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Statuses == nil && rhs.Statuses == nil) || (v.Statuses != nil && rhs.Statuses != nil && _Set_HostStatus_sliceType_Equals(v.Statuses, rhs.Statuses))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of EndMaintenanceResult.
func (v *EndMaintenanceResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Statuses != nil {
		err = multierr.Append(err, enc.AddArray("statuses", (_Set_HostStatus_sliceType_Zapper)(v.Statuses)))
	}
	return err
}

// GetStatuses returns the value of Statuses if it is set or its
// zero value if it is unset.
func (v *EndMaintenanceResult) GetStatuses() (o []*HostStatus) {
	if v != nil && v.Statuses != nil {
		return v.Statuses
	}

	return
}

// IsSetStatuses returns true if Statuses is not nil.
func (v *EndMaintenanceResult) IsSetStatuses() bool {
	return v != nil && v.Statuses != nil
}

type ExecutorConfig struct {
	// Name identifying the Executor.
	Name *string `json:"name,omitempty"`
	// Executor configuration data.
	Data *string `json:"data,omitempty"`
}

// ToWire translates a ExecutorConfig struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ExecutorConfig) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Data != nil {
		w, err = wire.NewValueString(*(v.Data)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ExecutorConfig struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ExecutorConfig struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ExecutorConfig
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ExecutorConfig) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Data = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ExecutorConfig
// struct.
func (v *ExecutorConfig) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Data != nil {
		fields[i] = fmt.Sprintf("Data: %v", *(v.Data))
		i++
	}

	return fmt.Sprintf("ExecutorConfig{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ExecutorConfig match the
// provided ExecutorConfig.
//
// This function performs a deep comparison.
func (v *ExecutorConfig) Equals(rhs *ExecutorConfig) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !_String_EqualsPtr(v.Data, rhs.Data) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ExecutorConfig.
func (v *ExecutorConfig) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.Data != nil {
		enc.AddString("data", *v.Data)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *ExecutorConfig) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *ExecutorConfig) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetData returns the value of Data if it is set or its
// zero value if it is unset.
func (v *ExecutorConfig) GetData() (o string) {
	if v != nil && v.Data != nil {
		return *v.Data
	}

	return
}

// IsSetData returns true if Data is not nil.
func (v *ExecutorConfig) IsSetData() bool {
	return v != nil && v.Data != nil
}

type ExplicitReconciliationSettings struct {
	BatchSize *int32 `json:"batchSize,omitempty"`
}

// ToWire translates a ExplicitReconciliationSettings struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ExplicitReconciliationSettings) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.BatchSize != nil {
		w, err = wire.NewValueI32(*(v.BatchSize)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ExplicitReconciliationSettings struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ExplicitReconciliationSettings struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ExplicitReconciliationSettings
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ExplicitReconciliationSettings) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.BatchSize = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ExplicitReconciliationSettings
// struct.
func (v *ExplicitReconciliationSettings) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.BatchSize != nil {
		fields[i] = fmt.Sprintf("BatchSize: %v", *(v.BatchSize))
		i++
	}

	return fmt.Sprintf("ExplicitReconciliationSettings{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ExplicitReconciliationSettings match the
// provided ExplicitReconciliationSettings.
//
// This function performs a deep comparison.
func (v *ExplicitReconciliationSettings) Equals(rhs *ExplicitReconciliationSettings) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.BatchSize, rhs.BatchSize) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ExplicitReconciliationSettings.
func (v *ExplicitReconciliationSettings) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.BatchSize != nil {
		enc.AddInt32("batchSize", *v.BatchSize)
	}
	return err
}

// GetBatchSize returns the value of BatchSize if it is set or its
// zero value if it is unset.
func (v *ExplicitReconciliationSettings) GetBatchSize() (o int32) {
	if v != nil && v.BatchSize != nil {
		return *v.BatchSize
	}

	return
}

// IsSetBatchSize returns true if BatchSize is not nil.
func (v *ExplicitReconciliationSettings) IsSetBatchSize() bool {
	return v != nil && v.BatchSize != nil
}

// Result of the getJobUpdateDetails call.
type GetJobUpdateDetailsResult struct {
	Details     *JobUpdateDetails   `json:"details,omitempty"`
	DetailsList []*JobUpdateDetails `json:"detailsList,omitempty"`
}

type _List_JobUpdateDetails_ValueList []*JobUpdateDetails

func (v _List_JobUpdateDetails_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_JobUpdateDetails_ValueList) Size() int {
	return len(v)
}

func (_List_JobUpdateDetails_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_JobUpdateDetails_ValueList) Close() {}

// ToWire translates a GetJobUpdateDetailsResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *GetJobUpdateDetailsResult) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Details != nil {
		w, err = v.Details.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.DetailsList != nil {
		w, err = wire.NewValueList(_List_JobUpdateDetails_ValueList(v.DetailsList)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _JobUpdateDetails_Read(w wire.Value) (*JobUpdateDetails, error) {
	var v JobUpdateDetails
	err := v.FromWire(w)
	return &v, err
}

func _List_JobUpdateDetails_Read(l wire.ValueList) ([]*JobUpdateDetails, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*JobUpdateDetails, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _JobUpdateDetails_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a GetJobUpdateDetailsResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a GetJobUpdateDetailsResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v GetJobUpdateDetailsResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *GetJobUpdateDetailsResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Details, err = _JobUpdateDetails_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TList {
				v.DetailsList, err = _List_JobUpdateDetails_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a GetJobUpdateDetailsResult
// struct.
func (v *GetJobUpdateDetailsResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Details != nil {
		fields[i] = fmt.Sprintf("Details: %v", v.Details)
		i++
	}
	if v.DetailsList != nil {
		fields[i] = fmt.Sprintf("DetailsList: %v", v.DetailsList)
		i++
	}

	return fmt.Sprintf("GetJobUpdateDetailsResult{%v}", strings.Join(fields[:i], ", "))
}

func _List_JobUpdateDetails_Equals(lhs, rhs []*JobUpdateDetails) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this GetJobUpdateDetailsResult match the
// provided GetJobUpdateDetailsResult.
//
// This function performs a deep comparison.
func (v *GetJobUpdateDetailsResult) Equals(rhs *GetJobUpdateDetailsResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Details == nil && rhs.Details == nil) || (v.Details != nil && rhs.Details != nil && v.Details.Equals(rhs.Details))) {
		return false
	}
	if !((v.DetailsList == nil && rhs.DetailsList == nil) || (v.DetailsList != nil && rhs.DetailsList != nil && _List_JobUpdateDetails_Equals(v.DetailsList, rhs.DetailsList))) {
		return false
	}

	return true
}

type _List_JobUpdateDetails_Zapper []*JobUpdateDetails

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_JobUpdateDetails_Zapper.
func (l _List_JobUpdateDetails_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of GetJobUpdateDetailsResult.
func (v *GetJobUpdateDetailsResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Details != nil {
		err = multierr.Append(err, enc.AddObject("details", v.Details))
	}
	if v.DetailsList != nil {
		err = multierr.Append(err, enc.AddArray("detailsList", (_List_JobUpdateDetails_Zapper)(v.DetailsList)))
	}
	return err
}

// GetDetails returns the value of Details if it is set or its
// zero value if it is unset.
func (v *GetJobUpdateDetailsResult) GetDetails() (o *JobUpdateDetails) {
	if v != nil && v.Details != nil {
		return v.Details
	}

	return
}

// IsSetDetails returns true if Details is not nil.
func (v *GetJobUpdateDetailsResult) IsSetDetails() bool {
	return v != nil && v.Details != nil
}

// GetDetailsList returns the value of DetailsList if it is set or its
// zero value if it is unset.
func (v *GetJobUpdateDetailsResult) GetDetailsList() (o []*JobUpdateDetails) {
	if v != nil && v.DetailsList != nil {
		return v.DetailsList
	}

	return
}

// IsSetDetailsList returns true if DetailsList is not nil.
func (v *GetJobUpdateDetailsResult) IsSetDetailsList() bool {
	return v != nil && v.DetailsList != nil
}

type GetJobUpdateDiffResult struct {
	// Instance addition diff details.
	Add []*ConfigGroup `json:"add,omitempty"`
	// Instance removal diff details.
	Remove []*ConfigGroup `json:"remove,omitempty"`
	// Instance update diff details.
	Update []*ConfigGroup `json:"update,omitempty"`
	// Instances unchanged by the update.
	Unchanged []*ConfigGroup `json:"unchanged,omitempty"`
}

// ToWire translates a GetJobUpdateDiffResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *GetJobUpdateDiffResult) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Add != nil {
		w, err = wire.NewValueSet(_Set_ConfigGroup_sliceType_ValueList(v.Add)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Remove != nil {
		w, err = wire.NewValueSet(_Set_ConfigGroup_sliceType_ValueList(v.Remove)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Update != nil {
		w, err = wire.NewValueSet(_Set_ConfigGroup_sliceType_ValueList(v.Update)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Unchanged != nil {
		w, err = wire.NewValueSet(_Set_ConfigGroup_sliceType_ValueList(v.Unchanged)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a GetJobUpdateDiffResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a GetJobUpdateDiffResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v GetJobUpdateDiffResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *GetJobUpdateDiffResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TSet {
				v.Add, err = _Set_ConfigGroup_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TSet {
				v.Remove, err = _Set_ConfigGroup_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TSet {
				v.Update, err = _Set_ConfigGroup_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TSet {
				v.Unchanged, err = _Set_ConfigGroup_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a GetJobUpdateDiffResult
// struct.
func (v *GetJobUpdateDiffResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Add != nil {
		fields[i] = fmt.Sprintf("Add: %v", v.Add)
		i++
	}
	if v.Remove != nil {
		fields[i] = fmt.Sprintf("Remove: %v", v.Remove)
		i++
	}
	if v.Update != nil {
		fields[i] = fmt.Sprintf("Update: %v", v.Update)
		i++
	}
	if v.Unchanged != nil {
		fields[i] = fmt.Sprintf("Unchanged: %v", v.Unchanged)
		i++
	}

	return fmt.Sprintf("GetJobUpdateDiffResult{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this GetJobUpdateDiffResult match the
// provided GetJobUpdateDiffResult.
//
// This function performs a deep comparison.
func (v *GetJobUpdateDiffResult) Equals(rhs *GetJobUpdateDiffResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Add == nil && rhs.Add == nil) || (v.Add != nil && rhs.Add != nil && _Set_ConfigGroup_sliceType_Equals(v.Add, rhs.Add))) {
		return false
	}
	if !((v.Remove == nil && rhs.Remove == nil) || (v.Remove != nil && rhs.Remove != nil && _Set_ConfigGroup_sliceType_Equals(v.Remove, rhs.Remove))) {
		return false
	}
	if !((v.Update == nil && rhs.Update == nil) || (v.Update != nil && rhs.Update != nil && _Set_ConfigGroup_sliceType_Equals(v.Update, rhs.Update))) {
		return false
	}
	if !((v.Unchanged == nil && rhs.Unchanged == nil) || (v.Unchanged != nil && rhs.Unchanged != nil && _Set_ConfigGroup_sliceType_Equals(v.Unchanged, rhs.Unchanged))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of GetJobUpdateDiffResult.
func (v *GetJobUpdateDiffResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Add != nil {
		err = multierr.Append(err, enc.AddArray("add", (_Set_ConfigGroup_sliceType_Zapper)(v.Add)))
	}
	if v.Remove != nil {
		err = multierr.Append(err, enc.AddArray("remove", (_Set_ConfigGroup_sliceType_Zapper)(v.Remove)))
	}
	if v.Update != nil {
		err = multierr.Append(err, enc.AddArray("update", (_Set_ConfigGroup_sliceType_Zapper)(v.Update)))
	}
	if v.Unchanged != nil {
		err = multierr.Append(err, enc.AddArray("unchanged", (_Set_ConfigGroup_sliceType_Zapper)(v.Unchanged)))
	}
	return err
}

// GetAdd returns the value of Add if it is set or its
// zero value if it is unset.
func (v *GetJobUpdateDiffResult) GetAdd() (o []*ConfigGroup) {
	if v != nil && v.Add != nil {
		return v.Add
	}

	return
}

// IsSetAdd returns true if Add is not nil.
func (v *GetJobUpdateDiffResult) IsSetAdd() bool {
	return v != nil && v.Add != nil
}

// GetRemove returns the value of Remove if it is set or its
// zero value if it is unset.
func (v *GetJobUpdateDiffResult) GetRemove() (o []*ConfigGroup) {
	if v != nil && v.Remove != nil {
		return v.Remove
	}

	return
}

// IsSetRemove returns true if Remove is not nil.
func (v *GetJobUpdateDiffResult) IsSetRemove() bool {
	return v != nil && v.Remove != nil
}

// GetUpdate returns the value of Update if it is set or its
// zero value if it is unset.
func (v *GetJobUpdateDiffResult) GetUpdate() (o []*ConfigGroup) {
	if v != nil && v.Update != nil {
		return v.Update
	}

	return
}

// IsSetUpdate returns true if Update is not nil.
func (v *GetJobUpdateDiffResult) IsSetUpdate() bool {
	return v != nil && v.Update != nil
}

// GetUnchanged returns the value of Unchanged if it is set or its
// zero value if it is unset.
func (v *GetJobUpdateDiffResult) GetUnchanged() (o []*ConfigGroup) {
	if v != nil && v.Unchanged != nil {
		return v.Unchanged
	}

	return
}

// IsSetUnchanged returns true if Unchanged is not nil.
func (v *GetJobUpdateDiffResult) IsSetUnchanged() bool {
	return v != nil && v.Unchanged != nil
}

// Result of the getJobUpdateSummaries call.
type GetJobUpdateSummariesResult struct {
	UpdateSummaries []*JobUpdateSummary `json:"updateSummaries,omitempty"`
}

type _List_JobUpdateSummary_ValueList []*JobUpdateSummary

func (v _List_JobUpdateSummary_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_JobUpdateSummary_ValueList) Size() int {
	return len(v)
}

func (_List_JobUpdateSummary_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_JobUpdateSummary_ValueList) Close() {}

// ToWire translates a GetJobUpdateSummariesResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *GetJobUpdateSummariesResult) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.UpdateSummaries != nil {
		w, err = wire.NewValueList(_List_JobUpdateSummary_ValueList(v.UpdateSummaries)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _JobUpdateSummary_Read(w wire.Value) (*JobUpdateSummary, error) {
	var v JobUpdateSummary
	err := v.FromWire(w)
	return &v, err
}

func _List_JobUpdateSummary_Read(l wire.ValueList) ([]*JobUpdateSummary, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*JobUpdateSummary, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _JobUpdateSummary_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a GetJobUpdateSummariesResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a GetJobUpdateSummariesResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v GetJobUpdateSummariesResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *GetJobUpdateSummariesResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.UpdateSummaries, err = _List_JobUpdateSummary_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a GetJobUpdateSummariesResult
// struct.
func (v *GetJobUpdateSummariesResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.UpdateSummaries != nil {
		fields[i] = fmt.Sprintf("UpdateSummaries: %v", v.UpdateSummaries)
		i++
	}

	return fmt.Sprintf("GetJobUpdateSummariesResult{%v}", strings.Join(fields[:i], ", "))
}

func _List_JobUpdateSummary_Equals(lhs, rhs []*JobUpdateSummary) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this GetJobUpdateSummariesResult match the
// provided GetJobUpdateSummariesResult.
//
// This function performs a deep comparison.
func (v *GetJobUpdateSummariesResult) Equals(rhs *GetJobUpdateSummariesResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.UpdateSummaries == nil && rhs.UpdateSummaries == nil) || (v.UpdateSummaries != nil && rhs.UpdateSummaries != nil && _List_JobUpdateSummary_Equals(v.UpdateSummaries, rhs.UpdateSummaries))) {
		return false
	}

	return true
}

type _List_JobUpdateSummary_Zapper []*JobUpdateSummary

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_JobUpdateSummary_Zapper.
func (l _List_JobUpdateSummary_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of GetJobUpdateSummariesResult.
func (v *GetJobUpdateSummariesResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.UpdateSummaries != nil {
		err = multierr.Append(err, enc.AddArray("updateSummaries", (_List_JobUpdateSummary_Zapper)(v.UpdateSummaries)))
	}
	return err
}

// GetUpdateSummaries returns the value of UpdateSummaries if it is set or its
// zero value if it is unset.
func (v *GetJobUpdateSummariesResult) GetUpdateSummaries() (o []*JobUpdateSummary) {
	if v != nil && v.UpdateSummaries != nil {
		return v.UpdateSummaries
	}

	return
}

// IsSetUpdateSummaries returns true if UpdateSummaries is not nil.
func (v *GetJobUpdateSummariesResult) IsSetUpdateSummaries() bool {
	return v != nil && v.UpdateSummaries != nil
}

type GetJobsResult struct {
	Configs []*JobConfiguration `json:"configs,omitempty"`
}

type _Set_JobConfiguration_sliceType_ValueList []*JobConfiguration

func (v _Set_JobConfiguration_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_JobConfiguration_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_JobConfiguration_sliceType_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_JobConfiguration_sliceType_ValueList) Close() {}

// ToWire translates a GetJobsResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *GetJobsResult) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Configs != nil {
		w, err = wire.NewValueSet(_Set_JobConfiguration_sliceType_ValueList(v.Configs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _JobConfiguration_Read(w wire.Value) (*JobConfiguration, error) {
	var v JobConfiguration
	err := v.FromWire(w)
	return &v, err
}

func _Set_JobConfiguration_sliceType_Read(s wire.ValueList) ([]*JobConfiguration, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*JobConfiguration, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _JobConfiguration_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

// FromWire deserializes a GetJobsResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a GetJobsResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v GetJobsResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *GetJobsResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TSet {
				v.Configs, err = _Set_JobConfiguration_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a GetJobsResult
// struct.
func (v *GetJobsResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Configs != nil {
		fields[i] = fmt.Sprintf("Configs: %v", v.Configs)
		i++
	}

	return fmt.Sprintf("GetJobsResult{%v}", strings.Join(fields[:i], ", "))
}

func _Set_JobConfiguration_sliceType_Equals(lhs, rhs []*JobConfiguration) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this GetJobsResult match the
// provided GetJobsResult.
//
// This function performs a deep comparison.
func (v *GetJobsResult) Equals(rhs *GetJobsResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Configs == nil && rhs.Configs == nil) || (v.Configs != nil && rhs.Configs != nil && _Set_JobConfiguration_sliceType_Equals(v.Configs, rhs.Configs))) {
		return false
	}

	return true
}

type _Set_JobConfiguration_sliceType_Zapper []*JobConfiguration

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_JobConfiguration_sliceType_Zapper.
func (s _Set_JobConfiguration_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of GetJobsResult.
func (v *GetJobsResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Configs != nil {
		err = multierr.Append(err, enc.AddArray("configs", (_Set_JobConfiguration_sliceType_Zapper)(v.Configs)))
	}
	return err
}

// GetConfigs returns the value of Configs if it is set or its
// zero value if it is unset.
func (v *GetJobsResult) GetConfigs() (o []*JobConfiguration) {
	if v != nil && v.Configs != nil {
		return v.Configs
	}

	return
}

// IsSetConfigs returns true if Configs is not nil.
func (v *GetJobsResult) IsSetConfigs() bool {
	return v != nil && v.Configs != nil
}

type GetPendingReasonResult struct {
	Reasons []*PendingReason `json:"reasons,omitempty"`
}

type _Set_PendingReason_sliceType_ValueList []*PendingReason

func (v _Set_PendingReason_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_PendingReason_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_PendingReason_sliceType_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_PendingReason_sliceType_ValueList) Close() {}

// ToWire translates a GetPendingReasonResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *GetPendingReasonResult) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Reasons != nil {
		w, err = wire.NewValueSet(_Set_PendingReason_sliceType_ValueList(v.Reasons)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _PendingReason_Read(w wire.Value) (*PendingReason, error) {
	var v PendingReason
	err := v.FromWire(w)
	return &v, err
}

func _Set_PendingReason_sliceType_Read(s wire.ValueList) ([]*PendingReason, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*PendingReason, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _PendingReason_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

// FromWire deserializes a GetPendingReasonResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a GetPendingReasonResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v GetPendingReasonResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *GetPendingReasonResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TSet {
				v.Reasons, err = _Set_PendingReason_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a GetPendingReasonResult
// struct.
func (v *GetPendingReasonResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Reasons != nil {
		fields[i] = fmt.Sprintf("Reasons: %v", v.Reasons)
		i++
	}

	return fmt.Sprintf("GetPendingReasonResult{%v}", strings.Join(fields[:i], ", "))
}

func _Set_PendingReason_sliceType_Equals(lhs, rhs []*PendingReason) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this GetPendingReasonResult match the
// provided GetPendingReasonResult.
//
// This function performs a deep comparison.
func (v *GetPendingReasonResult) Equals(rhs *GetPendingReasonResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Reasons == nil && rhs.Reasons == nil) || (v.Reasons != nil && rhs.Reasons != nil && _Set_PendingReason_sliceType_Equals(v.Reasons, rhs.Reasons))) {
		return false
	}

	return true
}

type _Set_PendingReason_sliceType_Zapper []*PendingReason

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_PendingReason_sliceType_Zapper.
func (s _Set_PendingReason_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of GetPendingReasonResult.
func (v *GetPendingReasonResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Reasons != nil {
		err = multierr.Append(err, enc.AddArray("reasons", (_Set_PendingReason_sliceType_Zapper)(v.Reasons)))
	}
	return err
}

// GetReasons returns the value of Reasons if it is set or its
// zero value if it is unset.
func (v *GetPendingReasonResult) GetReasons() (o []*PendingReason) {
	if v != nil && v.Reasons != nil {
		return v.Reasons
	}

	return
}

// IsSetReasons returns true if Reasons is not nil.
func (v *GetPendingReasonResult) IsSetReasons() bool {
	return v != nil && v.Reasons != nil
}

type GetQuotaResult struct {
	// Total allocated resource quota.
	Quota *ResourceAggregate `json:"quota,omitempty"`
	// Resources consumed by production jobs from a shared resource pool.
	ProdSharedConsumption *ResourceAggregate `json:"prodSharedConsumption,omitempty"`
	// Resources consumed by non-production jobs from a shared resource pool.
	NonProdSharedConsumption *ResourceAggregate `json:"nonProdSharedConsumption,omitempty"`
	// Resources consumed by production jobs from a dedicated resource pool.
	ProdDedicatedConsumption *ResourceAggregate `json:"prodDedicatedConsumption,omitempty"`
	// Resources consumed by non-production jobs from a dedicated resource pool.
	NonProdDedicatedConsumption *ResourceAggregate `json:"nonProdDedicatedConsumption,omitempty"`
}

// ToWire translates a GetQuotaResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *GetQuotaResult) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Quota != nil {
		w, err = v.Quota.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ProdSharedConsumption != nil {
		w, err = v.ProdSharedConsumption.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.NonProdSharedConsumption != nil {
		w, err = v.NonProdSharedConsumption.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.ProdDedicatedConsumption != nil {
		w, err = v.ProdDedicatedConsumption.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.NonProdDedicatedConsumption != nil {
		w, err = v.NonProdDedicatedConsumption.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ResourceAggregate_Read(w wire.Value) (*ResourceAggregate, error) {
	var v ResourceAggregate
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a GetQuotaResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a GetQuotaResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v GetQuotaResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *GetQuotaResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Quota, err = _ResourceAggregate_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ProdSharedConsumption, err = _ResourceAggregate_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.NonProdSharedConsumption, err = _ResourceAggregate_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TStruct {
				v.ProdDedicatedConsumption, err = _ResourceAggregate_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TStruct {
				v.NonProdDedicatedConsumption, err = _ResourceAggregate_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a GetQuotaResult
// struct.
func (v *GetQuotaResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [5]string
	i := 0
	if v.Quota != nil {
		fields[i] = fmt.Sprintf("Quota: %v", v.Quota)
		i++
	}
	if v.ProdSharedConsumption != nil {
		fields[i] = fmt.Sprintf("ProdSharedConsumption: %v", v.ProdSharedConsumption)
		i++
	}
	if v.NonProdSharedConsumption != nil {
		fields[i] = fmt.Sprintf("NonProdSharedConsumption: %v", v.NonProdSharedConsumption)
		i++
	}
	if v.ProdDedicatedConsumption != nil {
		fields[i] = fmt.Sprintf("ProdDedicatedConsumption: %v", v.ProdDedicatedConsumption)
		i++
	}
	if v.NonProdDedicatedConsumption != nil {
		fields[i] = fmt.Sprintf("NonProdDedicatedConsumption: %v", v.NonProdDedicatedConsumption)
		i++
	}

	return fmt.Sprintf("GetQuotaResult{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this GetQuotaResult match the
// provided GetQuotaResult.
//
// This function performs a deep comparison.
func (v *GetQuotaResult) Equals(rhs *GetQuotaResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Quota == nil && rhs.Quota == nil) || (v.Quota != nil && rhs.Quota != nil && v.Quota.Equals(rhs.Quota))) {
		return false
	}
	if !((v.ProdSharedConsumption == nil && rhs.ProdSharedConsumption == nil) || (v.ProdSharedConsumption != nil && rhs.ProdSharedConsumption != nil && v.ProdSharedConsumption.Equals(rhs.ProdSharedConsumption))) {
		return false
	}
	if !((v.NonProdSharedConsumption == nil && rhs.NonProdSharedConsumption == nil) || (v.NonProdSharedConsumption != nil && rhs.NonProdSharedConsumption != nil && v.NonProdSharedConsumption.Equals(rhs.NonProdSharedConsumption))) {
		return false
	}
	if !((v.ProdDedicatedConsumption == nil && rhs.ProdDedicatedConsumption == nil) || (v.ProdDedicatedConsumption != nil && rhs.ProdDedicatedConsumption != nil && v.ProdDedicatedConsumption.Equals(rhs.ProdDedicatedConsumption))) {
		return false
	}
	if !((v.NonProdDedicatedConsumption == nil && rhs.NonProdDedicatedConsumption == nil) || (v.NonProdDedicatedConsumption != nil && rhs.NonProdDedicatedConsumption != nil && v.NonProdDedicatedConsumption.Equals(rhs.NonProdDedicatedConsumption))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of GetQuotaResult.
func (v *GetQuotaResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Quota != nil {
		err = multierr.Append(err, enc.AddObject("quota", v.Quota))
	}
	if v.ProdSharedConsumption != nil {
		err = multierr.Append(err, enc.AddObject("prodSharedConsumption", v.ProdSharedConsumption))
	}
	if v.NonProdSharedConsumption != nil {
		err = multierr.Append(err, enc.AddObject("nonProdSharedConsumption", v.NonProdSharedConsumption))
	}
	if v.ProdDedicatedConsumption != nil {
		err = multierr.Append(err, enc.AddObject("prodDedicatedConsumption", v.ProdDedicatedConsumption))
	}
	if v.NonProdDedicatedConsumption != nil {
		err = multierr.Append(err, enc.AddObject("nonProdDedicatedConsumption", v.NonProdDedicatedConsumption))
	}
	return err
}

// GetQuota returns the value of Quota if it is set or its
// zero value if it is unset.
func (v *GetQuotaResult) GetQuota() (o *ResourceAggregate) {
	if v != nil && v.Quota != nil {
		return v.Quota
	}

	return
}

// IsSetQuota returns true if Quota is not nil.
func (v *GetQuotaResult) IsSetQuota() bool {
	return v != nil && v.Quota != nil
}

// GetProdSharedConsumption returns the value of ProdSharedConsumption if it is set or its
// zero value if it is unset.
func (v *GetQuotaResult) GetProdSharedConsumption() (o *ResourceAggregate) {
	if v != nil && v.ProdSharedConsumption != nil {
		return v.ProdSharedConsumption
	}

	return
}

// IsSetProdSharedConsumption returns true if ProdSharedConsumption is not nil.
func (v *GetQuotaResult) IsSetProdSharedConsumption() bool {
	return v != nil && v.ProdSharedConsumption != nil
}

// GetNonProdSharedConsumption returns the value of NonProdSharedConsumption if it is set or its
// zero value if it is unset.
func (v *GetQuotaResult) GetNonProdSharedConsumption() (o *ResourceAggregate) {
	if v != nil && v.NonProdSharedConsumption != nil {
		return v.NonProdSharedConsumption
	}

	return
}

// IsSetNonProdSharedConsumption returns true if NonProdSharedConsumption is not nil.
func (v *GetQuotaResult) IsSetNonProdSharedConsumption() bool {
	return v != nil && v.NonProdSharedConsumption != nil
}

// GetProdDedicatedConsumption returns the value of ProdDedicatedConsumption if it is set or its
// zero value if it is unset.
func (v *GetQuotaResult) GetProdDedicatedConsumption() (o *ResourceAggregate) {
	if v != nil && v.ProdDedicatedConsumption != nil {
		return v.ProdDedicatedConsumption
	}

	return
}

// IsSetProdDedicatedConsumption returns true if ProdDedicatedConsumption is not nil.
func (v *GetQuotaResult) IsSetProdDedicatedConsumption() bool {
	return v != nil && v.ProdDedicatedConsumption != nil
}

// GetNonProdDedicatedConsumption returns the value of NonProdDedicatedConsumption if it is set or its
// zero value if it is unset.
func (v *GetQuotaResult) GetNonProdDedicatedConsumption() (o *ResourceAggregate) {
	if v != nil && v.NonProdDedicatedConsumption != nil {
		return v.NonProdDedicatedConsumption
	}

	return
}

// IsSetNonProdDedicatedConsumption returns true if NonProdDedicatedConsumption is not nil.
func (v *GetQuotaResult) IsSetNonProdDedicatedConsumption() bool {
	return v != nil && v.NonProdDedicatedConsumption != nil
}

// Result of the getTierConfigResult call.
type GetTierConfigResult struct {
	// Name of the default tier.
	DefaultTierName *string `json:"defaultTierName,omitempty"`
	// Set of tier configurations.
	Tiers []*TierConfig `json:"tiers,omitempty"`
}

type _Set_TierConfig_sliceType_ValueList []*TierConfig

func (v _Set_TierConfig_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_TierConfig_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_TierConfig_sliceType_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_TierConfig_sliceType_ValueList) Close() {}

// ToWire translates a GetTierConfigResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *GetTierConfigResult) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.DefaultTierName != nil {
		w, err = wire.NewValueString(*(v.DefaultTierName)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Tiers != nil {
		w, err = wire.NewValueSet(_Set_TierConfig_sliceType_ValueList(v.Tiers)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _TierConfig_Read(w wire.Value) (*TierConfig, error) {
	var v TierConfig
	err := v.FromWire(w)
	return &v, err
}

func _Set_TierConfig_sliceType_Read(s wire.ValueList) ([]*TierConfig, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*TierConfig, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _TierConfig_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

// FromWire deserializes a GetTierConfigResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a GetTierConfigResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v GetTierConfigResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *GetTierConfigResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.DefaultTierName = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TSet {
				v.Tiers, err = _Set_TierConfig_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a GetTierConfigResult
// struct.
func (v *GetTierConfigResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.DefaultTierName != nil {
		fields[i] = fmt.Sprintf("DefaultTierName: %v", *(v.DefaultTierName))
		i++
	}
	if v.Tiers != nil {
		fields[i] = fmt.Sprintf("Tiers: %v", v.Tiers)
		i++
	}

	return fmt.Sprintf("GetTierConfigResult{%v}", strings.Join(fields[:i], ", "))
}

func _Set_TierConfig_sliceType_Equals(lhs, rhs []*TierConfig) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this GetTierConfigResult match the
// provided GetTierConfigResult.
//
// This function performs a deep comparison.
func (v *GetTierConfigResult) Equals(rhs *GetTierConfigResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.DefaultTierName, rhs.DefaultTierName) {
		return false
	}
	if !((v.Tiers == nil && rhs.Tiers == nil) || (v.Tiers != nil && rhs.Tiers != nil && _Set_TierConfig_sliceType_Equals(v.Tiers, rhs.Tiers))) {
		return false
	}

	return true
}

type _Set_TierConfig_sliceType_Zapper []*TierConfig

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_TierConfig_sliceType_Zapper.
func (s _Set_TierConfig_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of GetTierConfigResult.
func (v *GetTierConfigResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.DefaultTierName != nil {
		enc.AddString("defaultTierName", *v.DefaultTierName)
	}
	if v.Tiers != nil {
		err = multierr.Append(err, enc.AddArray("tiers", (_Set_TierConfig_sliceType_Zapper)(v.Tiers)))
	}
	return err
}

// GetDefaultTierName returns the value of DefaultTierName if it is set or its
// zero value if it is unset.
func (v *GetTierConfigResult) GetDefaultTierName() (o string) {
	if v != nil && v.DefaultTierName != nil {
		return *v.DefaultTierName
	}

	return
}

// IsSetDefaultTierName returns true if DefaultTierName is not nil.
func (v *GetTierConfigResult) IsSetDefaultTierName() bool {
	return v != nil && v.DefaultTierName != nil
}

// GetTiers returns the value of Tiers if it is set or its
// zero value if it is unset.
func (v *GetTierConfigResult) GetTiers() (o []*TierConfig) {
	if v != nil && v.Tiers != nil {
		return v.Tiers
	}

	return
}

// IsSetTiers returns true if Tiers is not nil.
func (v *GetTierConfigResult) IsSetTiers() bool {
	return v != nil && v.Tiers != nil
}

// The attributes assigned to a host.
type HostAttributes struct {
	Host       *string          `json:"host,omitempty"`
	Attributes []*Attribute     `json:"attributes,omitempty"`
	Mode       *MaintenanceMode `json:"mode,omitempty"`
	SlaveId    *string          `json:"slaveId,omitempty"`
}

type _Set_Attribute_sliceType_ValueList []*Attribute

func (v _Set_Attribute_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_Attribute_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_Attribute_sliceType_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_Attribute_sliceType_ValueList) Close() {}

// ToWire translates a HostAttributes struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *HostAttributes) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Host != nil {
		w, err = wire.NewValueString(*(v.Host)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Attributes != nil {
		w, err = wire.NewValueSet(_Set_Attribute_sliceType_ValueList(v.Attributes)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Mode != nil {
		w, err = v.Mode.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.SlaveId != nil {
		w, err = wire.NewValueString(*(v.SlaveId)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Attribute_Read(w wire.Value) (*Attribute, error) {
	var v Attribute
	err := v.FromWire(w)
	return &v, err
}

func _Set_Attribute_sliceType_Read(s wire.ValueList) ([]*Attribute, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Attribute, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _Attribute_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

func _MaintenanceMode_Read(w wire.Value) (MaintenanceMode, error) {
	var v MaintenanceMode
	err := v.FromWire(w)
	return v, err
}

// FromWire deserializes a HostAttributes struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a HostAttributes struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v HostAttributes
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *HostAttributes) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Host = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TSet {
				v.Attributes, err = _Set_Attribute_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x MaintenanceMode
				x, err = _MaintenanceMode_Read(field.Value)
				v.Mode = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.SlaveId = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a HostAttributes
// struct.
func (v *HostAttributes) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Host != nil {
		fields[i] = fmt.Sprintf("Host: %v", *(v.Host))
		i++
	}
	if v.Attributes != nil {
		fields[i] = fmt.Sprintf("Attributes: %v", v.Attributes)
		i++
	}
	if v.Mode != nil {
		fields[i] = fmt.Sprintf("Mode: %v", *(v.Mode))
		i++
	}
	if v.SlaveId != nil {
		fields[i] = fmt.Sprintf("SlaveId: %v", *(v.SlaveId))
		i++
	}

	return fmt.Sprintf("HostAttributes{%v}", strings.Join(fields[:i], ", "))
}

func _Set_Attribute_sliceType_Equals(lhs, rhs []*Attribute) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

func _MaintenanceMode_EqualsPtr(lhs, rhs *MaintenanceMode) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this HostAttributes match the
// provided HostAttributes.
//
// This function performs a deep comparison.
func (v *HostAttributes) Equals(rhs *HostAttributes) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Host, rhs.Host) {
		return false
	}
	if !((v.Attributes == nil && rhs.Attributes == nil) || (v.Attributes != nil && rhs.Attributes != nil && _Set_Attribute_sliceType_Equals(v.Attributes, rhs.Attributes))) {
		return false
	}
	if !_MaintenanceMode_EqualsPtr(v.Mode, rhs.Mode) {
		return false
	}
	if !_String_EqualsPtr(v.SlaveId, rhs.SlaveId) {
		return false
	}

	return true
}

type _Set_Attribute_sliceType_Zapper []*Attribute

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_Attribute_sliceType_Zapper.
func (s _Set_Attribute_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of HostAttributes.
func (v *HostAttributes) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Host != nil {
		enc.AddString("host", *v.Host)
	}
	if v.Attributes != nil {
		err = multierr.Append(err, enc.AddArray("attributes", (_Set_Attribute_sliceType_Zapper)(v.Attributes)))
	}
	if v.Mode != nil {
		err = multierr.Append(err, enc.AddObject("mode", *v.Mode))
	}
	if v.SlaveId != nil {
		enc.AddString("slaveId", *v.SlaveId)
	}
	return err
}

// GetHost returns the value of Host if it is set or its
// zero value if it is unset.
func (v *HostAttributes) GetHost() (o string) {
	if v != nil && v.Host != nil {
		return *v.Host
	}

	return
}

// IsSetHost returns true if Host is not nil.
func (v *HostAttributes) IsSetHost() bool {
	return v != nil && v.Host != nil
}

// GetAttributes returns the value of Attributes if it is set or its
// zero value if it is unset.
func (v *HostAttributes) GetAttributes() (o []*Attribute) {
	if v != nil && v.Attributes != nil {
		return v.Attributes
	}

	return
}

// IsSetAttributes returns true if Attributes is not nil.
func (v *HostAttributes) IsSetAttributes() bool {
	return v != nil && v.Attributes != nil
}

// GetMode returns the value of Mode if it is set or its
// zero value if it is unset.
func (v *HostAttributes) GetMode() (o MaintenanceMode) {
	if v != nil && v.Mode != nil {
		return *v.Mode
	}

	return
}

// IsSetMode returns true if Mode is not nil.
func (v *HostAttributes) IsSetMode() bool {
	return v != nil && v.Mode != nil
}

// GetSlaveId returns the value of SlaveId if it is set or its
// zero value if it is unset.
func (v *HostAttributes) GetSlaveId() (o string) {
	if v != nil && v.SlaveId != nil {
		return *v.SlaveId
	}

	return
}

// IsSetSlaveId returns true if SlaveId is not nil.
func (v *HostAttributes) IsSetSlaveId() bool {
	return v != nil && v.SlaveId != nil
}

type HostStatus struct {
	Host *string          `json:"host,omitempty"`
	Mode *MaintenanceMode `json:"mode,omitempty"`
}

// ToWire translates a HostStatus struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *HostStatus) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Host != nil {
		w, err = wire.NewValueString(*(v.Host)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Mode != nil {
		w, err = v.Mode.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a HostStatus struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a HostStatus struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v HostStatus
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *HostStatus) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Host = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x MaintenanceMode
				x, err = _MaintenanceMode_Read(field.Value)
				v.Mode = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a HostStatus
// struct.
func (v *HostStatus) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Host != nil {
		fields[i] = fmt.Sprintf("Host: %v", *(v.Host))
		i++
	}
	if v.Mode != nil {
		fields[i] = fmt.Sprintf("Mode: %v", *(v.Mode))
		i++
	}

	return fmt.Sprintf("HostStatus{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this HostStatus match the
// provided HostStatus.
//
// This function performs a deep comparison.
func (v *HostStatus) Equals(rhs *HostStatus) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Host, rhs.Host) {
		return false
	}
	if !_MaintenanceMode_EqualsPtr(v.Mode, rhs.Mode) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of HostStatus.
func (v *HostStatus) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Host != nil {
		enc.AddString("host", *v.Host)
	}
	if v.Mode != nil {
		err = multierr.Append(err, enc.AddObject("mode", *v.Mode))
	}
	return err
}

// GetHost returns the value of Host if it is set or its
// zero value if it is unset.
func (v *HostStatus) GetHost() (o string) {
	if v != nil && v.Host != nil {
		return *v.Host
	}

	return
}

// IsSetHost returns true if Host is not nil.
func (v *HostStatus) IsSetHost() bool {
	return v != nil && v.Host != nil
}

// GetMode returns the value of Mode if it is set or its
// zero value if it is unset.
func (v *HostStatus) GetMode() (o MaintenanceMode) {
	if v != nil && v.Mode != nil {
		return *v.Mode
	}

	return
}

// IsSetMode returns true if Mode is not nil.
func (v *HostStatus) IsSetMode() bool {
	return v != nil && v.Mode != nil
}

type Hosts struct {
	HostNames map[string]struct{} `json:"hostNames,omitempty"`
}

// ToWire translates a Hosts struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Hosts) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.HostNames != nil {
		w, err = wire.NewValueSet(_Set_String_mapType_ValueList(v.HostNames)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Hosts struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Hosts struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Hosts
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Hosts) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TSet {
				v.HostNames, err = _Set_String_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Hosts
// struct.
func (v *Hosts) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.HostNames != nil {
		fields[i] = fmt.Sprintf("HostNames: %v", v.HostNames)
		i++
	}

	return fmt.Sprintf("Hosts{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Hosts match the
// provided Hosts.
//
// This function performs a deep comparison.
func (v *Hosts) Equals(rhs *Hosts) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.HostNames == nil && rhs.HostNames == nil) || (v.HostNames != nil && rhs.HostNames != nil && _Set_String_mapType_Equals(v.HostNames, rhs.HostNames))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Hosts.
func (v *Hosts) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.HostNames != nil {
		err = multierr.Append(err, enc.AddArray("hostNames", (_Set_String_mapType_Zapper)(v.HostNames)))
	}
	return err
}

// GetHostNames returns the value of HostNames if it is set or its
// zero value if it is unset.
func (v *Hosts) GetHostNames() (o map[string]struct{}) {
	if v != nil && v.HostNames != nil {
		return v.HostNames
	}

	return
}

// IsSetHostNames returns true if HostNames is not nil.
func (v *Hosts) IsSetHostNames() bool {
	return v != nil && v.HostNames != nil
}

type Identity struct {
	User *string `json:"user,omitempty"`
}

// ToWire translates a Identity struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Identity) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.User != nil {
		w, err = wire.NewValueString(*(v.User)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Identity struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Identity struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Identity
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Identity) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.User = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Identity
// struct.
func (v *Identity) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.User != nil {
		fields[i] = fmt.Sprintf("User: %v", *(v.User))
		i++
	}

	return fmt.Sprintf("Identity{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Identity match the
// provided Identity.
//
// This function performs a deep comparison.
func (v *Identity) Equals(rhs *Identity) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.User, rhs.User) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Identity.
func (v *Identity) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.User != nil {
		enc.AddString("user", *v.User)
	}
	return err
}

// GetUser returns the value of User if it is set or its
// zero value if it is unset.
func (v *Identity) GetUser() (o string) {
	if v != nil && v.User != nil {
		return *v.User
	}

	return
}

// IsSetUser returns true if User is not nil.
func (v *Identity) IsSetUser() bool {
	return v != nil && v.User != nil
}

// Describes an image to be used with the Mesos unified containerizer
type Image struct {
	Docker *DockerImage `json:"docker,omitempty"`
	Appc   *AppcImage   `json:"appc,omitempty"`
}

// ToWire translates a Image struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Image) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Docker != nil {
		w, err = v.Docker.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Appc != nil {
		w, err = v.Appc.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Image should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _DockerImage_Read(w wire.Value) (*DockerImage, error) {
	var v DockerImage
	err := v.FromWire(w)
	return &v, err
}

func _AppcImage_Read(w wire.Value) (*AppcImage, error) {
	var v AppcImage
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Image struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Image struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Image
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Image) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Docker, err = _DockerImage_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Appc, err = _AppcImage_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Docker != nil {
		count++
	}
	if v.Appc != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Image should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Image
// struct.
func (v *Image) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Docker != nil {
		fields[i] = fmt.Sprintf("Docker: %v", v.Docker)
		i++
	}
	if v.Appc != nil {
		fields[i] = fmt.Sprintf("Appc: %v", v.Appc)
		i++
	}

	return fmt.Sprintf("Image{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Image match the
// provided Image.
//
// This function performs a deep comparison.
func (v *Image) Equals(rhs *Image) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Docker == nil && rhs.Docker == nil) || (v.Docker != nil && rhs.Docker != nil && v.Docker.Equals(rhs.Docker))) {
		return false
	}
	if !((v.Appc == nil && rhs.Appc == nil) || (v.Appc != nil && rhs.Appc != nil && v.Appc.Equals(rhs.Appc))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Image.
func (v *Image) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Docker != nil {
		err = multierr.Append(err, enc.AddObject("docker", v.Docker))
	}
	if v.Appc != nil {
		err = multierr.Append(err, enc.AddObject("appc", v.Appc))
	}
	return err
}

// GetDocker returns the value of Docker if it is set or its
// zero value if it is unset.
func (v *Image) GetDocker() (o *DockerImage) {
	if v != nil && v.Docker != nil {
		return v.Docker
	}

	return
}

// IsSetDocker returns true if Docker is not nil.
func (v *Image) IsSetDocker() bool {
	return v != nil && v.Docker != nil
}

// GetAppc returns the value of Appc if it is set or its
// zero value if it is unset.
func (v *Image) GetAppc() (o *AppcImage) {
	if v != nil && v.Appc != nil {
		return v.Appc
	}

	return
}

// IsSetAppc returns true if Appc is not nil.
func (v *Image) IsSetAppc() bool {
	return v != nil && v.Appc != nil
}

// A unique identifier for the active task within a job.
type InstanceKey struct {
	// Key identifying the job.
	JobKey *JobKey `json:"jobKey,omitempty"`
	// Unique instance ID for the active task in a job.
	InstanceId *int32 `json:"instanceId,omitempty"`
}

// ToWire translates a InstanceKey struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *InstanceKey) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.JobKey != nil {
		w, err = v.JobKey.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.InstanceId != nil {
		w, err = wire.NewValueI32(*(v.InstanceId)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a InstanceKey struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a InstanceKey struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v InstanceKey
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *InstanceKey) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.JobKey, err = _JobKey_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.InstanceId = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a InstanceKey
// struct.
func (v *InstanceKey) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.JobKey != nil {
		fields[i] = fmt.Sprintf("JobKey: %v", v.JobKey)
		i++
	}
	if v.InstanceId != nil {
		fields[i] = fmt.Sprintf("InstanceId: %v", *(v.InstanceId))
		i++
	}

	return fmt.Sprintf("InstanceKey{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this InstanceKey match the
// provided InstanceKey.
//
// This function performs a deep comparison.
func (v *InstanceKey) Equals(rhs *InstanceKey) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.JobKey == nil && rhs.JobKey == nil) || (v.JobKey != nil && rhs.JobKey != nil && v.JobKey.Equals(rhs.JobKey))) {
		return false
	}
	if !_I32_EqualsPtr(v.InstanceId, rhs.InstanceId) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of InstanceKey.
func (v *InstanceKey) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.JobKey != nil {
		err = multierr.Append(err, enc.AddObject("jobKey", v.JobKey))
	}
	if v.InstanceId != nil {
		enc.AddInt32("instanceId", *v.InstanceId)
	}
	return err
}

// GetJobKey returns the value of JobKey if it is set or its
// zero value if it is unset.
func (v *InstanceKey) GetJobKey() (o *JobKey) {
	if v != nil && v.JobKey != nil {
		return v.JobKey
	}

	return
}

// IsSetJobKey returns true if JobKey is not nil.
func (v *InstanceKey) IsSetJobKey() bool {
	return v != nil && v.JobKey != nil
}

// GetInstanceId returns the value of InstanceId if it is set or its
// zero value if it is unset.
func (v *InstanceKey) GetInstanceId() (o int32) {
	if v != nil && v.InstanceId != nil {
		return *v.InstanceId
	}

	return
}

// IsSetInstanceId returns true if InstanceId is not nil.
func (v *InstanceKey) IsSetInstanceId() bool {
	return v != nil && v.InstanceId != nil
}

// Maps instance IDs to TaskConfigs it.
type InstanceTaskConfig struct {
	// A TaskConfig associated with instances.
	Task *TaskConfig `json:"task,omitempty"`
	// Instances associated with the TaskConfig.
	Instances []*Range `json:"instances,omitempty"`
}

// ToWire translates a InstanceTaskConfig struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *InstanceTaskConfig) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Task != nil {
		w, err = v.Task.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Instances != nil {
		w, err = wire.NewValueSet(_Set_Range_sliceType_ValueList(v.Instances)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a InstanceTaskConfig struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a InstanceTaskConfig struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v InstanceTaskConfig
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *InstanceTaskConfig) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Task, err = _TaskConfig_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TSet {
				v.Instances, err = _Set_Range_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a InstanceTaskConfig
// struct.
func (v *InstanceTaskConfig) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Task != nil {
		fields[i] = fmt.Sprintf("Task: %v", v.Task)
		i++
	}
	if v.Instances != nil {
		fields[i] = fmt.Sprintf("Instances: %v", v.Instances)
		i++
	}

	return fmt.Sprintf("InstanceTaskConfig{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this InstanceTaskConfig match the
// provided InstanceTaskConfig.
//
// This function performs a deep comparison.
func (v *InstanceTaskConfig) Equals(rhs *InstanceTaskConfig) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Task == nil && rhs.Task == nil) || (v.Task != nil && rhs.Task != nil && v.Task.Equals(rhs.Task))) {
		return false
	}
	if !((v.Instances == nil && rhs.Instances == nil) || (v.Instances != nil && rhs.Instances != nil && _Set_Range_sliceType_Equals(v.Instances, rhs.Instances))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of InstanceTaskConfig.
func (v *InstanceTaskConfig) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Task != nil {
		err = multierr.Append(err, enc.AddObject("task", v.Task))
	}
	if v.Instances != nil {
		err = multierr.Append(err, enc.AddArray("instances", (_Set_Range_sliceType_Zapper)(v.Instances)))
	}
	return err
}

// GetTask returns the value of Task if it is set or its
// zero value if it is unset.
func (v *InstanceTaskConfig) GetTask() (o *TaskConfig) {
	if v != nil && v.Task != nil {
		return v.Task
	}

	return
}

// IsSetTask returns true if Task is not nil.
func (v *InstanceTaskConfig) IsSetTask() bool {
	return v != nil && v.Task != nil
}

// GetInstances returns the value of Instances if it is set or its
// zero value if it is unset.
func (v *InstanceTaskConfig) GetInstances() (o []*Range) {
	if v != nil && v.Instances != nil {
		return v.Instances
	}

	return
}

// IsSetInstances returns true if Instances is not nil.
func (v *InstanceTaskConfig) IsSetInstances() bool {
	return v != nil && v.Instances != nil
}

// Description of an Aurora job. One task will be scheduled for each instance within the job.
type JobConfiguration struct {
	// Key for this job. If not specified name, owner.role, and a reasonable default environment are
	// used to construct it server-side.
	Key *JobKey `json:"key,omitempty"`
	// Owner of this job.
	Owner *Identity `json:"owner,omitempty"`
	// If present, the job will be handled as a cron job with this crontab-syntax schedule.
	CronSchedule *string `json:"cronSchedule,omitempty"`
	// Collision policy to use when handling overlapping cron runs.  Default is KILL_EXISTING.
	CronCollisionPolicy *CronCollisionPolicy `json:"cronCollisionPolicy,omitempty"`
	// Task configuration for this job.
	TaskConfig *TaskConfig `json:"taskConfig,omitempty"`
	// The number of instances in the job. Generated instance IDs for tasks will be in the range
	// [0, instances).
	InstanceCount *int32 `json:"instanceCount,omitempty"`
}

// ToWire translates a JobConfiguration struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *JobConfiguration) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Key != nil {
		w, err = v.Key.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 9, Value: w}
		i++
	}
	if v.Owner != nil {
		w, err = v.Owner.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}
	if v.CronSchedule != nil {
		w, err = wire.NewValueString(*(v.CronSchedule)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.CronCollisionPolicy != nil {
		w, err = v.CronCollisionPolicy.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.TaskConfig != nil {
		w, err = v.TaskConfig.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	if v.InstanceCount != nil {
		w, err = wire.NewValueI32(*(v.InstanceCount)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 8, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Identity_Read(w wire.Value) (*Identity, error) {
	var v Identity
	err := v.FromWire(w)
	return &v, err
}

func _CronCollisionPolicy_Read(w wire.Value) (CronCollisionPolicy, error) {
	var v CronCollisionPolicy
	err := v.FromWire(w)
	return v, err
}

// FromWire deserializes a JobConfiguration struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a JobConfiguration struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v JobConfiguration
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *JobConfiguration) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 9:
			if field.Value.Type() == wire.TStruct {
				v.Key, err = _JobKey_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 7:
			if field.Value.Type() == wire.TStruct {
				v.Owner, err = _Identity_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.CronSchedule = &x
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TI32 {
				var x CronCollisionPolicy
				x, err = _CronCollisionPolicy_Read(field.Value)
				v.CronCollisionPolicy = &x
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TStruct {
				v.TaskConfig, err = _TaskConfig_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 8:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.InstanceCount = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a JobConfiguration
// struct.
func (v *JobConfiguration) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	if v.Key != nil {
		fields[i] = fmt.Sprintf("Key: %v", v.Key)
		i++
	}
	if v.Owner != nil {
		fields[i] = fmt.Sprintf("Owner: %v", v.Owner)
		i++
	}
	if v.CronSchedule != nil {
		fields[i] = fmt.Sprintf("CronSchedule: %v", *(v.CronSchedule))
		i++
	}
	if v.CronCollisionPolicy != nil {
		fields[i] = fmt.Sprintf("CronCollisionPolicy: %v", *(v.CronCollisionPolicy))
		i++
	}
	if v.TaskConfig != nil {
		fields[i] = fmt.Sprintf("TaskConfig: %v", v.TaskConfig)
		i++
	}
	if v.InstanceCount != nil {
		fields[i] = fmt.Sprintf("InstanceCount: %v", *(v.InstanceCount))
		i++
	}

	return fmt.Sprintf("JobConfiguration{%v}", strings.Join(fields[:i], ", "))
}

func _CronCollisionPolicy_EqualsPtr(lhs, rhs *CronCollisionPolicy) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this JobConfiguration match the
// provided JobConfiguration.
//
// This function performs a deep comparison.
func (v *JobConfiguration) Equals(rhs *JobConfiguration) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Key == nil && rhs.Key == nil) || (v.Key != nil && rhs.Key != nil && v.Key.Equals(rhs.Key))) {
		return false
	}
	if !((v.Owner == nil && rhs.Owner == nil) || (v.Owner != nil && rhs.Owner != nil && v.Owner.Equals(rhs.Owner))) {
		return false
	}
	if !_String_EqualsPtr(v.CronSchedule, rhs.CronSchedule) {
		return false
	}
	if !_CronCollisionPolicy_EqualsPtr(v.CronCollisionPolicy, rhs.CronCollisionPolicy) {
		return false
	}
	if !((v.TaskConfig == nil && rhs.TaskConfig == nil) || (v.TaskConfig != nil && rhs.TaskConfig != nil && v.TaskConfig.Equals(rhs.TaskConfig))) {
		return false
	}
	if !_I32_EqualsPtr(v.InstanceCount, rhs.InstanceCount) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of JobConfiguration.
func (v *JobConfiguration) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Key != nil {
		err = multierr.Append(err, enc.AddObject("key", v.Key))
	}
	if v.Owner != nil {
		err = multierr.Append(err, enc.AddObject("owner", v.Owner))
	}
	if v.CronSchedule != nil {
		enc.AddString("cronSchedule", *v.CronSchedule)
	}
	if v.CronCollisionPolicy != nil {
		err = multierr.Append(err, enc.AddObject("cronCollisionPolicy", *v.CronCollisionPolicy))
	}
	if v.TaskConfig != nil {
		err = multierr.Append(err, enc.AddObject("taskConfig", v.TaskConfig))
	}
	if v.InstanceCount != nil {
		enc.AddInt32("instanceCount", *v.InstanceCount)
	}
	return err
}

// GetKey returns the value of Key if it is set or its
// zero value if it is unset.
func (v *JobConfiguration) GetKey() (o *JobKey) {
	if v != nil && v.Key != nil {
		return v.Key
	}

	return
}

// IsSetKey returns true if Key is not nil.
func (v *JobConfiguration) IsSetKey() bool {
	return v != nil && v.Key != nil
}

// GetOwner returns the value of Owner if it is set or its
// zero value if it is unset.
func (v *JobConfiguration) GetOwner() (o *Identity) {
	if v != nil && v.Owner != nil {
		return v.Owner
	}

	return
}

// IsSetOwner returns true if Owner is not nil.
func (v *JobConfiguration) IsSetOwner() bool {
	return v != nil && v.Owner != nil
}

// GetCronSchedule returns the value of CronSchedule if it is set or its
// zero value if it is unset.
func (v *JobConfiguration) GetCronSchedule() (o string) {
	if v != nil && v.CronSchedule != nil {
		return *v.CronSchedule
	}

	return
}

// IsSetCronSchedule returns true if CronSchedule is not nil.
func (v *JobConfiguration) IsSetCronSchedule() bool {
	return v != nil && v.CronSchedule != nil
}

// GetCronCollisionPolicy returns the value of CronCollisionPolicy if it is set or its
// zero value if it is unset.
func (v *JobConfiguration) GetCronCollisionPolicy() (o CronCollisionPolicy) {
	if v != nil && v.CronCollisionPolicy != nil {
		return *v.CronCollisionPolicy
	}

	return
}

// IsSetCronCollisionPolicy returns true if CronCollisionPolicy is not nil.
func (v *JobConfiguration) IsSetCronCollisionPolicy() bool {
	return v != nil && v.CronCollisionPolicy != nil
}

// GetTaskConfig returns the value of TaskConfig if it is set or its
// zero value if it is unset.
func (v *JobConfiguration) GetTaskConfig() (o *TaskConfig) {
	if v != nil && v.TaskConfig != nil {
		return v.TaskConfig
	}

	return
}

// IsSetTaskConfig returns true if TaskConfig is not nil.
func (v *JobConfiguration) IsSetTaskConfig() bool {
	return v != nil && v.TaskConfig != nil
}

// GetInstanceCount returns the value of InstanceCount if it is set or its
// zero value if it is unset.
func (v *JobConfiguration) GetInstanceCount() (o int32) {
	if v != nil && v.InstanceCount != nil {
		return *v.InstanceCount
	}

	return
}

// IsSetInstanceCount returns true if InstanceCount is not nil.
func (v *JobConfiguration) IsSetInstanceCount() bool {
	return v != nil && v.InstanceCount != nil
}

// Event marking a state transition in job instance update lifecycle.
type JobInstanceUpdateEvent struct {
	// Job instance ID.
	InstanceId *int32 `json:"instanceId,omitempty"`
	// Epoch timestamp in milliseconds.
	TimestampMs *int64 `json:"timestampMs,omitempty"`
	// Job update action taken on the instance.
	Action *JobUpdateAction `json:"action,omitempty"`
}

// ToWire translates a JobInstanceUpdateEvent struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *JobInstanceUpdateEvent) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.InstanceId != nil {
		w, err = wire.NewValueI32(*(v.InstanceId)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.TimestampMs != nil {
		w, err = wire.NewValueI64(*(v.TimestampMs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Action != nil {
		w, err = v.Action.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _JobUpdateAction_Read(w wire.Value) (JobUpdateAction, error) {
	var v JobUpdateAction
	err := v.FromWire(w)
	return v, err
}

// FromWire deserializes a JobInstanceUpdateEvent struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a JobInstanceUpdateEvent struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v JobInstanceUpdateEvent
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *JobInstanceUpdateEvent) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.InstanceId = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.TimestampMs = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x JobUpdateAction
				x, err = _JobUpdateAction_Read(field.Value)
				v.Action = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a JobInstanceUpdateEvent
// struct.
func (v *JobInstanceUpdateEvent) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.InstanceId != nil {
		fields[i] = fmt.Sprintf("InstanceId: %v", *(v.InstanceId))
		i++
	}
	if v.TimestampMs != nil {
		fields[i] = fmt.Sprintf("TimestampMs: %v", *(v.TimestampMs))
		i++
	}
	if v.Action != nil {
		fields[i] = fmt.Sprintf("Action: %v", *(v.Action))
		i++
	}

	return fmt.Sprintf("JobInstanceUpdateEvent{%v}", strings.Join(fields[:i], ", "))
}

func _I64_EqualsPtr(lhs, rhs *int64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _JobUpdateAction_EqualsPtr(lhs, rhs *JobUpdateAction) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this JobInstanceUpdateEvent match the
// provided JobInstanceUpdateEvent.
//
// This function performs a deep comparison.
func (v *JobInstanceUpdateEvent) Equals(rhs *JobInstanceUpdateEvent) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.InstanceId, rhs.InstanceId) {
		return false
	}
	if !_I64_EqualsPtr(v.TimestampMs, rhs.TimestampMs) {
		return false
	}
	if !_JobUpdateAction_EqualsPtr(v.Action, rhs.Action) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of JobInstanceUpdateEvent.
func (v *JobInstanceUpdateEvent) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.InstanceId != nil {
		enc.AddInt32("instanceId", *v.InstanceId)
	}
	if v.TimestampMs != nil {
		enc.AddInt64("timestampMs", *v.TimestampMs)
	}
	if v.Action != nil {
		err = multierr.Append(err, enc.AddObject("action", *v.Action))
	}
	return err
}

// GetInstanceId returns the value of InstanceId if it is set or its
// zero value if it is unset.
func (v *JobInstanceUpdateEvent) GetInstanceId() (o int32) {
	if v != nil && v.InstanceId != nil {
		return *v.InstanceId
	}

	return
}

// IsSetInstanceId returns true if InstanceId is not nil.
func (v *JobInstanceUpdateEvent) IsSetInstanceId() bool {
	return v != nil && v.InstanceId != nil
}

// GetTimestampMs returns the value of TimestampMs if it is set or its
// zero value if it is unset.
func (v *JobInstanceUpdateEvent) GetTimestampMs() (o int64) {
	if v != nil && v.TimestampMs != nil {
		return *v.TimestampMs
	}

	return
}

// IsSetTimestampMs returns true if TimestampMs is not nil.
func (v *JobInstanceUpdateEvent) IsSetTimestampMs() bool {
	return v != nil && v.TimestampMs != nil
}

// GetAction returns the value of Action if it is set or its
// zero value if it is unset.
func (v *JobInstanceUpdateEvent) GetAction() (o JobUpdateAction) {
	if v != nil && v.Action != nil {
		return *v.Action
	}

	return
}

// IsSetAction returns true if Action is not nil.
func (v *JobInstanceUpdateEvent) IsSetAction() bool {
	return v != nil && v.Action != nil
}

// A unique identifier for a Job.
type JobKey struct {
	// User role (Unix service account), for example "mesos"
	Role *string `json:"role,omitempty"`
	// Environment, for example "devel"
	Environment *string `json:"environment,omitempty"`
	// Name, for example "labrat"
	Name *string `json:"name,omitempty"`
}

// ToWire translates a JobKey struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *JobKey) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Role != nil {
		w, err = wire.NewValueString(*(v.Role)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Environment != nil {
		w, err = wire.NewValueString(*(v.Environment)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a JobKey struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a JobKey struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v JobKey
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *JobKey) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Role = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Environment = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a JobKey
// struct.
func (v *JobKey) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Role != nil {
		fields[i] = fmt.Sprintf("Role: %v", *(v.Role))
		i++
	}
	if v.Environment != nil {
		fields[i] = fmt.Sprintf("Environment: %v", *(v.Environment))
		i++
	}
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}

	return fmt.Sprintf("JobKey{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this JobKey match the
// provided JobKey.
//
// This function performs a deep comparison.
func (v *JobKey) Equals(rhs *JobKey) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Role, rhs.Role) {
		return false
	}
	if !_String_EqualsPtr(v.Environment, rhs.Environment) {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of JobKey.
func (v *JobKey) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Role != nil {
		enc.AddString("role", *v.Role)
	}
	if v.Environment != nil {
		enc.AddString("environment", *v.Environment)
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	return err
}

// GetRole returns the value of Role if it is set or its
// zero value if it is unset.
func (v *JobKey) GetRole() (o string) {
	if v != nil && v.Role != nil {
		return *v.Role
	}

	return
}

// IsSetRole returns true if Role is not nil.
func (v *JobKey) IsSetRole() bool {
	return v != nil && v.Role != nil
}

// GetEnvironment returns the value of Environment if it is set or its
// zero value if it is unset.
func (v *JobKey) GetEnvironment() (o string) {
	if v != nil && v.Environment != nil {
		return *v.Environment
	}

	return
}

// IsSetEnvironment returns true if Environment is not nil.
func (v *JobKey) IsSetEnvironment() bool {
	return v != nil && v.Environment != nil
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *JobKey) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *JobKey) IsSetName() bool {
	return v != nil && v.Name != nil
}

type JobStats struct {
	// Number of tasks in active state for this job.
	ActiveTaskCount *int32 `json:"activeTaskCount,omitempty"`
	// Number of tasks in finished state for this job.
	FinishedTaskCount *int32 `json:"finishedTaskCount,omitempty"`
	// Number of failed tasks for this job.
	FailedTaskCount *int32 `json:"failedTaskCount,omitempty"`
	// Number of tasks in pending state for this job.
	PendingTaskCount *int32 `json:"pendingTaskCount,omitempty"`
}

// ToWire translates a JobStats struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *JobStats) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ActiveTaskCount != nil {
		w, err = wire.NewValueI32(*(v.ActiveTaskCount)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.FinishedTaskCount != nil {
		w, err = wire.NewValueI32(*(v.FinishedTaskCount)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.FailedTaskCount != nil {
		w, err = wire.NewValueI32(*(v.FailedTaskCount)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.PendingTaskCount != nil {
		w, err = wire.NewValueI32(*(v.PendingTaskCount)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a JobStats struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a JobStats struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v JobStats
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *JobStats) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ActiveTaskCount = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.FinishedTaskCount = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.FailedTaskCount = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.PendingTaskCount = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a JobStats
// struct.
func (v *JobStats) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.ActiveTaskCount != nil {
		fields[i] = fmt.Sprintf("ActiveTaskCount: %v", *(v.ActiveTaskCount))
		i++
	}
	if v.FinishedTaskCount != nil {
		fields[i] = fmt.Sprintf("FinishedTaskCount: %v", *(v.FinishedTaskCount))
		i++
	}
	if v.FailedTaskCount != nil {
		fields[i] = fmt.Sprintf("FailedTaskCount: %v", *(v.FailedTaskCount))
		i++
	}
	if v.PendingTaskCount != nil {
		fields[i] = fmt.Sprintf("PendingTaskCount: %v", *(v.PendingTaskCount))
		i++
	}

	return fmt.Sprintf("JobStats{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this JobStats match the
// provided JobStats.
//
// This function performs a deep comparison.
func (v *JobStats) Equals(rhs *JobStats) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.ActiveTaskCount, rhs.ActiveTaskCount) {
		return false
	}
	if !_I32_EqualsPtr(v.FinishedTaskCount, rhs.FinishedTaskCount) {
		return false
	}
	if !_I32_EqualsPtr(v.FailedTaskCount, rhs.FailedTaskCount) {
		return false
	}
	if !_I32_EqualsPtr(v.PendingTaskCount, rhs.PendingTaskCount) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of JobStats.
func (v *JobStats) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ActiveTaskCount != nil {
		enc.AddInt32("activeTaskCount", *v.ActiveTaskCount)
	}
	if v.FinishedTaskCount != nil {
		enc.AddInt32("finishedTaskCount", *v.FinishedTaskCount)
	}
	if v.FailedTaskCount != nil {
		enc.AddInt32("failedTaskCount", *v.FailedTaskCount)
	}
	if v.PendingTaskCount != nil {
		enc.AddInt32("pendingTaskCount", *v.PendingTaskCount)
	}
	return err
}

// GetActiveTaskCount returns the value of ActiveTaskCount if it is set or its
// zero value if it is unset.
func (v *JobStats) GetActiveTaskCount() (o int32) {
	if v != nil && v.ActiveTaskCount != nil {
		return *v.ActiveTaskCount
	}

	return
}

// IsSetActiveTaskCount returns true if ActiveTaskCount is not nil.
func (v *JobStats) IsSetActiveTaskCount() bool {
	return v != nil && v.ActiveTaskCount != nil
}

// GetFinishedTaskCount returns the value of FinishedTaskCount if it is set or its
// zero value if it is unset.
func (v *JobStats) GetFinishedTaskCount() (o int32) {
	if v != nil && v.FinishedTaskCount != nil {
		return *v.FinishedTaskCount
	}

	return
}

// IsSetFinishedTaskCount returns true if FinishedTaskCount is not nil.
func (v *JobStats) IsSetFinishedTaskCount() bool {
	return v != nil && v.FinishedTaskCount != nil
}

// GetFailedTaskCount returns the value of FailedTaskCount if it is set or its
// zero value if it is unset.
func (v *JobStats) GetFailedTaskCount() (o int32) {
	if v != nil && v.FailedTaskCount != nil {
		return *v.FailedTaskCount
	}

	return
}

// IsSetFailedTaskCount returns true if FailedTaskCount is not nil.
func (v *JobStats) IsSetFailedTaskCount() bool {
	return v != nil && v.FailedTaskCount != nil
}

// GetPendingTaskCount returns the value of PendingTaskCount if it is set or its
// zero value if it is unset.
func (v *JobStats) GetPendingTaskCount() (o int32) {
	if v != nil && v.PendingTaskCount != nil {
		return *v.PendingTaskCount
	}

	return
}

// IsSetPendingTaskCount returns true if PendingTaskCount is not nil.
func (v *JobStats) IsSetPendingTaskCount() bool {
	return v != nil && v.PendingTaskCount != nil
}

type JobSummary struct {
	Job   *JobConfiguration `json:"job,omitempty"`
	Stats *JobStats         `json:"stats,omitempty"`
	// Timestamp of next cron run in ms since epoch, for a cron job
	NextCronRunMs *int64 `json:"nextCronRunMs,omitempty"`
}

// ToWire translates a JobSummary struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *JobSummary) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Job != nil {
		w, err = v.Job.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Stats != nil {
		w, err = v.Stats.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.NextCronRunMs != nil {
		w, err = wire.NewValueI64(*(v.NextCronRunMs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _JobStats_Read(w wire.Value) (*JobStats, error) {
	var v JobStats
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a JobSummary struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a JobSummary struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v JobSummary
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *JobSummary) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Job, err = _JobConfiguration_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Stats, err = _JobStats_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.NextCronRunMs = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a JobSummary
// struct.
func (v *JobSummary) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Job != nil {
		fields[i] = fmt.Sprintf("Job: %v", v.Job)
		i++
	}
	if v.Stats != nil {
		fields[i] = fmt.Sprintf("Stats: %v", v.Stats)
		i++
	}
	if v.NextCronRunMs != nil {
		fields[i] = fmt.Sprintf("NextCronRunMs: %v", *(v.NextCronRunMs))
		i++
	}

	return fmt.Sprintf("JobSummary{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this JobSummary match the
// provided JobSummary.
//
// This function performs a deep comparison.
func (v *JobSummary) Equals(rhs *JobSummary) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Job == nil && rhs.Job == nil) || (v.Job != nil && rhs.Job != nil && v.Job.Equals(rhs.Job))) {
		return false
	}
	if !((v.Stats == nil && rhs.Stats == nil) || (v.Stats != nil && rhs.Stats != nil && v.Stats.Equals(rhs.Stats))) {
		return false
	}
	if !_I64_EqualsPtr(v.NextCronRunMs, rhs.NextCronRunMs) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of JobSummary.
func (v *JobSummary) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Job != nil {
		err = multierr.Append(err, enc.AddObject("job", v.Job))
	}
	if v.Stats != nil {
		err = multierr.Append(err, enc.AddObject("stats", v.Stats))
	}
	if v.NextCronRunMs != nil {
		enc.AddInt64("nextCronRunMs", *v.NextCronRunMs)
	}
	return err
}

// GetJob returns the value of Job if it is set or its
// zero value if it is unset.
func (v *JobSummary) GetJob() (o *JobConfiguration) {
	if v != nil && v.Job != nil {
		return v.Job
	}

	return
}

// IsSetJob returns true if Job is not nil.
func (v *JobSummary) IsSetJob() bool {
	return v != nil && v.Job != nil
}

// GetStats returns the value of Stats if it is set or its
// zero value if it is unset.
func (v *JobSummary) GetStats() (o *JobStats) {
	if v != nil && v.Stats != nil {
		return v.Stats
	}

	return
}

// IsSetStats returns true if Stats is not nil.
func (v *JobSummary) IsSetStats() bool {
	return v != nil && v.Stats != nil
}

// GetNextCronRunMs returns the value of NextCronRunMs if it is set or its
// zero value if it is unset.
func (v *JobSummary) GetNextCronRunMs() (o int64) {
	if v != nil && v.NextCronRunMs != nil {
		return *v.NextCronRunMs
	}

	return
}

// IsSetNextCronRunMs returns true if NextCronRunMs is not nil.
func (v *JobSummary) IsSetNextCronRunMs() bool {
	return v != nil && v.NextCronRunMs != nil
}

type JobSummaryResult struct {
	Summaries []*JobSummary `json:"summaries,omitempty"`
}

type _Set_JobSummary_sliceType_ValueList []*JobSummary

func (v _Set_JobSummary_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_JobSummary_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_JobSummary_sliceType_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_JobSummary_sliceType_ValueList) Close() {}

// ToWire translates a JobSummaryResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *JobSummaryResult) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Summaries != nil {
		w, err = wire.NewValueSet(_Set_JobSummary_sliceType_ValueList(v.Summaries)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _JobSummary_Read(w wire.Value) (*JobSummary, error) {
	var v JobSummary
	err := v.FromWire(w)
	return &v, err
}

func _Set_JobSummary_sliceType_Read(s wire.ValueList) ([]*JobSummary, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*JobSummary, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _JobSummary_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

// FromWire deserializes a JobSummaryResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a JobSummaryResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v JobSummaryResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *JobSummaryResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TSet {
				v.Summaries, err = _Set_JobSummary_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a JobSummaryResult
// struct.
func (v *JobSummaryResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Summaries != nil {
		fields[i] = fmt.Sprintf("Summaries: %v", v.Summaries)
		i++
	}

	return fmt.Sprintf("JobSummaryResult{%v}", strings.Join(fields[:i], ", "))
}

func _Set_JobSummary_sliceType_Equals(lhs, rhs []*JobSummary) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this JobSummaryResult match the
// provided JobSummaryResult.
//
// This function performs a deep comparison.
func (v *JobSummaryResult) Equals(rhs *JobSummaryResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Summaries == nil && rhs.Summaries == nil) || (v.Summaries != nil && rhs.Summaries != nil && _Set_JobSummary_sliceType_Equals(v.Summaries, rhs.Summaries))) {
		return false
	}

	return true
}

type _Set_JobSummary_sliceType_Zapper []*JobSummary

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_JobSummary_sliceType_Zapper.
func (s _Set_JobSummary_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of JobSummaryResult.
func (v *JobSummaryResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Summaries != nil {
		err = multierr.Append(err, enc.AddArray("summaries", (_Set_JobSummary_sliceType_Zapper)(v.Summaries)))
	}
	return err
}

// GetSummaries returns the value of Summaries if it is set or its
// zero value if it is unset.
func (v *JobSummaryResult) GetSummaries() (o []*JobSummary) {
	if v != nil && v.Summaries != nil {
		return v.Summaries
	}

	return
}

// IsSetSummaries returns true if Summaries is not nil.
func (v *JobSummaryResult) IsSetSummaries() bool {
	return v != nil && v.Summaries != nil
}

// Full definition of the job update.
type JobUpdate struct {
	// Update summary.
	Summary *JobUpdateSummary `json:"summary,omitempty"`
	// Update configuration.
	Instructions *JobUpdateInstructions `json:"instructions,omitempty"`
}

// ToWire translates a JobUpdate struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *JobUpdate) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Summary != nil {
		w, err = v.Summary.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Instructions != nil {
		w, err = v.Instructions.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _JobUpdateInstructions_Read(w wire.Value) (*JobUpdateInstructions, error) {
	var v JobUpdateInstructions
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a JobUpdate struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a JobUpdate struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v JobUpdate
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *JobUpdate) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Summary, err = _JobUpdateSummary_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Instructions, err = _JobUpdateInstructions_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a JobUpdate
// struct.
func (v *JobUpdate) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Summary != nil {
		fields[i] = fmt.Sprintf("Summary: %v", v.Summary)
		i++
	}
	if v.Instructions != nil {
		fields[i] = fmt.Sprintf("Instructions: %v", v.Instructions)
		i++
	}

	return fmt.Sprintf("JobUpdate{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this JobUpdate match the
// provided JobUpdate.
//
// This function performs a deep comparison.
func (v *JobUpdate) Equals(rhs *JobUpdate) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Summary == nil && rhs.Summary == nil) || (v.Summary != nil && rhs.Summary != nil && v.Summary.Equals(rhs.Summary))) {
		return false
	}
	if !((v.Instructions == nil && rhs.Instructions == nil) || (v.Instructions != nil && rhs.Instructions != nil && v.Instructions.Equals(rhs.Instructions))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of JobUpdate.
func (v *JobUpdate) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Summary != nil {
		err = multierr.Append(err, enc.AddObject("summary", v.Summary))
	}
	if v.Instructions != nil {
		err = multierr.Append(err, enc.AddObject("instructions", v.Instructions))
	}
	return err
}

// GetSummary returns the value of Summary if it is set or its
// zero value if it is unset.
func (v *JobUpdate) GetSummary() (o *JobUpdateSummary) {
	if v != nil && v.Summary != nil {
		return v.Summary
	}

	return
}

// IsSetSummary returns true if Summary is not nil.
func (v *JobUpdate) IsSetSummary() bool {
	return v != nil && v.Summary != nil
}

// GetInstructions returns the value of Instructions if it is set or its
// zero value if it is unset.
func (v *JobUpdate) GetInstructions() (o *JobUpdateInstructions) {
	if v != nil && v.Instructions != nil {
		return v.Instructions
	}

	return
}

// IsSetInstructions returns true if Instructions is not nil.
func (v *JobUpdate) IsSetInstructions() bool {
	return v != nil && v.Instructions != nil
}

// Job update actions that can be applied to job instances.
type JobUpdateAction int32

const (
	// An instance was moved to the target state successfully, and declared healthy if the desired
	// state did not involve deleting the instance.
	JobUpdateActionInstanceUpdated JobUpdateAction = 1
	// An instance was rolled back because the job update did not succeed.  The instance was reverted
	// to the original state prior to the job update, which means that the instance was removed if
	// the update added instances to the job.
	JobUpdateActionInstanceRolledBack JobUpdateAction = 2
	// An instance is being moved from the original state to the desired state.
	JobUpdateActionInstanceUpdating JobUpdateAction = 3
	// An instance is being moved from the desired state back to the original state, because the job
	// update failed.
	JobUpdateActionInstanceRollingBack JobUpdateAction = 4
	// An instance update was attempted but failed and was not rolled back.
	JobUpdateActionInstanceUpdateFailed JobUpdateAction = 5
	// An instance rollback was attempted but failed.
	JobUpdateActionInstanceRollbackFailed JobUpdateAction = 6
)

// JobUpdateAction_Values returns all recognized values of JobUpdateAction.
func JobUpdateAction_Values() []JobUpdateAction {
	return []JobUpdateAction{
		JobUpdateActionInstanceUpdated,
		JobUpdateActionInstanceRolledBack,
		JobUpdateActionInstanceUpdating,
		JobUpdateActionInstanceRollingBack,
		JobUpdateActionInstanceUpdateFailed,
		JobUpdateActionInstanceRollbackFailed,
	}
}

// UnmarshalText tries to decode JobUpdateAction from a byte slice
// containing its name.
//
//   var v JobUpdateAction
//   err := v.UnmarshalText([]byte("INSTANCE_UPDATED"))
func (v *JobUpdateAction) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "INSTANCE_UPDATED":
		*v = JobUpdateActionInstanceUpdated
		return nil
	case "INSTANCE_ROLLED_BACK":
		*v = JobUpdateActionInstanceRolledBack
		return nil
	case "INSTANCE_UPDATING":
		*v = JobUpdateActionInstanceUpdating
		return nil
	case "INSTANCE_ROLLING_BACK":
		*v = JobUpdateActionInstanceRollingBack
		return nil
	case "INSTANCE_UPDATE_FAILED":
		*v = JobUpdateActionInstanceUpdateFailed
		return nil
	case "INSTANCE_ROLLBACK_FAILED":
		*v = JobUpdateActionInstanceRollbackFailed
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "JobUpdateAction", err)
		}
		*v = JobUpdateAction(val)
		return nil
	}
}

// MarshalText encodes JobUpdateAction to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v JobUpdateAction) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 1:
		return []byte("INSTANCE_UPDATED"), nil
	case 2:
		return []byte("INSTANCE_ROLLED_BACK"), nil
	case 3:
		return []byte("INSTANCE_UPDATING"), nil
	case 4:
		return []byte("INSTANCE_ROLLING_BACK"), nil
	case 5:
		return []byte("INSTANCE_UPDATE_FAILED"), nil
	case 6:
		return []byte("INSTANCE_ROLLBACK_FAILED"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of JobUpdateAction.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v JobUpdateAction) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 1:
		enc.AddString("name", "INSTANCE_UPDATED")
	case 2:
		enc.AddString("name", "INSTANCE_ROLLED_BACK")
	case 3:
		enc.AddString("name", "INSTANCE_UPDATING")
	case 4:
		enc.AddString("name", "INSTANCE_ROLLING_BACK")
	case 5:
		enc.AddString("name", "INSTANCE_UPDATE_FAILED")
	case 6:
		enc.AddString("name", "INSTANCE_ROLLBACK_FAILED")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v JobUpdateAction) Ptr() *JobUpdateAction {
	return &v
}

// ToWire translates JobUpdateAction into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v JobUpdateAction) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes JobUpdateAction from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return JobUpdateAction(0), err
//   }
//
//   var v JobUpdateAction
//   if err := v.FromWire(x); err != nil {
//     return JobUpdateAction(0), err
//   }
//   return v, nil
func (v *JobUpdateAction) FromWire(w wire.Value) error {
	*v = (JobUpdateAction)(w.GetI32())
	return nil
}

// String returns a readable string representation of JobUpdateAction.
func (v JobUpdateAction) String() string {
	w := int32(v)
	switch w {
	case 1:
		return "INSTANCE_UPDATED"
	case 2:
		return "INSTANCE_ROLLED_BACK"
	case 3:
		return "INSTANCE_UPDATING"
	case 4:
		return "INSTANCE_ROLLING_BACK"
	case 5:
		return "INSTANCE_UPDATE_FAILED"
	case 6:
		return "INSTANCE_ROLLBACK_FAILED"
	}
	return fmt.Sprintf("JobUpdateAction(%d)", w)
}

// Equals returns true if this JobUpdateAction value matches the provided
// value.
func (v JobUpdateAction) Equals(rhs JobUpdateAction) bool {
	return v == rhs
}

// MarshalJSON serializes JobUpdateAction into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v JobUpdateAction) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 1:
		return ([]byte)("\"INSTANCE_UPDATED\""), nil
	case 2:
		return ([]byte)("\"INSTANCE_ROLLED_BACK\""), nil
	case 3:
		return ([]byte)("\"INSTANCE_UPDATING\""), nil
	case 4:
		return ([]byte)("\"INSTANCE_ROLLING_BACK\""), nil
	case 5:
		return ([]byte)("\"INSTANCE_UPDATE_FAILED\""), nil
	case 6:
		return ([]byte)("\"INSTANCE_ROLLBACK_FAILED\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode JobUpdateAction from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *JobUpdateAction) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "JobUpdateAction")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "JobUpdateAction")
		}
		*v = (JobUpdateAction)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "JobUpdateAction")
	}
}

type JobUpdateDetails struct {
	// Update definition.
	Update *JobUpdate `json:"update,omitempty"`
	// History for this update.
	UpdateEvents []*JobUpdateEvent `json:"updateEvents,omitempty"`
	// History for the individual instances updated.
	InstanceEvents []*JobInstanceUpdateEvent `json:"instanceEvents,omitempty"`
}

type _List_JobUpdateEvent_ValueList []*JobUpdateEvent

func (v _List_JobUpdateEvent_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_JobUpdateEvent_ValueList) Size() int {
	return len(v)
}

func (_List_JobUpdateEvent_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_JobUpdateEvent_ValueList) Close() {}

type _List_JobInstanceUpdateEvent_ValueList []*JobInstanceUpdateEvent

func (v _List_JobInstanceUpdateEvent_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_JobInstanceUpdateEvent_ValueList) Size() int {
	return len(v)
}

func (_List_JobInstanceUpdateEvent_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_JobInstanceUpdateEvent_ValueList) Close() {}

// ToWire translates a JobUpdateDetails struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *JobUpdateDetails) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Update != nil {
		w, err = v.Update.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.UpdateEvents != nil {
		w, err = wire.NewValueList(_List_JobUpdateEvent_ValueList(v.UpdateEvents)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.InstanceEvents != nil {
		w, err = wire.NewValueList(_List_JobInstanceUpdateEvent_ValueList(v.InstanceEvents)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _JobUpdate_Read(w wire.Value) (*JobUpdate, error) {
	var v JobUpdate
	err := v.FromWire(w)
	return &v, err
}

func _JobUpdateEvent_Read(w wire.Value) (*JobUpdateEvent, error) {
	var v JobUpdateEvent
	err := v.FromWire(w)
	return &v, err
}

func _List_JobUpdateEvent_Read(l wire.ValueList) ([]*JobUpdateEvent, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*JobUpdateEvent, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _JobUpdateEvent_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _JobInstanceUpdateEvent_Read(w wire.Value) (*JobInstanceUpdateEvent, error) {
	var v JobInstanceUpdateEvent
	err := v.FromWire(w)
	return &v, err
}

func _List_JobInstanceUpdateEvent_Read(l wire.ValueList) ([]*JobInstanceUpdateEvent, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*JobInstanceUpdateEvent, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _JobInstanceUpdateEvent_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a JobUpdateDetails struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a JobUpdateDetails struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v JobUpdateDetails
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *JobUpdateDetails) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Update, err = _JobUpdate_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TList {
				v.UpdateEvents, err = _List_JobUpdateEvent_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.InstanceEvents, err = _List_JobInstanceUpdateEvent_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a JobUpdateDetails
// struct.
func (v *JobUpdateDetails) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Update != nil {
		fields[i] = fmt.Sprintf("Update: %v", v.Update)
		i++
	}
	if v.UpdateEvents != nil {
		fields[i] = fmt.Sprintf("UpdateEvents: %v", v.UpdateEvents)
		i++
	}
	if v.InstanceEvents != nil {
		fields[i] = fmt.Sprintf("InstanceEvents: %v", v.InstanceEvents)
		i++
	}

	return fmt.Sprintf("JobUpdateDetails{%v}", strings.Join(fields[:i], ", "))
}

func _List_JobUpdateEvent_Equals(lhs, rhs []*JobUpdateEvent) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

func _List_JobInstanceUpdateEvent_Equals(lhs, rhs []*JobInstanceUpdateEvent) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this JobUpdateDetails match the
// provided JobUpdateDetails.
//
// This function performs a deep comparison.
func (v *JobUpdateDetails) Equals(rhs *JobUpdateDetails) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Update == nil && rhs.Update == nil) || (v.Update != nil && rhs.Update != nil && v.Update.Equals(rhs.Update))) {
		return false
	}
	if !((v.UpdateEvents == nil && rhs.UpdateEvents == nil) || (v.UpdateEvents != nil && rhs.UpdateEvents != nil && _List_JobUpdateEvent_Equals(v.UpdateEvents, rhs.UpdateEvents))) {
		return false
	}
	if !((v.InstanceEvents == nil && rhs.InstanceEvents == nil) || (v.InstanceEvents != nil && rhs.InstanceEvents != nil && _List_JobInstanceUpdateEvent_Equals(v.InstanceEvents, rhs.InstanceEvents))) {
		return false
	}

	return true
}

type _List_JobUpdateEvent_Zapper []*JobUpdateEvent

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_JobUpdateEvent_Zapper.
func (l _List_JobUpdateEvent_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

type _List_JobInstanceUpdateEvent_Zapper []*JobInstanceUpdateEvent

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_JobInstanceUpdateEvent_Zapper.
func (l _List_JobInstanceUpdateEvent_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of JobUpdateDetails.
func (v *JobUpdateDetails) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Update != nil {
		err = multierr.Append(err, enc.AddObject("update", v.Update))
	}
	if v.UpdateEvents != nil {
		err = multierr.Append(err, enc.AddArray("updateEvents", (_List_JobUpdateEvent_Zapper)(v.UpdateEvents)))
	}
	if v.InstanceEvents != nil {
		err = multierr.Append(err, enc.AddArray("instanceEvents", (_List_JobInstanceUpdateEvent_Zapper)(v.InstanceEvents)))
	}
	return err
}

// GetUpdate returns the value of Update if it is set or its
// zero value if it is unset.
func (v *JobUpdateDetails) GetUpdate() (o *JobUpdate) {
	if v != nil && v.Update != nil {
		return v.Update
	}

	return
}

// IsSetUpdate returns true if Update is not nil.
func (v *JobUpdateDetails) IsSetUpdate() bool {
	return v != nil && v.Update != nil
}

// GetUpdateEvents returns the value of UpdateEvents if it is set or its
// zero value if it is unset.
func (v *JobUpdateDetails) GetUpdateEvents() (o []*JobUpdateEvent) {
	if v != nil && v.UpdateEvents != nil {
		return v.UpdateEvents
	}

	return
}

// IsSetUpdateEvents returns true if UpdateEvents is not nil.
func (v *JobUpdateDetails) IsSetUpdateEvents() bool {
	return v != nil && v.UpdateEvents != nil
}

// GetInstanceEvents returns the value of InstanceEvents if it is set or its
// zero value if it is unset.
func (v *JobUpdateDetails) GetInstanceEvents() (o []*JobInstanceUpdateEvent) {
	if v != nil && v.InstanceEvents != nil {
		return v.InstanceEvents
	}

	return
}

// IsSetInstanceEvents returns true if InstanceEvents is not nil.
func (v *JobUpdateDetails) IsSetInstanceEvents() bool {
	return v != nil && v.InstanceEvents != nil
}

// Event marking a state transition in job update lifecycle.
type JobUpdateEvent struct {
	// Update status.
	Status *JobUpdateStatus `json:"status,omitempty"`
	// Epoch timestamp in milliseconds.
	TimestampMs *int64 `json:"timestampMs,omitempty"`
	// User who performed this event (if user-initiated).
	User *string `json:"user,omitempty"`
	// Message from the user (for user-initiated transitions) or the scheduler about why the state was
	// changed.
	Message *string `json:"message,omitempty"`
}

// ToWire translates a JobUpdateEvent struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *JobUpdateEvent) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Status != nil {
		w, err = v.Status.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.TimestampMs != nil {
		w, err = wire.NewValueI64(*(v.TimestampMs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.User != nil {
		w, err = wire.NewValueString(*(v.User)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _JobUpdateStatus_Read(w wire.Value) (JobUpdateStatus, error) {
	var v JobUpdateStatus
	err := v.FromWire(w)
	return v, err
}

// FromWire deserializes a JobUpdateEvent struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a JobUpdateEvent struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v JobUpdateEvent
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *JobUpdateEvent) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x JobUpdateStatus
				x, err = _JobUpdateStatus_Read(field.Value)
				v.Status = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.TimestampMs = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.User = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a JobUpdateEvent
// struct.
func (v *JobUpdateEvent) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Status != nil {
		fields[i] = fmt.Sprintf("Status: %v", *(v.Status))
		i++
	}
	if v.TimestampMs != nil {
		fields[i] = fmt.Sprintf("TimestampMs: %v", *(v.TimestampMs))
		i++
	}
	if v.User != nil {
		fields[i] = fmt.Sprintf("User: %v", *(v.User))
		i++
	}
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}

	return fmt.Sprintf("JobUpdateEvent{%v}", strings.Join(fields[:i], ", "))
}

func _JobUpdateStatus_EqualsPtr(lhs, rhs *JobUpdateStatus) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this JobUpdateEvent match the
// provided JobUpdateEvent.
//
// This function performs a deep comparison.
func (v *JobUpdateEvent) Equals(rhs *JobUpdateEvent) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_JobUpdateStatus_EqualsPtr(v.Status, rhs.Status) {
		return false
	}
	if !_I64_EqualsPtr(v.TimestampMs, rhs.TimestampMs) {
		return false
	}
	if !_String_EqualsPtr(v.User, rhs.User) {
		return false
	}
	if !_String_EqualsPtr(v.Message, rhs.Message) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of JobUpdateEvent.
func (v *JobUpdateEvent) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Status != nil {
		err = multierr.Append(err, enc.AddObject("status", *v.Status))
	}
	if v.TimestampMs != nil {
		enc.AddInt64("timestampMs", *v.TimestampMs)
	}
	if v.User != nil {
		enc.AddString("user", *v.User)
	}
	if v.Message != nil {
		enc.AddString("message", *v.Message)
	}
	return err
}

// GetStatus returns the value of Status if it is set or its
// zero value if it is unset.
func (v *JobUpdateEvent) GetStatus() (o JobUpdateStatus) {
	if v != nil && v.Status != nil {
		return *v.Status
	}

	return
}

// IsSetStatus returns true if Status is not nil.
func (v *JobUpdateEvent) IsSetStatus() bool {
	return v != nil && v.Status != nil
}

// GetTimestampMs returns the value of TimestampMs if it is set or its
// zero value if it is unset.
func (v *JobUpdateEvent) GetTimestampMs() (o int64) {
	if v != nil && v.TimestampMs != nil {
		return *v.TimestampMs
	}

	return
}

// IsSetTimestampMs returns true if TimestampMs is not nil.
func (v *JobUpdateEvent) IsSetTimestampMs() bool {
	return v != nil && v.TimestampMs != nil
}

// GetUser returns the value of User if it is set or its
// zero value if it is unset.
func (v *JobUpdateEvent) GetUser() (o string) {
	if v != nil && v.User != nil {
		return *v.User
	}

	return
}

// IsSetUser returns true if User is not nil.
func (v *JobUpdateEvent) IsSetUser() bool {
	return v != nil && v.User != nil
}

// GetMessage returns the value of Message if it is set or its
// zero value if it is unset.
func (v *JobUpdateEvent) GetMessage() (o string) {
	if v != nil && v.Message != nil {
		return *v.Message
	}

	return
}

// IsSetMessage returns true if Message is not nil.
func (v *JobUpdateEvent) IsSetMessage() bool {
	return v != nil && v.Message != nil
}

// Update configuration and setting details.
type JobUpdateInstructions struct {
	// Actual InstanceId -> TaskConfig mapping when the update was requested.
	InitialState []*InstanceTaskConfig `json:"initialState,omitempty"`
	// Desired configuration when the update completes.
	DesiredState *InstanceTaskConfig `json:"desiredState,omitempty"`
	// Update specific settings.
	Settings *JobUpdateSettings `json:"settings,omitempty"`
}

type _Set_InstanceTaskConfig_sliceType_ValueList []*InstanceTaskConfig

func (v _Set_InstanceTaskConfig_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_InstanceTaskConfig_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_InstanceTaskConfig_sliceType_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_InstanceTaskConfig_sliceType_ValueList) Close() {}

// ToWire translates a JobUpdateInstructions struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *JobUpdateInstructions) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.InitialState != nil {
		w, err = wire.NewValueSet(_Set_InstanceTaskConfig_sliceType_ValueList(v.InitialState)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.DesiredState != nil {
		w, err = v.DesiredState.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Settings != nil {
		w, err = v.Settings.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _InstanceTaskConfig_Read(w wire.Value) (*InstanceTaskConfig, error) {
	var v InstanceTaskConfig
	err := v.FromWire(w)
	return &v, err
}

func _Set_InstanceTaskConfig_sliceType_Read(s wire.ValueList) ([]*InstanceTaskConfig, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*InstanceTaskConfig, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _InstanceTaskConfig_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

func _JobUpdateSettings_Read(w wire.Value) (*JobUpdateSettings, error) {
	var v JobUpdateSettings
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a JobUpdateInstructions struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a JobUpdateInstructions struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v JobUpdateInstructions
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *JobUpdateInstructions) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TSet {
				v.InitialState, err = _Set_InstanceTaskConfig_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.DesiredState, err = _InstanceTaskConfig_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.Settings, err = _JobUpdateSettings_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a JobUpdateInstructions
// struct.
func (v *JobUpdateInstructions) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.InitialState != nil {
		fields[i] = fmt.Sprintf("InitialState: %v", v.InitialState)
		i++
	}
	if v.DesiredState != nil {
		fields[i] = fmt.Sprintf("DesiredState: %v", v.DesiredState)
		i++
	}
	if v.Settings != nil {
		fields[i] = fmt.Sprintf("Settings: %v", v.Settings)
		i++
	}

	return fmt.Sprintf("JobUpdateInstructions{%v}", strings.Join(fields[:i], ", "))
}

func _Set_InstanceTaskConfig_sliceType_Equals(lhs, rhs []*InstanceTaskConfig) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this JobUpdateInstructions match the
// provided JobUpdateInstructions.
//
// This function performs a deep comparison.
func (v *JobUpdateInstructions) Equals(rhs *JobUpdateInstructions) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.InitialState == nil && rhs.InitialState == nil) || (v.InitialState != nil && rhs.InitialState != nil && _Set_InstanceTaskConfig_sliceType_Equals(v.InitialState, rhs.InitialState))) {
		return false
	}
	if !((v.DesiredState == nil && rhs.DesiredState == nil) || (v.DesiredState != nil && rhs.DesiredState != nil && v.DesiredState.Equals(rhs.DesiredState))) {
		return false
	}
	if !((v.Settings == nil && rhs.Settings == nil) || (v.Settings != nil && rhs.Settings != nil && v.Settings.Equals(rhs.Settings))) {
		return false
	}

	return true
}

type _Set_InstanceTaskConfig_sliceType_Zapper []*InstanceTaskConfig

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_InstanceTaskConfig_sliceType_Zapper.
func (s _Set_InstanceTaskConfig_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of JobUpdateInstructions.
func (v *JobUpdateInstructions) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.InitialState != nil {
		err = multierr.Append(err, enc.AddArray("initialState", (_Set_InstanceTaskConfig_sliceType_Zapper)(v.InitialState)))
	}
	if v.DesiredState != nil {
		err = multierr.Append(err, enc.AddObject("desiredState", v.DesiredState))
	}
	if v.Settings != nil {
		err = multierr.Append(err, enc.AddObject("settings", v.Settings))
	}
	return err
}

// GetInitialState returns the value of InitialState if it is set or its
// zero value if it is unset.
func (v *JobUpdateInstructions) GetInitialState() (o []*InstanceTaskConfig) {
	if v != nil && v.InitialState != nil {
		return v.InitialState
	}

	return
}

// IsSetInitialState returns true if InitialState is not nil.
func (v *JobUpdateInstructions) IsSetInitialState() bool {
	return v != nil && v.InitialState != nil
}

// GetDesiredState returns the value of DesiredState if it is set or its
// zero value if it is unset.
func (v *JobUpdateInstructions) GetDesiredState() (o *InstanceTaskConfig) {
	if v != nil && v.DesiredState != nil {
		return v.DesiredState
	}

	return
}

// IsSetDesiredState returns true if DesiredState is not nil.
func (v *JobUpdateInstructions) IsSetDesiredState() bool {
	return v != nil && v.DesiredState != nil
}

// GetSettings returns the value of Settings if it is set or its
// zero value if it is unset.
func (v *JobUpdateInstructions) GetSettings() (o *JobUpdateSettings) {
	if v != nil && v.Settings != nil {
		return v.Settings
	}

	return
}

// IsSetSettings returns true if Settings is not nil.
func (v *JobUpdateInstructions) IsSetSettings() bool {
	return v != nil && v.Settings != nil
}

// Job update key.
type JobUpdateKey struct {
	// Job being updated
	Job *JobKey `json:"job,omitempty"`
	// Update ID.
	ID *string `json:"id,omitempty"`
}

// ToWire translates a JobUpdateKey struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *JobUpdateKey) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Job != nil {
		w, err = v.Job.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ID != nil {
		w, err = wire.NewValueString(*(v.ID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a JobUpdateKey struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a JobUpdateKey struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v JobUpdateKey
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *JobUpdateKey) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Job, err = _JobKey_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ID = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a JobUpdateKey
// struct.
func (v *JobUpdateKey) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Job != nil {
		fields[i] = fmt.Sprintf("Job: %v", v.Job)
		i++
	}
	if v.ID != nil {
		fields[i] = fmt.Sprintf("ID: %v", *(v.ID))
		i++
	}

	return fmt.Sprintf("JobUpdateKey{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this JobUpdateKey match the
// provided JobUpdateKey.
//
// This function performs a deep comparison.
func (v *JobUpdateKey) Equals(rhs *JobUpdateKey) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Job == nil && rhs.Job == nil) || (v.Job != nil && rhs.Job != nil && v.Job.Equals(rhs.Job))) {
		return false
	}
	if !_String_EqualsPtr(v.ID, rhs.ID) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of JobUpdateKey.
func (v *JobUpdateKey) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Job != nil {
		err = multierr.Append(err, enc.AddObject("job", v.Job))
	}
	if v.ID != nil {
		enc.AddString("id", *v.ID)
	}
	return err
}

// GetJob returns the value of Job if it is set or its
// zero value if it is unset.
func (v *JobUpdateKey) GetJob() (o *JobKey) {
	if v != nil && v.Job != nil {
		return v.Job
	}

	return
}

// IsSetJob returns true if Job is not nil.
func (v *JobUpdateKey) IsSetJob() bool {
	return v != nil && v.Job != nil
}

// GetID returns the value of ID if it is set or its
// zero value if it is unset.
func (v *JobUpdateKey) GetID() (o string) {
	if v != nil && v.ID != nil {
		return *v.ID
	}

	return
}

// IsSetID returns true if ID is not nil.
func (v *JobUpdateKey) IsSetID() bool {
	return v != nil && v.ID != nil
}

// Status of the coordinated update. Intended as a response to pulseJobUpdate RPC.
type JobUpdatePulseStatus int32

const (
	// Update is active. See ACTIVE_JOB_UPDATE_STATES for statuses considered active.
	JobUpdatePulseStatusOk JobUpdatePulseStatus = 1
	// Update has reached terminal state. See TERMINAL_JOB_UPDATE_STATES for statuses
	// considered terminal.
	JobUpdatePulseStatusFinished JobUpdatePulseStatus = 2
)

// JobUpdatePulseStatus_Values returns all recognized values of JobUpdatePulseStatus.
func JobUpdatePulseStatus_Values() []JobUpdatePulseStatus {
	return []JobUpdatePulseStatus{
		JobUpdatePulseStatusOk,
		JobUpdatePulseStatusFinished,
	}
}

// UnmarshalText tries to decode JobUpdatePulseStatus from a byte slice
// containing its name.
//
//   var v JobUpdatePulseStatus
//   err := v.UnmarshalText([]byte("OK"))
func (v *JobUpdatePulseStatus) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "OK":
		*v = JobUpdatePulseStatusOk
		return nil
	case "FINISHED":
		*v = JobUpdatePulseStatusFinished
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "JobUpdatePulseStatus", err)
		}
		*v = JobUpdatePulseStatus(val)
		return nil
	}
}

// MarshalText encodes JobUpdatePulseStatus to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v JobUpdatePulseStatus) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 1:
		return []byte("OK"), nil
	case 2:
		return []byte("FINISHED"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of JobUpdatePulseStatus.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v JobUpdatePulseStatus) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 1:
		enc.AddString("name", "OK")
	case 2:
		enc.AddString("name", "FINISHED")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v JobUpdatePulseStatus) Ptr() *JobUpdatePulseStatus {
	return &v
}

// ToWire translates JobUpdatePulseStatus into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v JobUpdatePulseStatus) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes JobUpdatePulseStatus from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return JobUpdatePulseStatus(0), err
//   }
//
//   var v JobUpdatePulseStatus
//   if err := v.FromWire(x); err != nil {
//     return JobUpdatePulseStatus(0), err
//   }
//   return v, nil
func (v *JobUpdatePulseStatus) FromWire(w wire.Value) error {
	*v = (JobUpdatePulseStatus)(w.GetI32())
	return nil
}

// String returns a readable string representation of JobUpdatePulseStatus.
func (v JobUpdatePulseStatus) String() string {
	w := int32(v)
	switch w {
	case 1:
		return "OK"
	case 2:
		return "FINISHED"
	}
	return fmt.Sprintf("JobUpdatePulseStatus(%d)", w)
}

// Equals returns true if this JobUpdatePulseStatus value matches the provided
// value.
func (v JobUpdatePulseStatus) Equals(rhs JobUpdatePulseStatus) bool {
	return v == rhs
}

// MarshalJSON serializes JobUpdatePulseStatus into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v JobUpdatePulseStatus) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 1:
		return ([]byte)("\"OK\""), nil
	case 2:
		return ([]byte)("\"FINISHED\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode JobUpdatePulseStatus from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *JobUpdatePulseStatus) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "JobUpdatePulseStatus")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "JobUpdatePulseStatus")
		}
		*v = (JobUpdatePulseStatus)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "JobUpdatePulseStatus")
	}
}

// Contains a set of restrictions on matching job updates where all restrictions must be met
// (terms are AND'ed together).
type JobUpdateQuery struct {
	// Job role.
	Role *string `json:"role,omitempty"`
	// Unique identifier for a job update.
	Key *JobUpdateKey `json:"key,omitempty"`
	// Job key.
	JobKey *JobKey `json:"jobKey,omitempty"`
	// User who created the update.
	User *string `json:"user,omitempty"`
	// Set of update statuses.
	UpdateStatuses map[JobUpdateStatus]struct{} `json:"updateStatuses,omitempty"`
	// Offset to serve data from. Used by pagination.
	Offset *int32 `json:"offset,omitempty"`
	// Number or records to serve. Used by pagination.
	Limit *int32 `json:"limit,omitempty"`
}

type _Set_JobUpdateStatus_mapType_ValueList map[JobUpdateStatus]struct{}

func (v _Set_JobUpdateStatus_mapType_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_JobUpdateStatus_mapType_ValueList) Size() int {
	return len(v)
}

func (_Set_JobUpdateStatus_mapType_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_Set_JobUpdateStatus_mapType_ValueList) Close() {}

// ToWire translates a JobUpdateQuery struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *JobUpdateQuery) ToWire() (wire.Value, error) {
	var (
		fields [7]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Role != nil {
		w, err = wire.NewValueString(*(v.Role)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Key != nil {
		w, err = v.Key.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 8, Value: w}
		i++
	}
	if v.JobKey != nil {
		w, err = v.JobKey.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.User != nil {
		w, err = wire.NewValueString(*(v.User)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.UpdateStatuses != nil {
		w, err = wire.NewValueSet(_Set_JobUpdateStatus_mapType_ValueList(v.UpdateStatuses)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.Offset != nil {
		w, err = wire.NewValueI32(*(v.Offset)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	if v.Limit != nil {
		w, err = wire.NewValueI32(*(v.Limit)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _JobUpdateKey_Read(w wire.Value) (*JobUpdateKey, error) {
	var v JobUpdateKey
	err := v.FromWire(w)
	return &v, err
}

func _Set_JobUpdateStatus_mapType_Read(s wire.ValueList) (map[JobUpdateStatus]struct{}, error) {
	if s.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make(map[JobUpdateStatus]struct{}, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _JobUpdateStatus_Read(x)
		if err != nil {
			return err
		}

		o[i] = struct{}{}
		return nil
	})
	s.Close()
	return o, err
}

// FromWire deserializes a JobUpdateQuery struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a JobUpdateQuery struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v JobUpdateQuery
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *JobUpdateQuery) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Role = &x
				if err != nil {
					return err
				}

			}
		case 8:
			if field.Value.Type() == wire.TStruct {
				v.Key, err = _JobUpdateKey_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.JobKey, err = _JobKey_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.User = &x
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TSet {
				v.UpdateStatuses, err = _Set_JobUpdateStatus_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Offset = &x
				if err != nil {
					return err
				}

			}
		case 7:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Limit = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a JobUpdateQuery
// struct.
func (v *JobUpdateQuery) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [7]string
	i := 0
	if v.Role != nil {
		fields[i] = fmt.Sprintf("Role: %v", *(v.Role))
		i++
	}
	if v.Key != nil {
		fields[i] = fmt.Sprintf("Key: %v", v.Key)
		i++
	}
	if v.JobKey != nil {
		fields[i] = fmt.Sprintf("JobKey: %v", v.JobKey)
		i++
	}
	if v.User != nil {
		fields[i] = fmt.Sprintf("User: %v", *(v.User))
		i++
	}
	if v.UpdateStatuses != nil {
		fields[i] = fmt.Sprintf("UpdateStatuses: %v", v.UpdateStatuses)
		i++
	}
	if v.Offset != nil {
		fields[i] = fmt.Sprintf("Offset: %v", *(v.Offset))
		i++
	}
	if v.Limit != nil {
		fields[i] = fmt.Sprintf("Limit: %v", *(v.Limit))
		i++
	}

	return fmt.Sprintf("JobUpdateQuery{%v}", strings.Join(fields[:i], ", "))
}

func _Set_JobUpdateStatus_mapType_Equals(lhs, rhs map[JobUpdateStatus]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for x := range rhs {
		if _, ok := lhs[x]; !ok {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this JobUpdateQuery match the
// provided JobUpdateQuery.
//
// This function performs a deep comparison.
func (v *JobUpdateQuery) Equals(rhs *JobUpdateQuery) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Role, rhs.Role) {
		return false
	}
	if !((v.Key == nil && rhs.Key == nil) || (v.Key != nil && rhs.Key != nil && v.Key.Equals(rhs.Key))) {
		return false
	}
	if !((v.JobKey == nil && rhs.JobKey == nil) || (v.JobKey != nil && rhs.JobKey != nil && v.JobKey.Equals(rhs.JobKey))) {
		return false
	}
	if !_String_EqualsPtr(v.User, rhs.User) {
		return false
	}
	if !((v.UpdateStatuses == nil && rhs.UpdateStatuses == nil) || (v.UpdateStatuses != nil && rhs.UpdateStatuses != nil && _Set_JobUpdateStatus_mapType_Equals(v.UpdateStatuses, rhs.UpdateStatuses))) {
		return false
	}
	if !_I32_EqualsPtr(v.Offset, rhs.Offset) {
		return false
	}
	if !_I32_EqualsPtr(v.Limit, rhs.Limit) {
		return false
	}

	return true
}

type _Set_JobUpdateStatus_mapType_Zapper map[JobUpdateStatus]struct{}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_JobUpdateStatus_mapType_Zapper.
func (s _Set_JobUpdateStatus_mapType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of JobUpdateQuery.
func (v *JobUpdateQuery) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Role != nil {
		enc.AddString("role", *v.Role)
	}
	if v.Key != nil {
		err = multierr.Append(err, enc.AddObject("key", v.Key))
	}
	if v.JobKey != nil {
		err = multierr.Append(err, enc.AddObject("jobKey", v.JobKey))
	}
	if v.User != nil {
		enc.AddString("user", *v.User)
	}
	if v.UpdateStatuses != nil {
		err = multierr.Append(err, enc.AddArray("updateStatuses", (_Set_JobUpdateStatus_mapType_Zapper)(v.UpdateStatuses)))
	}
	if v.Offset != nil {
		enc.AddInt32("offset", *v.Offset)
	}
	if v.Limit != nil {
		enc.AddInt32("limit", *v.Limit)
	}
	return err
}

// GetRole returns the value of Role if it is set or its
// zero value if it is unset.
func (v *JobUpdateQuery) GetRole() (o string) {
	if v != nil && v.Role != nil {
		return *v.Role
	}

	return
}

// IsSetRole returns true if Role is not nil.
func (v *JobUpdateQuery) IsSetRole() bool {
	return v != nil && v.Role != nil
}

// GetKey returns the value of Key if it is set or its
// zero value if it is unset.
func (v *JobUpdateQuery) GetKey() (o *JobUpdateKey) {
	if v != nil && v.Key != nil {
		return v.Key
	}

	return
}

// IsSetKey returns true if Key is not nil.
func (v *JobUpdateQuery) IsSetKey() bool {
	return v != nil && v.Key != nil
}

// GetJobKey returns the value of JobKey if it is set or its
// zero value if it is unset.
func (v *JobUpdateQuery) GetJobKey() (o *JobKey) {
	if v != nil && v.JobKey != nil {
		return v.JobKey
	}

	return
}

// IsSetJobKey returns true if JobKey is not nil.
func (v *JobUpdateQuery) IsSetJobKey() bool {
	return v != nil && v.JobKey != nil
}

// GetUser returns the value of User if it is set or its
// zero value if it is unset.
func (v *JobUpdateQuery) GetUser() (o string) {
	if v != nil && v.User != nil {
		return *v.User
	}

	return
}

// IsSetUser returns true if User is not nil.
func (v *JobUpdateQuery) IsSetUser() bool {
	return v != nil && v.User != nil
}

// GetUpdateStatuses returns the value of UpdateStatuses if it is set or its
// zero value if it is unset.
func (v *JobUpdateQuery) GetUpdateStatuses() (o map[JobUpdateStatus]struct{}) {
	if v != nil && v.UpdateStatuses != nil {
		return v.UpdateStatuses
	}

	return
}

// IsSetUpdateStatuses returns true if UpdateStatuses is not nil.
func (v *JobUpdateQuery) IsSetUpdateStatuses() bool {
	return v != nil && v.UpdateStatuses != nil
}

// GetOffset returns the value of Offset if it is set or its
// zero value if it is unset.
func (v *JobUpdateQuery) GetOffset() (o int32) {
	if v != nil && v.Offset != nil {
		return *v.Offset
	}

	return
}

// IsSetOffset returns true if Offset is not nil.
func (v *JobUpdateQuery) IsSetOffset() bool {
	return v != nil && v.Offset != nil
}

// GetLimit returns the value of Limit if it is set or its
// zero value if it is unset.
func (v *JobUpdateQuery) GetLimit() (o int32) {
	if v != nil && v.Limit != nil {
		return *v.Limit
	}

	return
}

// IsSetLimit returns true if Limit is not nil.
func (v *JobUpdateQuery) IsSetLimit() bool {
	return v != nil && v.Limit != nil
}

// A request to update the following instances of an existing job. Used by startUpdate.
type JobUpdateRequest struct {
	// Desired TaskConfig to apply.
	TaskConfig *TaskConfig `json:"taskConfig,omitempty"`
	// Desired number of instances of the task config.
	InstanceCount *int32 `json:"instanceCount,omitempty"`
	// Update settings and limits.
	Settings *JobUpdateSettings `json:"settings,omitempty"`
	// Update metadata supplied by the client issuing the JobUpdateRequest.
	Metadata []*Metadata `json:"metadata,omitempty"`
}

type _Set_Metadata_sliceType_ValueList []*Metadata

func (v _Set_Metadata_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_Metadata_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_Metadata_sliceType_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_Metadata_sliceType_ValueList) Close() {}

// ToWire translates a JobUpdateRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *JobUpdateRequest) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.TaskConfig != nil {
		w, err = v.TaskConfig.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.InstanceCount != nil {
		w, err = wire.NewValueI32(*(v.InstanceCount)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Settings != nil {
		w, err = v.Settings.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Metadata != nil {
		w, err = wire.NewValueSet(_Set_Metadata_sliceType_ValueList(v.Metadata)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Metadata_Read(w wire.Value) (*Metadata, error) {
	var v Metadata
	err := v.FromWire(w)
	return &v, err
}

func _Set_Metadata_sliceType_Read(s wire.ValueList) ([]*Metadata, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Metadata, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _Metadata_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

// FromWire deserializes a JobUpdateRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a JobUpdateRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v JobUpdateRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *JobUpdateRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.TaskConfig, err = _TaskConfig_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.InstanceCount = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.Settings, err = _JobUpdateSettings_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TSet {
				v.Metadata, err = _Set_Metadata_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a JobUpdateRequest
// struct.
func (v *JobUpdateRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.TaskConfig != nil {
		fields[i] = fmt.Sprintf("TaskConfig: %v", v.TaskConfig)
		i++
	}
	if v.InstanceCount != nil {
		fields[i] = fmt.Sprintf("InstanceCount: %v", *(v.InstanceCount))
		i++
	}
	if v.Settings != nil {
		fields[i] = fmt.Sprintf("Settings: %v", v.Settings)
		i++
	}
	if v.Metadata != nil {
		fields[i] = fmt.Sprintf("Metadata: %v", v.Metadata)
		i++
	}

	return fmt.Sprintf("JobUpdateRequest{%v}", strings.Join(fields[:i], ", "))
}

func _Set_Metadata_sliceType_Equals(lhs, rhs []*Metadata) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this JobUpdateRequest match the
// provided JobUpdateRequest.
//
// This function performs a deep comparison.
func (v *JobUpdateRequest) Equals(rhs *JobUpdateRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.TaskConfig == nil && rhs.TaskConfig == nil) || (v.TaskConfig != nil && rhs.TaskConfig != nil && v.TaskConfig.Equals(rhs.TaskConfig))) {
		return false
	}
	if !_I32_EqualsPtr(v.InstanceCount, rhs.InstanceCount) {
		return false
	}
	if !((v.Settings == nil && rhs.Settings == nil) || (v.Settings != nil && rhs.Settings != nil && v.Settings.Equals(rhs.Settings))) {
		return false
	}
	if !((v.Metadata == nil && rhs.Metadata == nil) || (v.Metadata != nil && rhs.Metadata != nil && _Set_Metadata_sliceType_Equals(v.Metadata, rhs.Metadata))) {
		return false
	}

	return true
}

type _Set_Metadata_sliceType_Zapper []*Metadata

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_Metadata_sliceType_Zapper.
func (s _Set_Metadata_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of JobUpdateRequest.
func (v *JobUpdateRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.TaskConfig != nil {
		err = multierr.Append(err, enc.AddObject("taskConfig", v.TaskConfig))
	}
	if v.InstanceCount != nil {
		enc.AddInt32("instanceCount", *v.InstanceCount)
	}
	if v.Settings != nil {
		err = multierr.Append(err, enc.AddObject("settings", v.Settings))
	}
	if v.Metadata != nil {
		err = multierr.Append(err, enc.AddArray("metadata", (_Set_Metadata_sliceType_Zapper)(v.Metadata)))
	}
	return err
}

// GetTaskConfig returns the value of TaskConfig if it is set or its
// zero value if it is unset.
func (v *JobUpdateRequest) GetTaskConfig() (o *TaskConfig) {
	if v != nil && v.TaskConfig != nil {
		return v.TaskConfig
	}

	return
}

// IsSetTaskConfig returns true if TaskConfig is not nil.
func (v *JobUpdateRequest) IsSetTaskConfig() bool {
	return v != nil && v.TaskConfig != nil
}

// GetInstanceCount returns the value of InstanceCount if it is set or its
// zero value if it is unset.
func (v *JobUpdateRequest) GetInstanceCount() (o int32) {
	if v != nil && v.InstanceCount != nil {
		return *v.InstanceCount
	}

	return
}

// IsSetInstanceCount returns true if InstanceCount is not nil.
func (v *JobUpdateRequest) IsSetInstanceCount() bool {
	return v != nil && v.InstanceCount != nil
}

// GetSettings returns the value of Settings if it is set or its
// zero value if it is unset.
func (v *JobUpdateRequest) GetSettings() (o *JobUpdateSettings) {
	if v != nil && v.Settings != nil {
		return v.Settings
	}

	return
}

// IsSetSettings returns true if Settings is not nil.
func (v *JobUpdateRequest) IsSetSettings() bool {
	return v != nil && v.Settings != nil
}

// GetMetadata returns the value of Metadata if it is set or its
// zero value if it is unset.
func (v *JobUpdateRequest) GetMetadata() (o []*Metadata) {
	if v != nil && v.Metadata != nil {
		return v.Metadata
	}

	return
}

// IsSetMetadata returns true if Metadata is not nil.
func (v *JobUpdateRequest) IsSetMetadata() bool {
	return v != nil && v.Metadata != nil
}

// Job update thresholds and limits.
type JobUpdateSettings struct {
	// Max number of instances being updated at any given moment.
	UpdateGroupSize *int32 `json:"updateGroupSize,omitempty"`
	// Max number of instance failures to tolerate before marking instance as FAILED.
	MaxPerInstanceFailures *int32 `json:"maxPerInstanceFailures,omitempty"`
	// Max number of FAILED instances to tolerate before terminating the update.
	MaxFailedInstances *int32 `json:"maxFailedInstances,omitempty"`
	// Min time to watch a RUNNING instance.
	MinWaitInInstanceRunningMs *int32 `json:"minWaitInInstanceRunningMs,omitempty"`
	// If true, enables failed update rollback.
	RollbackOnFailure *bool `json:"rollbackOnFailure,omitempty"`
	// Instance IDs to act on. All instances will be affected if this is not set.
	UpdateOnlyTheseInstances []*Range `json:"updateOnlyTheseInstances,omitempty"`
	// If true, use updateGroupSize as strict batching boundaries, and avoid proceeding to another
	// batch until the preceding batch finishes updating.
	WaitForBatchCompletion *bool `json:"waitForBatchCompletion,omitempty"`
	// If set, requires external calls to pulseJobUpdate RPC within the specified rate for the
	// update to make progress. If no pulses received within specified interval the update will
	// block. A blocked update is unable to continue but retains its current status. It may only get
	// unblocked by a fresh pulseJobUpdate call.
	BlockIfNoPulsesAfterMs *int32 `json:"blockIfNoPulsesAfterMs,omitempty"`
}

// ToWire translates a JobUpdateSettings struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *JobUpdateSettings) ToWire() (wire.Value, error) {
	var (
		fields [8]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.UpdateGroupSize != nil {
		w, err = wire.NewValueI32(*(v.UpdateGroupSize)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.MaxPerInstanceFailures != nil {
		w, err = wire.NewValueI32(*(v.MaxPerInstanceFailures)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.MaxFailedInstances != nil {
		w, err = wire.NewValueI32(*(v.MaxFailedInstances)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.MinWaitInInstanceRunningMs != nil {
		w, err = wire.NewValueI32(*(v.MinWaitInInstanceRunningMs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.RollbackOnFailure != nil {
		w, err = wire.NewValueBool(*(v.RollbackOnFailure)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	if v.UpdateOnlyTheseInstances != nil {
		w, err = wire.NewValueSet(_Set_Range_sliceType_ValueList(v.UpdateOnlyTheseInstances)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}
	if v.WaitForBatchCompletion != nil {
		w, err = wire.NewValueBool(*(v.WaitForBatchCompletion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 8, Value: w}
		i++
	}
	if v.BlockIfNoPulsesAfterMs != nil {
		w, err = wire.NewValueI32(*(v.BlockIfNoPulsesAfterMs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 9, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a JobUpdateSettings struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a JobUpdateSettings struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v JobUpdateSettings
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *JobUpdateSettings) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.UpdateGroupSize = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.MaxPerInstanceFailures = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.MaxFailedInstances = &x
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.MinWaitInInstanceRunningMs = &x
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.RollbackOnFailure = &x
				if err != nil {
					return err
				}

			}
		case 7:
			if field.Value.Type() == wire.TSet {
				v.UpdateOnlyTheseInstances, err = _Set_Range_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 8:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.WaitForBatchCompletion = &x
				if err != nil {
					return err
				}

			}
		case 9:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.BlockIfNoPulsesAfterMs = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a JobUpdateSettings
// struct.
func (v *JobUpdateSettings) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [8]string
	i := 0
	if v.UpdateGroupSize != nil {
		fields[i] = fmt.Sprintf("UpdateGroupSize: %v", *(v.UpdateGroupSize))
		i++
	}
	if v.MaxPerInstanceFailures != nil {
		fields[i] = fmt.Sprintf("MaxPerInstanceFailures: %v", *(v.MaxPerInstanceFailures))
		i++
	}
	if v.MaxFailedInstances != nil {
		fields[i] = fmt.Sprintf("MaxFailedInstances: %v", *(v.MaxFailedInstances))
		i++
	}
	if v.MinWaitInInstanceRunningMs != nil {
		fields[i] = fmt.Sprintf("MinWaitInInstanceRunningMs: %v", *(v.MinWaitInInstanceRunningMs))
		i++
	}
	if v.RollbackOnFailure != nil {
		fields[i] = fmt.Sprintf("RollbackOnFailure: %v", *(v.RollbackOnFailure))
		i++
	}
	if v.UpdateOnlyTheseInstances != nil {
		fields[i] = fmt.Sprintf("UpdateOnlyTheseInstances: %v", v.UpdateOnlyTheseInstances)
		i++
	}
	if v.WaitForBatchCompletion != nil {
		fields[i] = fmt.Sprintf("WaitForBatchCompletion: %v", *(v.WaitForBatchCompletion))
		i++
	}
	if v.BlockIfNoPulsesAfterMs != nil {
		fields[i] = fmt.Sprintf("BlockIfNoPulsesAfterMs: %v", *(v.BlockIfNoPulsesAfterMs))
		i++
	}

	return fmt.Sprintf("JobUpdateSettings{%v}", strings.Join(fields[:i], ", "))
}

func _Bool_EqualsPtr(lhs, rhs *bool) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this JobUpdateSettings match the
// provided JobUpdateSettings.
//
// This function performs a deep comparison.
func (v *JobUpdateSettings) Equals(rhs *JobUpdateSettings) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.UpdateGroupSize, rhs.UpdateGroupSize) {
		return false
	}
	if !_I32_EqualsPtr(v.MaxPerInstanceFailures, rhs.MaxPerInstanceFailures) {
		return false
	}
	if !_I32_EqualsPtr(v.MaxFailedInstances, rhs.MaxFailedInstances) {
		return false
	}
	if !_I32_EqualsPtr(v.MinWaitInInstanceRunningMs, rhs.MinWaitInInstanceRunningMs) {
		return false
	}
	if !_Bool_EqualsPtr(v.RollbackOnFailure, rhs.RollbackOnFailure) {
		return false
	}
	if !((v.UpdateOnlyTheseInstances == nil && rhs.UpdateOnlyTheseInstances == nil) || (v.UpdateOnlyTheseInstances != nil && rhs.UpdateOnlyTheseInstances != nil && _Set_Range_sliceType_Equals(v.UpdateOnlyTheseInstances, rhs.UpdateOnlyTheseInstances))) {
		return false
	}
	if !_Bool_EqualsPtr(v.WaitForBatchCompletion, rhs.WaitForBatchCompletion) {
		return false
	}
	if !_I32_EqualsPtr(v.BlockIfNoPulsesAfterMs, rhs.BlockIfNoPulsesAfterMs) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of JobUpdateSettings.
func (v *JobUpdateSettings) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.UpdateGroupSize != nil {
		enc.AddInt32("updateGroupSize", *v.UpdateGroupSize)
	}
	if v.MaxPerInstanceFailures != nil {
		enc.AddInt32("maxPerInstanceFailures", *v.MaxPerInstanceFailures)
	}
	if v.MaxFailedInstances != nil {
		enc.AddInt32("maxFailedInstances", *v.MaxFailedInstances)
	}
	if v.MinWaitInInstanceRunningMs != nil {
		enc.AddInt32("minWaitInInstanceRunningMs", *v.MinWaitInInstanceRunningMs)
	}
	if v.RollbackOnFailure != nil {
		enc.AddBool("rollbackOnFailure", *v.RollbackOnFailure)
	}
	if v.UpdateOnlyTheseInstances != nil {
		err = multierr.Append(err, enc.AddArray("updateOnlyTheseInstances", (_Set_Range_sliceType_Zapper)(v.UpdateOnlyTheseInstances)))
	}
	if v.WaitForBatchCompletion != nil {
		enc.AddBool("waitForBatchCompletion", *v.WaitForBatchCompletion)
	}
	if v.BlockIfNoPulsesAfterMs != nil {
		enc.AddInt32("blockIfNoPulsesAfterMs", *v.BlockIfNoPulsesAfterMs)
	}
	return err
}

// GetUpdateGroupSize returns the value of UpdateGroupSize if it is set or its
// zero value if it is unset.
func (v *JobUpdateSettings) GetUpdateGroupSize() (o int32) {
	if v != nil && v.UpdateGroupSize != nil {
		return *v.UpdateGroupSize
	}

	return
}

// IsSetUpdateGroupSize returns true if UpdateGroupSize is not nil.
func (v *JobUpdateSettings) IsSetUpdateGroupSize() bool {
	return v != nil && v.UpdateGroupSize != nil
}

// GetMaxPerInstanceFailures returns the value of MaxPerInstanceFailures if it is set or its
// zero value if it is unset.
func (v *JobUpdateSettings) GetMaxPerInstanceFailures() (o int32) {
	if v != nil && v.MaxPerInstanceFailures != nil {
		return *v.MaxPerInstanceFailures
	}

	return
}

// IsSetMaxPerInstanceFailures returns true if MaxPerInstanceFailures is not nil.
func (v *JobUpdateSettings) IsSetMaxPerInstanceFailures() bool {
	return v != nil && v.MaxPerInstanceFailures != nil
}

// GetMaxFailedInstances returns the value of MaxFailedInstances if it is set or its
// zero value if it is unset.
func (v *JobUpdateSettings) GetMaxFailedInstances() (o int32) {
	if v != nil && v.MaxFailedInstances != nil {
		return *v.MaxFailedInstances
	}

	return
}

// IsSetMaxFailedInstances returns true if MaxFailedInstances is not nil.
func (v *JobUpdateSettings) IsSetMaxFailedInstances() bool {
	return v != nil && v.MaxFailedInstances != nil
}

// GetMinWaitInInstanceRunningMs returns the value of MinWaitInInstanceRunningMs if it is set or its
// zero value if it is unset.
func (v *JobUpdateSettings) GetMinWaitInInstanceRunningMs() (o int32) {
	if v != nil && v.MinWaitInInstanceRunningMs != nil {
		return *v.MinWaitInInstanceRunningMs
	}

	return
}

// IsSetMinWaitInInstanceRunningMs returns true if MinWaitInInstanceRunningMs is not nil.
func (v *JobUpdateSettings) IsSetMinWaitInInstanceRunningMs() bool {
	return v != nil && v.MinWaitInInstanceRunningMs != nil
}

// GetRollbackOnFailure returns the value of RollbackOnFailure if it is set or its
// zero value if it is unset.
func (v *JobUpdateSettings) GetRollbackOnFailure() (o bool) {
	if v != nil && v.RollbackOnFailure != nil {
		return *v.RollbackOnFailure
	}

	return
}

// IsSetRollbackOnFailure returns true if RollbackOnFailure is not nil.
func (v *JobUpdateSettings) IsSetRollbackOnFailure() bool {
	return v != nil && v.RollbackOnFailure != nil
}

// GetUpdateOnlyTheseInstances returns the value of UpdateOnlyTheseInstances if it is set or its
// zero value if it is unset.
func (v *JobUpdateSettings) GetUpdateOnlyTheseInstances() (o []*Range) {
	if v != nil && v.UpdateOnlyTheseInstances != nil {
		return v.UpdateOnlyTheseInstances
	}

	return
}

// IsSetUpdateOnlyTheseInstances returns true if UpdateOnlyTheseInstances is not nil.
func (v *JobUpdateSettings) IsSetUpdateOnlyTheseInstances() bool {
	return v != nil && v.UpdateOnlyTheseInstances != nil
}

// GetWaitForBatchCompletion returns the value of WaitForBatchCompletion if it is set or its
// zero value if it is unset.
func (v *JobUpdateSettings) GetWaitForBatchCompletion() (o bool) {
	if v != nil && v.WaitForBatchCompletion != nil {
		return *v.WaitForBatchCompletion
	}

	return
}

// IsSetWaitForBatchCompletion returns true if WaitForBatchCompletion is not nil.
func (v *JobUpdateSettings) IsSetWaitForBatchCompletion() bool {
	return v != nil && v.WaitForBatchCompletion != nil
}

// GetBlockIfNoPulsesAfterMs returns the value of BlockIfNoPulsesAfterMs if it is set or its
// zero value if it is unset.
func (v *JobUpdateSettings) GetBlockIfNoPulsesAfterMs() (o int32) {
	if v != nil && v.BlockIfNoPulsesAfterMs != nil {
		return *v.BlockIfNoPulsesAfterMs
	}

	return
}

// IsSetBlockIfNoPulsesAfterMs returns true if BlockIfNoPulsesAfterMs is not nil.
func (v *JobUpdateSettings) IsSetBlockIfNoPulsesAfterMs() bool {
	return v != nil && v.BlockIfNoPulsesAfterMs != nil
}

// Current job update state including status and created/modified timestamps.
type JobUpdateState struct {
	// Current status of the update.
	Status *JobUpdateStatus `json:"status,omitempty"`
	// Created timestamp in milliseconds.
	CreatedTimestampMs *int64 `json:"createdTimestampMs,omitempty"`
	// Last modified timestamp in milliseconds.
	LastModifiedTimestampMs *int64 `json:"lastModifiedTimestampMs,omitempty"`
}

// ToWire translates a JobUpdateState struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *JobUpdateState) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Status != nil {
		w, err = v.Status.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.CreatedTimestampMs != nil {
		w, err = wire.NewValueI64(*(v.CreatedTimestampMs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.LastModifiedTimestampMs != nil {
		w, err = wire.NewValueI64(*(v.LastModifiedTimestampMs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a JobUpdateState struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a JobUpdateState struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v JobUpdateState
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *JobUpdateState) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x JobUpdateStatus
				x, err = _JobUpdateStatus_Read(field.Value)
				v.Status = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.CreatedTimestampMs = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.LastModifiedTimestampMs = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a JobUpdateState
// struct.
func (v *JobUpdateState) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Status != nil {
		fields[i] = fmt.Sprintf("Status: %v", *(v.Status))
		i++
	}
	if v.CreatedTimestampMs != nil {
		fields[i] = fmt.Sprintf("CreatedTimestampMs: %v", *(v.CreatedTimestampMs))
		i++
	}
	if v.LastModifiedTimestampMs != nil {
		fields[i] = fmt.Sprintf("LastModifiedTimestampMs: %v", *(v.LastModifiedTimestampMs))
		i++
	}

	return fmt.Sprintf("JobUpdateState{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this JobUpdateState match the
// provided JobUpdateState.
//
// This function performs a deep comparison.
func (v *JobUpdateState) Equals(rhs *JobUpdateState) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_JobUpdateStatus_EqualsPtr(v.Status, rhs.Status) {
		return false
	}
	if !_I64_EqualsPtr(v.CreatedTimestampMs, rhs.CreatedTimestampMs) {
		return false
	}
	if !_I64_EqualsPtr(v.LastModifiedTimestampMs, rhs.LastModifiedTimestampMs) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of JobUpdateState.
func (v *JobUpdateState) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Status != nil {
		err = multierr.Append(err, enc.AddObject("status", *v.Status))
	}
	if v.CreatedTimestampMs != nil {
		enc.AddInt64("createdTimestampMs", *v.CreatedTimestampMs)
	}
	if v.LastModifiedTimestampMs != nil {
		enc.AddInt64("lastModifiedTimestampMs", *v.LastModifiedTimestampMs)
	}
	return err
}

// GetStatus returns the value of Status if it is set or its
// zero value if it is unset.
func (v *JobUpdateState) GetStatus() (o JobUpdateStatus) {
	if v != nil && v.Status != nil {
		return *v.Status
	}

	return
}

// IsSetStatus returns true if Status is not nil.
func (v *JobUpdateState) IsSetStatus() bool {
	return v != nil && v.Status != nil
}

// GetCreatedTimestampMs returns the value of CreatedTimestampMs if it is set or its
// zero value if it is unset.
func (v *JobUpdateState) GetCreatedTimestampMs() (o int64) {
	if v != nil && v.CreatedTimestampMs != nil {
		return *v.CreatedTimestampMs
	}

	return
}

// IsSetCreatedTimestampMs returns true if CreatedTimestampMs is not nil.
func (v *JobUpdateState) IsSetCreatedTimestampMs() bool {
	return v != nil && v.CreatedTimestampMs != nil
}

// GetLastModifiedTimestampMs returns the value of LastModifiedTimestampMs if it is set or its
// zero value if it is unset.
func (v *JobUpdateState) GetLastModifiedTimestampMs() (o int64) {
	if v != nil && v.LastModifiedTimestampMs != nil {
		return *v.LastModifiedTimestampMs
	}

	return
}

// IsSetLastModifiedTimestampMs returns true if LastModifiedTimestampMs is not nil.
func (v *JobUpdateState) IsSetLastModifiedTimestampMs() bool {
	return v != nil && v.LastModifiedTimestampMs != nil
}

// States that a job update may be in.
type JobUpdateStatus int32

const (
	// Update is in progress.
	JobUpdateStatusRollingForward JobUpdateStatus = 0
	// Update has failed and is being rolled back.
	JobUpdateStatusRollingBack JobUpdateStatus = 1
	// Update has been paused while in progress.
	JobUpdateStatusRollForwardPaused JobUpdateStatus = 2
	// Update has been paused during rollback.
	JobUpdateStatusRollBackPaused JobUpdateStatus = 3
	// Update has completed successfully.
	JobUpdateStatusRolledForward JobUpdateStatus = 4
	// Update has failed and rolled back.
	JobUpdateStatusRolledBack JobUpdateStatus = 5
	// Update was aborted.
	JobUpdateStatusAborted JobUpdateStatus = 6
	// Unknown error during update.
	JobUpdateStatusError JobUpdateStatus = 7
	// Update failed to complete.
	// This can happen if failure thresholds are met while rolling forward, but rollback is disabled,
	// or if failure thresholds are met when rolling back.
	JobUpdateStatusFailed JobUpdateStatus = 8
	// Update has been blocked while in progress due to missing/expired pulse.
	JobUpdateStatusRollForwardAwaitingPulse JobUpdateStatus = 9
	// Update has been blocked during rollback due to missing/expired pulse.
	JobUpdateStatusRollBackAwaitingPulse JobUpdateStatus = 10
)

// JobUpdateStatus_Values returns all recognized values of JobUpdateStatus.
func JobUpdateStatus_Values() []JobUpdateStatus {
	return []JobUpdateStatus{
		JobUpdateStatusRollingForward,
		JobUpdateStatusRollingBack,
		JobUpdateStatusRollForwardPaused,
		JobUpdateStatusRollBackPaused,
		JobUpdateStatusRolledForward,
		JobUpdateStatusRolledBack,
		JobUpdateStatusAborted,
		JobUpdateStatusError,
		JobUpdateStatusFailed,
		JobUpdateStatusRollForwardAwaitingPulse,
		JobUpdateStatusRollBackAwaitingPulse,
	}
}

// UnmarshalText tries to decode JobUpdateStatus from a byte slice
// containing its name.
//
//   var v JobUpdateStatus
//   err := v.UnmarshalText([]byte("ROLLING_FORWARD"))
func (v *JobUpdateStatus) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "ROLLING_FORWARD":
		*v = JobUpdateStatusRollingForward
		return nil
	case "ROLLING_BACK":
		*v = JobUpdateStatusRollingBack
		return nil
	case "ROLL_FORWARD_PAUSED":
		*v = JobUpdateStatusRollForwardPaused
		return nil
	case "ROLL_BACK_PAUSED":
		*v = JobUpdateStatusRollBackPaused
		return nil
	case "ROLLED_FORWARD":
		*v = JobUpdateStatusRolledForward
		return nil
	case "ROLLED_BACK":
		*v = JobUpdateStatusRolledBack
		return nil
	case "ABORTED":
		*v = JobUpdateStatusAborted
		return nil
	case "ERROR":
		*v = JobUpdateStatusError
		return nil
	case "FAILED":
		*v = JobUpdateStatusFailed
		return nil
	case "ROLL_FORWARD_AWAITING_PULSE":
		*v = JobUpdateStatusRollForwardAwaitingPulse
		return nil
	case "ROLL_BACK_AWAITING_PULSE":
		*v = JobUpdateStatusRollBackAwaitingPulse
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "JobUpdateStatus", err)
		}
		*v = JobUpdateStatus(val)
		return nil
	}
}

// MarshalText encodes JobUpdateStatus to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v JobUpdateStatus) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("ROLLING_FORWARD"), nil
	case 1:
		return []byte("ROLLING_BACK"), nil
	case 2:
		return []byte("ROLL_FORWARD_PAUSED"), nil
	case 3:
		return []byte("ROLL_BACK_PAUSED"), nil
	case 4:
		return []byte("ROLLED_FORWARD"), nil
	case 5:
		return []byte("ROLLED_BACK"), nil
	case 6:
		return []byte("ABORTED"), nil
	case 7:
		return []byte("ERROR"), nil
	case 8:
		return []byte("FAILED"), nil
	case 9:
		return []byte("ROLL_FORWARD_AWAITING_PULSE"), nil
	case 10:
		return []byte("ROLL_BACK_AWAITING_PULSE"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of JobUpdateStatus.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v JobUpdateStatus) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "ROLLING_FORWARD")
	case 1:
		enc.AddString("name", "ROLLING_BACK")
	case 2:
		enc.AddString("name", "ROLL_FORWARD_PAUSED")
	case 3:
		enc.AddString("name", "ROLL_BACK_PAUSED")
	case 4:
		enc.AddString("name", "ROLLED_FORWARD")
	case 5:
		enc.AddString("name", "ROLLED_BACK")
	case 6:
		enc.AddString("name", "ABORTED")
	case 7:
		enc.AddString("name", "ERROR")
	case 8:
		enc.AddString("name", "FAILED")
	case 9:
		enc.AddString("name", "ROLL_FORWARD_AWAITING_PULSE")
	case 10:
		enc.AddString("name", "ROLL_BACK_AWAITING_PULSE")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v JobUpdateStatus) Ptr() *JobUpdateStatus {
	return &v
}

// ToWire translates JobUpdateStatus into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v JobUpdateStatus) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes JobUpdateStatus from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return JobUpdateStatus(0), err
//   }
//
//   var v JobUpdateStatus
//   if err := v.FromWire(x); err != nil {
//     return JobUpdateStatus(0), err
//   }
//   return v, nil
func (v *JobUpdateStatus) FromWire(w wire.Value) error {
	*v = (JobUpdateStatus)(w.GetI32())
	return nil
}

// String returns a readable string representation of JobUpdateStatus.
func (v JobUpdateStatus) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "ROLLING_FORWARD"
	case 1:
		return "ROLLING_BACK"
	case 2:
		return "ROLL_FORWARD_PAUSED"
	case 3:
		return "ROLL_BACK_PAUSED"
	case 4:
		return "ROLLED_FORWARD"
	case 5:
		return "ROLLED_BACK"
	case 6:
		return "ABORTED"
	case 7:
		return "ERROR"
	case 8:
		return "FAILED"
	case 9:
		return "ROLL_FORWARD_AWAITING_PULSE"
	case 10:
		return "ROLL_BACK_AWAITING_PULSE"
	}
	return fmt.Sprintf("JobUpdateStatus(%d)", w)
}

// Equals returns true if this JobUpdateStatus value matches the provided
// value.
func (v JobUpdateStatus) Equals(rhs JobUpdateStatus) bool {
	return v == rhs
}

// MarshalJSON serializes JobUpdateStatus into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v JobUpdateStatus) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"ROLLING_FORWARD\""), nil
	case 1:
		return ([]byte)("\"ROLLING_BACK\""), nil
	case 2:
		return ([]byte)("\"ROLL_FORWARD_PAUSED\""), nil
	case 3:
		return ([]byte)("\"ROLL_BACK_PAUSED\""), nil
	case 4:
		return ([]byte)("\"ROLLED_FORWARD\""), nil
	case 5:
		return ([]byte)("\"ROLLED_BACK\""), nil
	case 6:
		return ([]byte)("\"ABORTED\""), nil
	case 7:
		return ([]byte)("\"ERROR\""), nil
	case 8:
		return ([]byte)("\"FAILED\""), nil
	case 9:
		return ([]byte)("\"ROLL_FORWARD_AWAITING_PULSE\""), nil
	case 10:
		return ([]byte)("\"ROLL_BACK_AWAITING_PULSE\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode JobUpdateStatus from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *JobUpdateStatus) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "JobUpdateStatus")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "JobUpdateStatus")
		}
		*v = (JobUpdateStatus)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "JobUpdateStatus")
	}
}

// Summary of the job update including job key, user and current state.
type JobUpdateSummary struct {
	// Unique identifier for the update.
	Key *JobUpdateKey `json:"key,omitempty"`
	// User initiated an update.
	User *string `json:"user,omitempty"`
	// Current job update state.
	State *JobUpdateState `json:"state,omitempty"`
	// Update metadata supplied by the client.
	Metadata []*Metadata `json:"metadata,omitempty"`
}

// ToWire translates a JobUpdateSummary struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *JobUpdateSummary) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Key != nil {
		w, err = v.Key.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.User != nil {
		w, err = wire.NewValueString(*(v.User)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.State != nil {
		w, err = v.State.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Metadata != nil {
		w, err = wire.NewValueSet(_Set_Metadata_sliceType_ValueList(v.Metadata)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _JobUpdateState_Read(w wire.Value) (*JobUpdateState, error) {
	var v JobUpdateState
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a JobUpdateSummary struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a JobUpdateSummary struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v JobUpdateSummary
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *JobUpdateSummary) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 5:
			if field.Value.Type() == wire.TStruct {
				v.Key, err = _JobUpdateKey_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.User = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TStruct {
				v.State, err = _JobUpdateState_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TSet {
				v.Metadata, err = _Set_Metadata_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a JobUpdateSummary
// struct.
func (v *JobUpdateSummary) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Key != nil {
		fields[i] = fmt.Sprintf("Key: %v", v.Key)
		i++
	}
	if v.User != nil {
		fields[i] = fmt.Sprintf("User: %v", *(v.User))
		i++
	}
	if v.State != nil {
		fields[i] = fmt.Sprintf("State: %v", v.State)
		i++
	}
	if v.Metadata != nil {
		fields[i] = fmt.Sprintf("Metadata: %v", v.Metadata)
		i++
	}

	return fmt.Sprintf("JobUpdateSummary{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this JobUpdateSummary match the
// provided JobUpdateSummary.
//
// This function performs a deep comparison.
func (v *JobUpdateSummary) Equals(rhs *JobUpdateSummary) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Key == nil && rhs.Key == nil) || (v.Key != nil && rhs.Key != nil && v.Key.Equals(rhs.Key))) {
		return false
	}
	if !_String_EqualsPtr(v.User, rhs.User) {
		return false
	}
	if !((v.State == nil && rhs.State == nil) || (v.State != nil && rhs.State != nil && v.State.Equals(rhs.State))) {
		return false
	}
	if !((v.Metadata == nil && rhs.Metadata == nil) || (v.Metadata != nil && rhs.Metadata != nil && _Set_Metadata_sliceType_Equals(v.Metadata, rhs.Metadata))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of JobUpdateSummary.
func (v *JobUpdateSummary) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Key != nil {
		err = multierr.Append(err, enc.AddObject("key", v.Key))
	}
	if v.User != nil {
		enc.AddString("user", *v.User)
	}
	if v.State != nil {
		err = multierr.Append(err, enc.AddObject("state", v.State))
	}
	if v.Metadata != nil {
		err = multierr.Append(err, enc.AddArray("metadata", (_Set_Metadata_sliceType_Zapper)(v.Metadata)))
	}
	return err
}

// GetKey returns the value of Key if it is set or its
// zero value if it is unset.
func (v *JobUpdateSummary) GetKey() (o *JobUpdateKey) {
	if v != nil && v.Key != nil {
		return v.Key
	}

	return
}

// IsSetKey returns true if Key is not nil.
func (v *JobUpdateSummary) IsSetKey() bool {
	return v != nil && v.Key != nil
}

// GetUser returns the value of User if it is set or its
// zero value if it is unset.
func (v *JobUpdateSummary) GetUser() (o string) {
	if v != nil && v.User != nil {
		return *v.User
	}

	return
}

// IsSetUser returns true if User is not nil.
func (v *JobUpdateSummary) IsSetUser() bool {
	return v != nil && v.User != nil
}

// GetState returns the value of State if it is set or its
// zero value if it is unset.
func (v *JobUpdateSummary) GetState() (o *JobUpdateState) {
	if v != nil && v.State != nil {
		return v.State
	}

	return
}

// IsSetState returns true if State is not nil.
func (v *JobUpdateSummary) IsSetState() bool {
	return v != nil && v.State != nil
}

// GetMetadata returns the value of Metadata if it is set or its
// zero value if it is unset.
func (v *JobUpdateSummary) GetMetadata() (o []*Metadata) {
	if v != nil && v.Metadata != nil {
		return v.Metadata
	}

	return
}

// IsSetMetadata returns true if Metadata is not nil.
func (v *JobUpdateSummary) IsSetMetadata() bool {
	return v != nil && v.Metadata != nil
}

// A constraint the specifies the maximum number of active tasks on a host with a matching
// attribute that may be scheduled simultaneously.
type LimitConstraint struct {
	Limit *int32 `json:"limit,omitempty"`
}

// ToWire translates a LimitConstraint struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *LimitConstraint) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Limit != nil {
		w, err = wire.NewValueI32(*(v.Limit)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a LimitConstraint struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a LimitConstraint struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v LimitConstraint
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *LimitConstraint) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Limit = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a LimitConstraint
// struct.
func (v *LimitConstraint) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Limit != nil {
		fields[i] = fmt.Sprintf("Limit: %v", *(v.Limit))
		i++
	}

	return fmt.Sprintf("LimitConstraint{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this LimitConstraint match the
// provided LimitConstraint.
//
// This function performs a deep comparison.
func (v *LimitConstraint) Equals(rhs *LimitConstraint) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.Limit, rhs.Limit) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of LimitConstraint.
func (v *LimitConstraint) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Limit != nil {
		enc.AddInt32("limit", *v.Limit)
	}
	return err
}

// GetLimit returns the value of Limit if it is set or its
// zero value if it is unset.
func (v *LimitConstraint) GetLimit() (o int32) {
	if v != nil && v.Limit != nil {
		return *v.Limit
	}

	return
}

// IsSetLimit returns true if Limit is not nil.
func (v *LimitConstraint) IsSetLimit() bool {
	return v != nil && v.Limit != nil
}

type ListBackupsResult struct {
	Backups map[string]struct{} `json:"backups,omitempty"`
}

// ToWire translates a ListBackupsResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ListBackupsResult) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Backups != nil {
		w, err = wire.NewValueSet(_Set_String_mapType_ValueList(v.Backups)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ListBackupsResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ListBackupsResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ListBackupsResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ListBackupsResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TSet {
				v.Backups, err = _Set_String_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ListBackupsResult
// struct.
func (v *ListBackupsResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Backups != nil {
		fields[i] = fmt.Sprintf("Backups: %v", v.Backups)
		i++
	}

	return fmt.Sprintf("ListBackupsResult{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ListBackupsResult match the
// provided ListBackupsResult.
//
// This function performs a deep comparison.
func (v *ListBackupsResult) Equals(rhs *ListBackupsResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Backups == nil && rhs.Backups == nil) || (v.Backups != nil && rhs.Backups != nil && _Set_String_mapType_Equals(v.Backups, rhs.Backups))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ListBackupsResult.
func (v *ListBackupsResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Backups != nil {
		err = multierr.Append(err, enc.AddArray("backups", (_Set_String_mapType_Zapper)(v.Backups)))
	}
	return err
}

// GetBackups returns the value of Backups if it is set or its
// zero value if it is unset.
func (v *ListBackupsResult) GetBackups() (o map[string]struct{}) {
	if v != nil && v.Backups != nil {
		return v.Backups
	}

	return
}

// IsSetBackups returns true if Backups is not nil.
func (v *ListBackupsResult) IsSetBackups() bool {
	return v != nil && v.Backups != nil
}

// A generic lock struct to facilitate context specific resource/operation serialization.
type Lock struct {
	// ID of the lock - unique per storage
	Key *LockKey `json:"key,omitempty"`
	// UUID - facilitating soft lock authorization
	Token *string `json:"token,omitempty"`
	// Lock creator
	User *string `json:"user,omitempty"`
	// Lock creation timestamp in milliseconds
	TimestampMs *int64 `json:"timestampMs,omitempty"`
	// Optional message to record with the lock
	Message *string `json:"message,omitempty"`
}

// ToWire translates a Lock struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Lock) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Key != nil {
		w, err = v.Key.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Token != nil {
		w, err = wire.NewValueString(*(v.Token)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.User != nil {
		w, err = wire.NewValueString(*(v.User)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.TimestampMs != nil {
		w, err = wire.NewValueI64(*(v.TimestampMs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _LockKey_Read(w wire.Value) (*LockKey, error) {
	var v LockKey
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Lock struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Lock struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Lock
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Lock) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Key, err = _LockKey_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Token = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.User = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.TimestampMs = &x
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Lock
// struct.
func (v *Lock) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [5]string
	i := 0
	if v.Key != nil {
		fields[i] = fmt.Sprintf("Key: %v", v.Key)
		i++
	}
	if v.Token != nil {
		fields[i] = fmt.Sprintf("Token: %v", *(v.Token))
		i++
	}
	if v.User != nil {
		fields[i] = fmt.Sprintf("User: %v", *(v.User))
		i++
	}
	if v.TimestampMs != nil {
		fields[i] = fmt.Sprintf("TimestampMs: %v", *(v.TimestampMs))
		i++
	}
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}

	return fmt.Sprintf("Lock{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Lock match the
// provided Lock.
//
// This function performs a deep comparison.
func (v *Lock) Equals(rhs *Lock) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Key == nil && rhs.Key == nil) || (v.Key != nil && rhs.Key != nil && v.Key.Equals(rhs.Key))) {
		return false
	}
	if !_String_EqualsPtr(v.Token, rhs.Token) {
		return false
	}
	if !_String_EqualsPtr(v.User, rhs.User) {
		return false
	}
	if !_I64_EqualsPtr(v.TimestampMs, rhs.TimestampMs) {
		return false
	}
	if !_String_EqualsPtr(v.Message, rhs.Message) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Lock.
func (v *Lock) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Key != nil {
		err = multierr.Append(err, enc.AddObject("key", v.Key))
	}
	if v.Token != nil {
		enc.AddString("token", *v.Token)
	}
	if v.User != nil {
		enc.AddString("user", *v.User)
	}
	if v.TimestampMs != nil {
		enc.AddInt64("timestampMs", *v.TimestampMs)
	}
	if v.Message != nil {
		enc.AddString("message", *v.Message)
	}
	return err
}

// GetKey returns the value of Key if it is set or its
// zero value if it is unset.
func (v *Lock) GetKey() (o *LockKey) {
	if v != nil && v.Key != nil {
		return v.Key
	}

	return
}

// IsSetKey returns true if Key is not nil.
func (v *Lock) IsSetKey() bool {
	return v != nil && v.Key != nil
}

// GetToken returns the value of Token if it is set or its
// zero value if it is unset.
func (v *Lock) GetToken() (o string) {
	if v != nil && v.Token != nil {
		return *v.Token
	}

	return
}

// IsSetToken returns true if Token is not nil.
func (v *Lock) IsSetToken() bool {
	return v != nil && v.Token != nil
}

// GetUser returns the value of User if it is set or its
// zero value if it is unset.
func (v *Lock) GetUser() (o string) {
	if v != nil && v.User != nil {
		return *v.User
	}

	return
}

// IsSetUser returns true if User is not nil.
func (v *Lock) IsSetUser() bool {
	return v != nil && v.User != nil
}

// GetTimestampMs returns the value of TimestampMs if it is set or its
// zero value if it is unset.
func (v *Lock) GetTimestampMs() (o int64) {
	if v != nil && v.TimestampMs != nil {
		return *v.TimestampMs
	}

	return
}

// IsSetTimestampMs returns true if TimestampMs is not nil.
func (v *Lock) IsSetTimestampMs() bool {
	return v != nil && v.TimestampMs != nil
}

// GetMessage returns the value of Message if it is set or its
// zero value if it is unset.
func (v *Lock) GetMessage() (o string) {
	if v != nil && v.Message != nil {
		return *v.Message
	}

	return
}

// IsSetMessage returns true if Message is not nil.
func (v *Lock) IsSetMessage() bool {
	return v != nil && v.Message != nil
}

// A unique lock key.
type LockKey struct {
	Job *JobKey `json:"job,omitempty"`
}

// ToWire translates a LockKey struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *LockKey) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Job != nil {
		w, err = v.Job.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("LockKey should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a LockKey struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a LockKey struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v LockKey
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *LockKey) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Job, err = _JobKey_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Job != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("LockKey should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a LockKey
// struct.
func (v *LockKey) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Job != nil {
		fields[i] = fmt.Sprintf("Job: %v", v.Job)
		i++
	}

	return fmt.Sprintf("LockKey{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this LockKey match the
// provided LockKey.
//
// This function performs a deep comparison.
func (v *LockKey) Equals(rhs *LockKey) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Job == nil && rhs.Job == nil) || (v.Job != nil && rhs.Job != nil && v.Job.Equals(rhs.Job))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of LockKey.
func (v *LockKey) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Job != nil {
		err = multierr.Append(err, enc.AddObject("job", v.Job))
	}
	return err
}

// GetJob returns the value of Job if it is set or its
// zero value if it is unset.
func (v *LockKey) GetJob() (o *JobKey) {
	if v != nil && v.Job != nil {
		return v.Job
	}

	return
}

// IsSetJob returns true if Job is not nil.
func (v *LockKey) IsSetJob() bool {
	return v != nil && v.Job != nil
}

type MaintenanceMode int32

const (
	MaintenanceModeNone      MaintenanceMode = 1
	MaintenanceModeScheduled MaintenanceMode = 2
	MaintenanceModeDraining  MaintenanceMode = 3
	MaintenanceModeDrained   MaintenanceMode = 4
)

// MaintenanceMode_Values returns all recognized values of MaintenanceMode.
func MaintenanceMode_Values() []MaintenanceMode {
	return []MaintenanceMode{
		MaintenanceModeNone,
		MaintenanceModeScheduled,
		MaintenanceModeDraining,
		MaintenanceModeDrained,
	}
}

// UnmarshalText tries to decode MaintenanceMode from a byte slice
// containing its name.
//
//   var v MaintenanceMode
//   err := v.UnmarshalText([]byte("NONE"))
func (v *MaintenanceMode) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "NONE":
		*v = MaintenanceModeNone
		return nil
	case "SCHEDULED":
		*v = MaintenanceModeScheduled
		return nil
	case "DRAINING":
		*v = MaintenanceModeDraining
		return nil
	case "DRAINED":
		*v = MaintenanceModeDrained
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "MaintenanceMode", err)
		}
		*v = MaintenanceMode(val)
		return nil
	}
}

// MarshalText encodes MaintenanceMode to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v MaintenanceMode) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 1:
		return []byte("NONE"), nil
	case 2:
		return []byte("SCHEDULED"), nil
	case 3:
		return []byte("DRAINING"), nil
	case 4:
		return []byte("DRAINED"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of MaintenanceMode.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v MaintenanceMode) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 1:
		enc.AddString("name", "NONE")
	case 2:
		enc.AddString("name", "SCHEDULED")
	case 3:
		enc.AddString("name", "DRAINING")
	case 4:
		enc.AddString("name", "DRAINED")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v MaintenanceMode) Ptr() *MaintenanceMode {
	return &v
}

// ToWire translates MaintenanceMode into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v MaintenanceMode) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes MaintenanceMode from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return MaintenanceMode(0), err
//   }
//
//   var v MaintenanceMode
//   if err := v.FromWire(x); err != nil {
//     return MaintenanceMode(0), err
//   }
//   return v, nil
func (v *MaintenanceMode) FromWire(w wire.Value) error {
	*v = (MaintenanceMode)(w.GetI32())
	return nil
}

// String returns a readable string representation of MaintenanceMode.
func (v MaintenanceMode) String() string {
	w := int32(v)
	switch w {
	case 1:
		return "NONE"
	case 2:
		return "SCHEDULED"
	case 3:
		return "DRAINING"
	case 4:
		return "DRAINED"
	}
	return fmt.Sprintf("MaintenanceMode(%d)", w)
}

// Equals returns true if this MaintenanceMode value matches the provided
// value.
func (v MaintenanceMode) Equals(rhs MaintenanceMode) bool {
	return v == rhs
}

// MarshalJSON serializes MaintenanceMode into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v MaintenanceMode) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 1:
		return ([]byte)("\"NONE\""), nil
	case 2:
		return ([]byte)("\"SCHEDULED\""), nil
	case 3:
		return ([]byte)("\"DRAINING\""), nil
	case 4:
		return ([]byte)("\"DRAINED\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode MaintenanceMode from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *MaintenanceMode) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "MaintenanceMode")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "MaintenanceMode")
		}
		*v = (MaintenanceMode)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "MaintenanceMode")
	}
}

type MaintenanceStatusResult struct {
	Statuses []*HostStatus `json:"statuses,omitempty"`
}

// ToWire translates a MaintenanceStatusResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *MaintenanceStatusResult) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Statuses != nil {
		w, err = wire.NewValueSet(_Set_HostStatus_sliceType_ValueList(v.Statuses)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a MaintenanceStatusResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a MaintenanceStatusResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v MaintenanceStatusResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *MaintenanceStatusResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TSet {
				v.Statuses, err = _Set_HostStatus_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a MaintenanceStatusResult
// struct.
func (v *MaintenanceStatusResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Statuses != nil {
		fields[i] = fmt.Sprintf("Statuses: %v", v.Statuses)
		i++
	}

	return fmt.Sprintf("MaintenanceStatusResult{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this MaintenanceStatusResult match the
// provided MaintenanceStatusResult.
//
// This function performs a deep comparison.
func (v *MaintenanceStatusResult) Equals(rhs *MaintenanceStatusResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Statuses == nil && rhs.Statuses == nil) || (v.Statuses != nil && rhs.Statuses != nil && _Set_HostStatus_sliceType_Equals(v.Statuses, rhs.Statuses))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of MaintenanceStatusResult.
func (v *MaintenanceStatusResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Statuses != nil {
		err = multierr.Append(err, enc.AddArray("statuses", (_Set_HostStatus_sliceType_Zapper)(v.Statuses)))
	}
	return err
}

// GetStatuses returns the value of Statuses if it is set or its
// zero value if it is unset.
func (v *MaintenanceStatusResult) GetStatuses() (o []*HostStatus) {
	if v != nil && v.Statuses != nil {
		return v.Statuses
	}

	return
}

// IsSetStatuses returns true if Statuses is not nil.
func (v *MaintenanceStatusResult) IsSetStatuses() bool {
	return v != nil && v.Statuses != nil
}

// Describes a mesos container, this is the default
type MesosContainer struct {
	// the optional filesystem image to use when launching this task.
	Image *Image `json:"image,omitempty"`
	// the optional list of volumes to mount into the task.
	Volumes []*Volume `json:"volumes,omitempty"`
}

type _List_Volume_ValueList []*Volume

func (v _List_Volume_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Volume_ValueList) Size() int {
	return len(v)
}

func (_List_Volume_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Volume_ValueList) Close() {}

// ToWire translates a MesosContainer struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *MesosContainer) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Image != nil {
		w, err = v.Image.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Volumes != nil {
		w, err = wire.NewValueList(_List_Volume_ValueList(v.Volumes)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Image_Read(w wire.Value) (*Image, error) {
	var v Image
	err := v.FromWire(w)
	return &v, err
}

func _Volume_Read(w wire.Value) (*Volume, error) {
	var v Volume
	err := v.FromWire(w)
	return &v, err
}

func _List_Volume_Read(l wire.ValueList) ([]*Volume, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Volume, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Volume_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a MesosContainer struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a MesosContainer struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v MesosContainer
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *MesosContainer) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Image, err = _Image_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TList {
				v.Volumes, err = _List_Volume_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a MesosContainer
// struct.
func (v *MesosContainer) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Image != nil {
		fields[i] = fmt.Sprintf("Image: %v", v.Image)
		i++
	}
	if v.Volumes != nil {
		fields[i] = fmt.Sprintf("Volumes: %v", v.Volumes)
		i++
	}

	return fmt.Sprintf("MesosContainer{%v}", strings.Join(fields[:i], ", "))
}

func _List_Volume_Equals(lhs, rhs []*Volume) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this MesosContainer match the
// provided MesosContainer.
//
// This function performs a deep comparison.
func (v *MesosContainer) Equals(rhs *MesosContainer) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Image == nil && rhs.Image == nil) || (v.Image != nil && rhs.Image != nil && v.Image.Equals(rhs.Image))) {
		return false
	}
	if !((v.Volumes == nil && rhs.Volumes == nil) || (v.Volumes != nil && rhs.Volumes != nil && _List_Volume_Equals(v.Volumes, rhs.Volumes))) {
		return false
	}

	return true
}

type _List_Volume_Zapper []*Volume

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Volume_Zapper.
func (l _List_Volume_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of MesosContainer.
func (v *MesosContainer) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Image != nil {
		err = multierr.Append(err, enc.AddObject("image", v.Image))
	}
	if v.Volumes != nil {
		err = multierr.Append(err, enc.AddArray("volumes", (_List_Volume_Zapper)(v.Volumes)))
	}
	return err
}

// GetImage returns the value of Image if it is set or its
// zero value if it is unset.
func (v *MesosContainer) GetImage() (o *Image) {
	if v != nil && v.Image != nil {
		return v.Image
	}

	return
}

// IsSetImage returns true if Image is not nil.
func (v *MesosContainer) IsSetImage() bool {
	return v != nil && v.Image != nil
}

// GetVolumes returns the value of Volumes if it is set or its
// zero value if it is unset.
func (v *MesosContainer) GetVolumes() (o []*Volume) {
	if v != nil && v.Volumes != nil {
		return v.Volumes
	}

	return
}

// IsSetVolumes returns true if Volumes is not nil.
func (v *MesosContainer) IsSetVolumes() bool {
	return v != nil && v.Volumes != nil
}

// URI which mirrors CommandInfo.URI in the Mesos Protobuf
type MesosFetcherURI struct {
	// Where to get the resource from
	Value *string `json:"value,omitempty"`
	// Extract compressed archive after downloading
	Extract *bool `json:"extract,omitempty"`
	// Cache value using Mesos Fetcher caching mechanism *
	Cache *bool `json:"cache,omitempty"`
}

// ToWire translates a MesosFetcherURI struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *MesosFetcherURI) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Value != nil {
		w, err = wire.NewValueString(*(v.Value)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Extract != nil {
		w, err = wire.NewValueBool(*(v.Extract)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Cache != nil {
		w, err = wire.NewValueBool(*(v.Cache)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a MesosFetcherURI struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a MesosFetcherURI struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v MesosFetcherURI
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *MesosFetcherURI) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Value = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.Extract = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.Cache = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a MesosFetcherURI
// struct.
func (v *MesosFetcherURI) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Value != nil {
		fields[i] = fmt.Sprintf("Value: %v", *(v.Value))
		i++
	}
	if v.Extract != nil {
		fields[i] = fmt.Sprintf("Extract: %v", *(v.Extract))
		i++
	}
	if v.Cache != nil {
		fields[i] = fmt.Sprintf("Cache: %v", *(v.Cache))
		i++
	}

	return fmt.Sprintf("MesosFetcherURI{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this MesosFetcherURI match the
// provided MesosFetcherURI.
//
// This function performs a deep comparison.
func (v *MesosFetcherURI) Equals(rhs *MesosFetcherURI) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Value, rhs.Value) {
		return false
	}
	if !_Bool_EqualsPtr(v.Extract, rhs.Extract) {
		return false
	}
	if !_Bool_EqualsPtr(v.Cache, rhs.Cache) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of MesosFetcherURI.
func (v *MesosFetcherURI) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Value != nil {
		enc.AddString("value", *v.Value)
	}
	if v.Extract != nil {
		enc.AddBool("extract", *v.Extract)
	}
	if v.Cache != nil {
		enc.AddBool("cache", *v.Cache)
	}
	return err
}

// GetValue returns the value of Value if it is set or its
// zero value if it is unset.
func (v *MesosFetcherURI) GetValue() (o string) {
	if v != nil && v.Value != nil {
		return *v.Value
	}

	return
}

// IsSetValue returns true if Value is not nil.
func (v *MesosFetcherURI) IsSetValue() bool {
	return v != nil && v.Value != nil
}

// GetExtract returns the value of Extract if it is set or its
// zero value if it is unset.
func (v *MesosFetcherURI) GetExtract() (o bool) {
	if v != nil && v.Extract != nil {
		return *v.Extract
	}

	return
}

// IsSetExtract returns true if Extract is not nil.
func (v *MesosFetcherURI) IsSetExtract() bool {
	return v != nil && v.Extract != nil
}

// GetCache returns the value of Cache if it is set or its
// zero value if it is unset.
func (v *MesosFetcherURI) GetCache() (o bool) {
	if v != nil && v.Cache != nil {
		return *v.Cache
	}

	return
}

// IsSetCache returns true if Cache is not nil.
func (v *MesosFetcherURI) IsSetCache() bool {
	return v != nil && v.Cache != nil
}

// Arbitrary key-value metadata to be included into TaskConfig.
type Metadata struct {
	Key   *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

// ToWire translates a Metadata struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Metadata) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Key != nil {
		w, err = wire.NewValueString(*(v.Key)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Value != nil {
		w, err = wire.NewValueString(*(v.Value)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Metadata struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Metadata struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Metadata
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Metadata) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Key = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Value = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Metadata
// struct.
func (v *Metadata) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Key != nil {
		fields[i] = fmt.Sprintf("Key: %v", *(v.Key))
		i++
	}
	if v.Value != nil {
		fields[i] = fmt.Sprintf("Value: %v", *(v.Value))
		i++
	}

	return fmt.Sprintf("Metadata{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Metadata match the
// provided Metadata.
//
// This function performs a deep comparison.
func (v *Metadata) Equals(rhs *Metadata) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Key, rhs.Key) {
		return false
	}
	if !_String_EqualsPtr(v.Value, rhs.Value) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Metadata.
func (v *Metadata) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Key != nil {
		enc.AddString("key", *v.Key)
	}
	if v.Value != nil {
		enc.AddString("value", *v.Value)
	}
	return err
}

// GetKey returns the value of Key if it is set or its
// zero value if it is unset.
func (v *Metadata) GetKey() (o string) {
	if v != nil && v.Key != nil {
		return *v.Key
	}

	return
}

// IsSetKey returns true if Key is not nil.
func (v *Metadata) IsSetKey() bool {
	return v != nil && v.Key != nil
}

// GetValue returns the value of Value if it is set or its
// zero value if it is unset.
func (v *Metadata) GetValue() (o string) {
	if v != nil && v.Value != nil {
		return *v.Value
	}

	return
}

// IsSetValue returns true if Value is not nil.
func (v *Metadata) IsSetValue() bool {
	return v != nil && v.Value != nil
}

// The mode for a volume mount
type Mode int32

const (
	// Read Write
	ModeRw Mode = 1
	// Read Only
	ModeRo Mode = 2
)

// Mode_Values returns all recognized values of Mode.
func Mode_Values() []Mode {
	return []Mode{
		ModeRw,
		ModeRo,
	}
}

// UnmarshalText tries to decode Mode from a byte slice
// containing its name.
//
//   var v Mode
//   err := v.UnmarshalText([]byte("RW"))
func (v *Mode) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "RW":
		*v = ModeRw
		return nil
	case "RO":
		*v = ModeRo
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "Mode", err)
		}
		*v = Mode(val)
		return nil
	}
}

// MarshalText encodes Mode to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v Mode) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 1:
		return []byte("RW"), nil
	case 2:
		return []byte("RO"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Mode.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v Mode) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 1:
		enc.AddString("name", "RW")
	case 2:
		enc.AddString("name", "RO")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v Mode) Ptr() *Mode {
	return &v
}

// ToWire translates Mode into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v Mode) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes Mode from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return Mode(0), err
//   }
//
//   var v Mode
//   if err := v.FromWire(x); err != nil {
//     return Mode(0), err
//   }
//   return v, nil
func (v *Mode) FromWire(w wire.Value) error {
	*v = (Mode)(w.GetI32())
	return nil
}

// String returns a readable string representation of Mode.
func (v Mode) String() string {
	w := int32(v)
	switch w {
	case 1:
		return "RW"
	case 2:
		return "RO"
	}
	return fmt.Sprintf("Mode(%d)", w)
}

// Equals returns true if this Mode value matches the provided
// value.
func (v Mode) Equals(rhs Mode) bool {
	return v == rhs
}

// MarshalJSON serializes Mode into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v Mode) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 1:
		return ([]byte)("\"RW\""), nil
	case 2:
		return ([]byte)("\"RO\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode Mode from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *Mode) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "Mode")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "Mode")
		}
		*v = (Mode)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "Mode")
	}
}

type Package struct {
	Role    *string `json:"role,omitempty"`
	Name    *string `json:"name,omitempty"`
	Version *int32  `json:"version,omitempty"`
}

// ToWire translates a Package struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Package) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Role != nil {
		w, err = wire.NewValueString(*(v.Role)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Version != nil {
		w, err = wire.NewValueI32(*(v.Version)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Package struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Package struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Package
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Package) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Role = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Version = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Package
// struct.
func (v *Package) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Role != nil {
		fields[i] = fmt.Sprintf("Role: %v", *(v.Role))
		i++
	}
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}

	return fmt.Sprintf("Package{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Package match the
// provided Package.
//
// This function performs a deep comparison.
func (v *Package) Equals(rhs *Package) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Role, rhs.Role) {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !_I32_EqualsPtr(v.Version, rhs.Version) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Package.
func (v *Package) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Role != nil {
		enc.AddString("role", *v.Role)
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.Version != nil {
		enc.AddInt32("version", *v.Version)
	}
	return err
}

// GetRole returns the value of Role if it is set or its
// zero value if it is unset.
func (v *Package) GetRole() (o string) {
	if v != nil && v.Role != nil {
		return *v.Role
	}

	return
}

// IsSetRole returns true if Role is not nil.
func (v *Package) IsSetRole() bool {
	return v != nil && v.Role != nil
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *Package) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *Package) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetVersion returns the value of Version if it is set or its
// zero value if it is unset.
func (v *Package) GetVersion() (o int32) {
	if v != nil && v.Version != nil {
		return *v.Version
	}

	return
}

// IsSetVersion returns true if Version is not nil.
func (v *Package) IsSetVersion() bool {
	return v != nil && v.Version != nil
}

type PendingReason struct {
	TaskId *string `json:"taskId,omitempty"`
	Reason *string `json:"reason,omitempty"`
}

// ToWire translates a PendingReason struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *PendingReason) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.TaskId != nil {
		w, err = wire.NewValueString(*(v.TaskId)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Reason != nil {
		w, err = wire.NewValueString(*(v.Reason)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a PendingReason struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a PendingReason struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v PendingReason
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *PendingReason) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.TaskId = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Reason = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a PendingReason
// struct.
func (v *PendingReason) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.TaskId != nil {
		fields[i] = fmt.Sprintf("TaskId: %v", *(v.TaskId))
		i++
	}
	if v.Reason != nil {
		fields[i] = fmt.Sprintf("Reason: %v", *(v.Reason))
		i++
	}

	return fmt.Sprintf("PendingReason{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this PendingReason match the
// provided PendingReason.
//
// This function performs a deep comparison.
func (v *PendingReason) Equals(rhs *PendingReason) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.TaskId, rhs.TaskId) {
		return false
	}
	if !_String_EqualsPtr(v.Reason, rhs.Reason) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of PendingReason.
func (v *PendingReason) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.TaskId != nil {
		enc.AddString("taskId", *v.TaskId)
	}
	if v.Reason != nil {
		enc.AddString("reason", *v.Reason)
	}
	return err
}

// GetTaskId returns the value of TaskId if it is set or its
// zero value if it is unset.
func (v *PendingReason) GetTaskId() (o string) {
	if v != nil && v.TaskId != nil {
		return *v.TaskId
	}

	return
}

// IsSetTaskId returns true if TaskId is not nil.
func (v *PendingReason) IsSetTaskId() bool {
	return v != nil && v.TaskId != nil
}

// GetReason returns the value of Reason if it is set or its
// zero value if it is unset.
func (v *PendingReason) GetReason() (o string) {
	if v != nil && v.Reason != nil {
		return *v.Reason
	}

	return
}

// IsSetReason returns true if Reason is not nil.
func (v *PendingReason) IsSetReason() bool {
	return v != nil && v.Reason != nil
}

type PopulateJobResult struct {
	TaskConfig *TaskConfig `json:"taskConfig,omitempty"`
}

// ToWire translates a PopulateJobResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *PopulateJobResult) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.TaskConfig != nil {
		w, err = v.TaskConfig.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a PopulateJobResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a PopulateJobResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v PopulateJobResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *PopulateJobResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.TaskConfig, err = _TaskConfig_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a PopulateJobResult
// struct.
func (v *PopulateJobResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.TaskConfig != nil {
		fields[i] = fmt.Sprintf("TaskConfig: %v", v.TaskConfig)
		i++
	}

	return fmt.Sprintf("PopulateJobResult{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this PopulateJobResult match the
// provided PopulateJobResult.
//
// This function performs a deep comparison.
func (v *PopulateJobResult) Equals(rhs *PopulateJobResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.TaskConfig == nil && rhs.TaskConfig == nil) || (v.TaskConfig != nil && rhs.TaskConfig != nil && v.TaskConfig.Equals(rhs.TaskConfig))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of PopulateJobResult.
func (v *PopulateJobResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.TaskConfig != nil {
		err = multierr.Append(err, enc.AddObject("taskConfig", v.TaskConfig))
	}
	return err
}

// GetTaskConfig returns the value of TaskConfig if it is set or its
// zero value if it is unset.
func (v *PopulateJobResult) GetTaskConfig() (o *TaskConfig) {
	if v != nil && v.TaskConfig != nil {
		return v.TaskConfig
	}

	return
}

// IsSetTaskConfig returns true if TaskConfig is not nil.
func (v *PopulateJobResult) IsSetTaskConfig() bool {
	return v != nil && v.TaskConfig != nil
}

// Result of the pulseJobUpdate call.
type PulseJobUpdateResult struct {
	Status *JobUpdatePulseStatus `json:"status,omitempty"`
}

// ToWire translates a PulseJobUpdateResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *PulseJobUpdateResult) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Status != nil {
		w, err = v.Status.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _JobUpdatePulseStatus_Read(w wire.Value) (JobUpdatePulseStatus, error) {
	var v JobUpdatePulseStatus
	err := v.FromWire(w)
	return v, err
}

// FromWire deserializes a PulseJobUpdateResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a PulseJobUpdateResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v PulseJobUpdateResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *PulseJobUpdateResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x JobUpdatePulseStatus
				x, err = _JobUpdatePulseStatus_Read(field.Value)
				v.Status = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a PulseJobUpdateResult
// struct.
func (v *PulseJobUpdateResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Status != nil {
		fields[i] = fmt.Sprintf("Status: %v", *(v.Status))
		i++
	}

	return fmt.Sprintf("PulseJobUpdateResult{%v}", strings.Join(fields[:i], ", "))
}

func _JobUpdatePulseStatus_EqualsPtr(lhs, rhs *JobUpdatePulseStatus) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this PulseJobUpdateResult match the
// provided PulseJobUpdateResult.
//
// This function performs a deep comparison.
func (v *PulseJobUpdateResult) Equals(rhs *PulseJobUpdateResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_JobUpdatePulseStatus_EqualsPtr(v.Status, rhs.Status) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of PulseJobUpdateResult.
func (v *PulseJobUpdateResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Status != nil {
		err = multierr.Append(err, enc.AddObject("status", *v.Status))
	}
	return err
}

// GetStatus returns the value of Status if it is set or its
// zero value if it is unset.
func (v *PulseJobUpdateResult) GetStatus() (o JobUpdatePulseStatus) {
	if v != nil && v.Status != nil {
		return *v.Status
	}

	return
}

// IsSetStatus returns true if Status is not nil.
func (v *PulseJobUpdateResult) IsSetStatus() bool {
	return v != nil && v.Status != nil
}

type QueryRecoveryResult struct {
	Tasks []*ScheduledTask `json:"tasks,omitempty"`
}

type _Set_ScheduledTask_sliceType_ValueList []*ScheduledTask

func (v _Set_ScheduledTask_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_ScheduledTask_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_ScheduledTask_sliceType_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_ScheduledTask_sliceType_ValueList) Close() {}

// ToWire translates a QueryRecoveryResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *QueryRecoveryResult) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Tasks != nil {
		w, err = wire.NewValueSet(_Set_ScheduledTask_sliceType_ValueList(v.Tasks)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ScheduledTask_Read(w wire.Value) (*ScheduledTask, error) {
	var v ScheduledTask
	err := v.FromWire(w)
	return &v, err
}

func _Set_ScheduledTask_sliceType_Read(s wire.ValueList) ([]*ScheduledTask, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*ScheduledTask, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _ScheduledTask_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

// FromWire deserializes a QueryRecoveryResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a QueryRecoveryResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v QueryRecoveryResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *QueryRecoveryResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TSet {
				v.Tasks, err = _Set_ScheduledTask_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a QueryRecoveryResult
// struct.
func (v *QueryRecoveryResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Tasks != nil {
		fields[i] = fmt.Sprintf("Tasks: %v", v.Tasks)
		i++
	}

	return fmt.Sprintf("QueryRecoveryResult{%v}", strings.Join(fields[:i], ", "))
}

func _Set_ScheduledTask_sliceType_Equals(lhs, rhs []*ScheduledTask) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this QueryRecoveryResult match the
// provided QueryRecoveryResult.
//
// This function performs a deep comparison.
func (v *QueryRecoveryResult) Equals(rhs *QueryRecoveryResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Tasks == nil && rhs.Tasks == nil) || (v.Tasks != nil && rhs.Tasks != nil && _Set_ScheduledTask_sliceType_Equals(v.Tasks, rhs.Tasks))) {
		return false
	}

	return true
}

type _Set_ScheduledTask_sliceType_Zapper []*ScheduledTask

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_ScheduledTask_sliceType_Zapper.
func (s _Set_ScheduledTask_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of QueryRecoveryResult.
func (v *QueryRecoveryResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Tasks != nil {
		err = multierr.Append(err, enc.AddArray("tasks", (_Set_ScheduledTask_sliceType_Zapper)(v.Tasks)))
	}
	return err
}

// GetTasks returns the value of Tasks if it is set or its
// zero value if it is unset.
func (v *QueryRecoveryResult) GetTasks() (o []*ScheduledTask) {
	if v != nil && v.Tasks != nil {
		return v.Tasks
	}

	return
}

// IsSetTasks returns true if Tasks is not nil.
func (v *QueryRecoveryResult) IsSetTasks() bool {
	return v != nil && v.Tasks != nil
}

// Closed range of integers.
type Range struct {
	First *int32 `json:"first,omitempty"`
	Last  *int32 `json:"last,omitempty"`
}

// ToWire translates a Range struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Range) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.First != nil {
		w, err = wire.NewValueI32(*(v.First)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Last != nil {
		w, err = wire.NewValueI32(*(v.Last)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Range struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Range struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Range
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Range) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.First = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Last = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Range
// struct.
func (v *Range) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.First != nil {
		fields[i] = fmt.Sprintf("First: %v", *(v.First))
		i++
	}
	if v.Last != nil {
		fields[i] = fmt.Sprintf("Last: %v", *(v.Last))
		i++
	}

	return fmt.Sprintf("Range{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Range match the
// provided Range.
//
// This function performs a deep comparison.
func (v *Range) Equals(rhs *Range) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.First, rhs.First) {
		return false
	}
	if !_I32_EqualsPtr(v.Last, rhs.Last) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Range.
func (v *Range) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.First != nil {
		enc.AddInt32("first", *v.First)
	}
	if v.Last != nil {
		enc.AddInt32("last", *v.Last)
	}
	return err
}

// GetFirst returns the value of First if it is set or its
// zero value if it is unset.
func (v *Range) GetFirst() (o int32) {
	if v != nil && v.First != nil {
		return *v.First
	}

	return
}

// IsSetFirst returns true if First is not nil.
func (v *Range) IsSetFirst() bool {
	return v != nil && v.First != nil
}

// GetLast returns the value of Last if it is set or its
// zero value if it is unset.
func (v *Range) GetLast() (o int32) {
	if v != nil && v.Last != nil {
		return *v.Last
	}

	return
}

// IsSetLast returns true if Last is not nil.
func (v *Range) IsSetLast() bool {
	return v != nil && v.Last != nil
}

// Describes resource value required to run a task.
type Resource struct {
	NumCpus   *float64 `json:"numCpus,omitempty"`
	RamMb     *int64   `json:"ramMb,omitempty"`
	DiskMb    *int64   `json:"diskMb,omitempty"`
	NamedPort *string  `json:"namedPort,omitempty"`
	NumGpus   *int64   `json:"numGpus,omitempty"`
}

// ToWire translates a Resource struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Resource) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.NumCpus != nil {
		w, err = wire.NewValueDouble(*(v.NumCpus)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.RamMb != nil {
		w, err = wire.NewValueI64(*(v.RamMb)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.DiskMb != nil {
		w, err = wire.NewValueI64(*(v.DiskMb)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.NamedPort != nil {
		w, err = wire.NewValueString(*(v.NamedPort)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.NumGpus != nil {
		w, err = wire.NewValueI64(*(v.NumGpus)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Resource should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Resource struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Resource struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Resource
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Resource) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.NumCpus = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.RamMb = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.DiskMb = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.NamedPort = &x
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.NumGpus = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.NumCpus != nil {
		count++
	}
	if v.RamMb != nil {
		count++
	}
	if v.DiskMb != nil {
		count++
	}
	if v.NamedPort != nil {
		count++
	}
	if v.NumGpus != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Resource should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Resource
// struct.
func (v *Resource) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [5]string
	i := 0
	if v.NumCpus != nil {
		fields[i] = fmt.Sprintf("NumCpus: %v", *(v.NumCpus))
		i++
	}
	if v.RamMb != nil {
		fields[i] = fmt.Sprintf("RamMb: %v", *(v.RamMb))
		i++
	}
	if v.DiskMb != nil {
		fields[i] = fmt.Sprintf("DiskMb: %v", *(v.DiskMb))
		i++
	}
	if v.NamedPort != nil {
		fields[i] = fmt.Sprintf("NamedPort: %v", *(v.NamedPort))
		i++
	}
	if v.NumGpus != nil {
		fields[i] = fmt.Sprintf("NumGpus: %v", *(v.NumGpus))
		i++
	}

	return fmt.Sprintf("Resource{%v}", strings.Join(fields[:i], ", "))
}

func _Double_EqualsPtr(lhs, rhs *float64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this Resource match the
// provided Resource.
//
// This function performs a deep comparison.
func (v *Resource) Equals(rhs *Resource) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Double_EqualsPtr(v.NumCpus, rhs.NumCpus) {
		return false
	}
	if !_I64_EqualsPtr(v.RamMb, rhs.RamMb) {
		return false
	}
	if !_I64_EqualsPtr(v.DiskMb, rhs.DiskMb) {
		return false
	}
	if !_String_EqualsPtr(v.NamedPort, rhs.NamedPort) {
		return false
	}
	if !_I64_EqualsPtr(v.NumGpus, rhs.NumGpus) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Resource.
func (v *Resource) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.NumCpus != nil {
		enc.AddFloat64("numCpus", *v.NumCpus)
	}
	if v.RamMb != nil {
		enc.AddInt64("ramMb", *v.RamMb)
	}
	if v.DiskMb != nil {
		enc.AddInt64("diskMb", *v.DiskMb)
	}
	if v.NamedPort != nil {
		enc.AddString("namedPort", *v.NamedPort)
	}
	if v.NumGpus != nil {
		enc.AddInt64("numGpus", *v.NumGpus)
	}
	return err
}

// GetNumCpus returns the value of NumCpus if it is set or its
// zero value if it is unset.
func (v *Resource) GetNumCpus() (o float64) {
	if v != nil && v.NumCpus != nil {
		return *v.NumCpus
	}

	return
}

// IsSetNumCpus returns true if NumCpus is not nil.
func (v *Resource) IsSetNumCpus() bool {
	return v != nil && v.NumCpus != nil
}

// GetRamMb returns the value of RamMb if it is set or its
// zero value if it is unset.
func (v *Resource) GetRamMb() (o int64) {
	if v != nil && v.RamMb != nil {
		return *v.RamMb
	}

	return
}

// IsSetRamMb returns true if RamMb is not nil.
func (v *Resource) IsSetRamMb() bool {
	return v != nil && v.RamMb != nil
}

// GetDiskMb returns the value of DiskMb if it is set or its
// zero value if it is unset.
func (v *Resource) GetDiskMb() (o int64) {
	if v != nil && v.DiskMb != nil {
		return *v.DiskMb
	}

	return
}

// IsSetDiskMb returns true if DiskMb is not nil.
func (v *Resource) IsSetDiskMb() bool {
	return v != nil && v.DiskMb != nil
}

// GetNamedPort returns the value of NamedPort if it is set or its
// zero value if it is unset.
func (v *Resource) GetNamedPort() (o string) {
	if v != nil && v.NamedPort != nil {
		return *v.NamedPort
	}

	return
}

// IsSetNamedPort returns true if NamedPort is not nil.
func (v *Resource) IsSetNamedPort() bool {
	return v != nil && v.NamedPort != nil
}

// GetNumGpus returns the value of NumGpus if it is set or its
// zero value if it is unset.
func (v *Resource) GetNumGpus() (o int64) {
	if v != nil && v.NumGpus != nil {
		return *v.NumGpus
	}

	return
}

// IsSetNumGpus returns true if NumGpus is not nil.
func (v *Resource) IsSetNumGpus() bool {
	return v != nil && v.NumGpus != nil
}

type ResourceAggregate struct {
	// Number of CPU cores allotted.
	NumCpus *float64 `json:"numCpus,omitempty"`
	// Megabytes of RAM allotted.
	RamMb *int64 `json:"ramMb,omitempty"`
	// Megabytes of disk space allotted.
	DiskMb *int64 `json:"diskMb,omitempty"`
	// Aggregated resource values.
	Resources []*Resource `json:"resources,omitempty"`
}

type _Set_Resource_sliceType_ValueList []*Resource

func (v _Set_Resource_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_Resource_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_Resource_sliceType_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_Resource_sliceType_ValueList) Close() {}

// ToWire translates a ResourceAggregate struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ResourceAggregate) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.NumCpus != nil {
		w, err = wire.NewValueDouble(*(v.NumCpus)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.RamMb != nil {
		w, err = wire.NewValueI64(*(v.RamMb)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.DiskMb != nil {
		w, err = wire.NewValueI64(*(v.DiskMb)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Resources != nil {
		w, err = wire.NewValueSet(_Set_Resource_sliceType_ValueList(v.Resources)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Resource_Read(w wire.Value) (*Resource, error) {
	var v Resource
	err := v.FromWire(w)
	return &v, err
}

func _Set_Resource_sliceType_Read(s wire.ValueList) ([]*Resource, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Resource, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _Resource_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

// FromWire deserializes a ResourceAggregate struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ResourceAggregate struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ResourceAggregate
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ResourceAggregate) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.NumCpus = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.RamMb = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.DiskMb = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TSet {
				v.Resources, err = _Set_Resource_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ResourceAggregate
// struct.
func (v *ResourceAggregate) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.NumCpus != nil {
		fields[i] = fmt.Sprintf("NumCpus: %v", *(v.NumCpus))
		i++
	}
	if v.RamMb != nil {
		fields[i] = fmt.Sprintf("RamMb: %v", *(v.RamMb))
		i++
	}
	if v.DiskMb != nil {
		fields[i] = fmt.Sprintf("DiskMb: %v", *(v.DiskMb))
		i++
	}
	if v.Resources != nil {
		fields[i] = fmt.Sprintf("Resources: %v", v.Resources)
		i++
	}

	return fmt.Sprintf("ResourceAggregate{%v}", strings.Join(fields[:i], ", "))
}

func _Set_Resource_sliceType_Equals(lhs, rhs []*Resource) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this ResourceAggregate match the
// provided ResourceAggregate.
//
// This function performs a deep comparison.
func (v *ResourceAggregate) Equals(rhs *ResourceAggregate) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Double_EqualsPtr(v.NumCpus, rhs.NumCpus) {
		return false
	}
	if !_I64_EqualsPtr(v.RamMb, rhs.RamMb) {
		return false
	}
	if !_I64_EqualsPtr(v.DiskMb, rhs.DiskMb) {
		return false
	}
	if !((v.Resources == nil && rhs.Resources == nil) || (v.Resources != nil && rhs.Resources != nil && _Set_Resource_sliceType_Equals(v.Resources, rhs.Resources))) {
		return false
	}

	return true
}

type _Set_Resource_sliceType_Zapper []*Resource

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_Resource_sliceType_Zapper.
func (s _Set_Resource_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ResourceAggregate.
func (v *ResourceAggregate) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.NumCpus != nil {
		enc.AddFloat64("numCpus", *v.NumCpus)
	}
	if v.RamMb != nil {
		enc.AddInt64("ramMb", *v.RamMb)
	}
	if v.DiskMb != nil {
		enc.AddInt64("diskMb", *v.DiskMb)
	}
	if v.Resources != nil {
		err = multierr.Append(err, enc.AddArray("resources", (_Set_Resource_sliceType_Zapper)(v.Resources)))
	}
	return err
}

// GetNumCpus returns the value of NumCpus if it is set or its
// zero value if it is unset.
func (v *ResourceAggregate) GetNumCpus() (o float64) {
	if v != nil && v.NumCpus != nil {
		return *v.NumCpus
	}

	return
}

// IsSetNumCpus returns true if NumCpus is not nil.
func (v *ResourceAggregate) IsSetNumCpus() bool {
	return v != nil && v.NumCpus != nil
}

// GetRamMb returns the value of RamMb if it is set or its
// zero value if it is unset.
func (v *ResourceAggregate) GetRamMb() (o int64) {
	if v != nil && v.RamMb != nil {
		return *v.RamMb
	}

	return
}

// IsSetRamMb returns true if RamMb is not nil.
func (v *ResourceAggregate) IsSetRamMb() bool {
	return v != nil && v.RamMb != nil
}

// GetDiskMb returns the value of DiskMb if it is set or its
// zero value if it is unset.
func (v *ResourceAggregate) GetDiskMb() (o int64) {
	if v != nil && v.DiskMb != nil {
		return *v.DiskMb
	}

	return
}

// IsSetDiskMb returns true if DiskMb is not nil.
func (v *ResourceAggregate) IsSetDiskMb() bool {
	return v != nil && v.DiskMb != nil
}

// GetResources returns the value of Resources if it is set or its
// zero value if it is unset.
func (v *ResourceAggregate) GetResources() (o []*Resource) {
	if v != nil && v.Resources != nil {
		return v.Resources
	}

	return
}

// IsSetResources returns true if Resources is not nil.
func (v *ResourceAggregate) IsSetResources() bool {
	return v != nil && v.Resources != nil
}

type Response struct {
	ResponseCode *ResponseCode `json:"responseCode,omitempty"`
	ServerInfo   *ServerInfo   `json:"serverInfo,omitempty"`
	// Payload from the invoked RPC.
	Result *Result `json:"result,omitempty"`
	// Messages from the server relevant to the request, such as warnings or use of deprecated
	// features.
	Details []*ResponseDetail `json:"details,omitempty"`
}

type _List_ResponseDetail_ValueList []*ResponseDetail

func (v _List_ResponseDetail_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_ResponseDetail_ValueList) Size() int {
	return len(v)
}

func (_List_ResponseDetail_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_ResponseDetail_ValueList) Close() {}

// ToWire translates a Response struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Response) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ResponseCode != nil {
		w, err = v.ResponseCode.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ServerInfo != nil {
		w, err = v.ServerInfo.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.Result != nil {
		w, err = v.Result.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Details != nil {
		w, err = wire.NewValueList(_List_ResponseDetail_ValueList(v.Details)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ResponseCode_Read(w wire.Value) (ResponseCode, error) {
	var v ResponseCode
	err := v.FromWire(w)
	return v, err
}

func _ServerInfo_Read(w wire.Value) (*ServerInfo, error) {
	var v ServerInfo
	err := v.FromWire(w)
	return &v, err
}

func _Result_Read(w wire.Value) (*Result, error) {
	var v Result
	err := v.FromWire(w)
	return &v, err
}

func _ResponseDetail_Read(w wire.Value) (*ResponseDetail, error) {
	var v ResponseDetail
	err := v.FromWire(w)
	return &v, err
}

func _List_ResponseDetail_Read(l wire.ValueList) ([]*ResponseDetail, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*ResponseDetail, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _ResponseDetail_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a Response struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Response struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Response
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Response) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x ResponseCode
				x, err = _ResponseCode_Read(field.Value)
				v.ResponseCode = &x
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TStruct {
				v.ServerInfo, err = _ServerInfo_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.Result, err = _Result_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TList {
				v.Details, err = _List_ResponseDetail_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Response
// struct.
func (v *Response) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.ResponseCode != nil {
		fields[i] = fmt.Sprintf("ResponseCode: %v", *(v.ResponseCode))
		i++
	}
	if v.ServerInfo != nil {
		fields[i] = fmt.Sprintf("ServerInfo: %v", v.ServerInfo)
		i++
	}
	if v.Result != nil {
		fields[i] = fmt.Sprintf("Result: %v", v.Result)
		i++
	}
	if v.Details != nil {
		fields[i] = fmt.Sprintf("Details: %v", v.Details)
		i++
	}

	return fmt.Sprintf("Response{%v}", strings.Join(fields[:i], ", "))
}

func _ResponseCode_EqualsPtr(lhs, rhs *ResponseCode) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

func _List_ResponseDetail_Equals(lhs, rhs []*ResponseDetail) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this Response match the
// provided Response.
//
// This function performs a deep comparison.
func (v *Response) Equals(rhs *Response) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_ResponseCode_EqualsPtr(v.ResponseCode, rhs.ResponseCode) {
		return false
	}
	if !((v.ServerInfo == nil && rhs.ServerInfo == nil) || (v.ServerInfo != nil && rhs.ServerInfo != nil && v.ServerInfo.Equals(rhs.ServerInfo))) {
		return false
	}
	if !((v.Result == nil && rhs.Result == nil) || (v.Result != nil && rhs.Result != nil && v.Result.Equals(rhs.Result))) {
		return false
	}
	if !((v.Details == nil && rhs.Details == nil) || (v.Details != nil && rhs.Details != nil && _List_ResponseDetail_Equals(v.Details, rhs.Details))) {
		return false
	}

	return true
}

type _List_ResponseDetail_Zapper []*ResponseDetail

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_ResponseDetail_Zapper.
func (l _List_ResponseDetail_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Response.
func (v *Response) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ResponseCode != nil {
		err = multierr.Append(err, enc.AddObject("responseCode", *v.ResponseCode))
	}
	if v.ServerInfo != nil {
		err = multierr.Append(err, enc.AddObject("serverInfo", v.ServerInfo))
	}
	if v.Result != nil {
		err = multierr.Append(err, enc.AddObject("result", v.Result))
	}
	if v.Details != nil {
		err = multierr.Append(err, enc.AddArray("details", (_List_ResponseDetail_Zapper)(v.Details)))
	}
	return err
}

// GetResponseCode returns the value of ResponseCode if it is set or its
// zero value if it is unset.
func (v *Response) GetResponseCode() (o ResponseCode) {
	if v != nil && v.ResponseCode != nil {
		return *v.ResponseCode
	}

	return
}

// IsSetResponseCode returns true if ResponseCode is not nil.
func (v *Response) IsSetResponseCode() bool {
	return v != nil && v.ResponseCode != nil
}

// GetServerInfo returns the value of ServerInfo if it is set or its
// zero value if it is unset.
func (v *Response) GetServerInfo() (o *ServerInfo) {
	if v != nil && v.ServerInfo != nil {
		return v.ServerInfo
	}

	return
}

// IsSetServerInfo returns true if ServerInfo is not nil.
func (v *Response) IsSetServerInfo() bool {
	return v != nil && v.ServerInfo != nil
}

// GetResult returns the value of Result if it is set or its
// zero value if it is unset.
func (v *Response) GetResult() (o *Result) {
	if v != nil && v.Result != nil {
		return v.Result
	}

	return
}

// IsSetResult returns true if Result is not nil.
func (v *Response) IsSetResult() bool {
	return v != nil && v.Result != nil
}

// GetDetails returns the value of Details if it is set or its
// zero value if it is unset.
func (v *Response) GetDetails() (o []*ResponseDetail) {
	if v != nil && v.Details != nil {
		return v.Details
	}

	return
}

// IsSetDetails returns true if Details is not nil.
func (v *Response) IsSetDetails() bool {
	return v != nil && v.Details != nil
}

type ResponseCode int32

const (
	ResponseCodeInvalidRequest ResponseCode = 0
	ResponseCodeOk             ResponseCode = 1
	ResponseCodeError          ResponseCode = 2
	ResponseCodeWarning        ResponseCode = 3
	ResponseCodeAuthFailed     ResponseCode = 4
	// Raised when an operation was unable to proceed due to an in-progress job update.
	ResponseCodeJobUpdatingError ResponseCode = 5
	// Raised when a scheduler is transiently unavailable and later retry is recommended.
	ResponseCodeErrorTransient ResponseCode = 6
)

// ResponseCode_Values returns all recognized values of ResponseCode.
func ResponseCode_Values() []ResponseCode {
	return []ResponseCode{
		ResponseCodeInvalidRequest,
		ResponseCodeOk,
		ResponseCodeError,
		ResponseCodeWarning,
		ResponseCodeAuthFailed,
		ResponseCodeJobUpdatingError,
		ResponseCodeErrorTransient,
	}
}

// UnmarshalText tries to decode ResponseCode from a byte slice
// containing its name.
//
//   var v ResponseCode
//   err := v.UnmarshalText([]byte("INVALID_REQUEST"))
func (v *ResponseCode) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "INVALID_REQUEST":
		*v = ResponseCodeInvalidRequest
		return nil
	case "OK":
		*v = ResponseCodeOk
		return nil
	case "ERROR":
		*v = ResponseCodeError
		return nil
	case "WARNING":
		*v = ResponseCodeWarning
		return nil
	case "AUTH_FAILED":
		*v = ResponseCodeAuthFailed
		return nil
	case "JOB_UPDATING_ERROR":
		*v = ResponseCodeJobUpdatingError
		return nil
	case "ERROR_TRANSIENT":
		*v = ResponseCodeErrorTransient
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "ResponseCode", err)
		}
		*v = ResponseCode(val)
		return nil
	}
}

// MarshalText encodes ResponseCode to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v ResponseCode) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("INVALID_REQUEST"), nil
	case 1:
		return []byte("OK"), nil
	case 2:
		return []byte("ERROR"), nil
	case 3:
		return []byte("WARNING"), nil
	case 4:
		return []byte("AUTH_FAILED"), nil
	case 5:
		return []byte("JOB_UPDATING_ERROR"), nil
	case 6:
		return []byte("ERROR_TRANSIENT"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ResponseCode.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v ResponseCode) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "INVALID_REQUEST")
	case 1:
		enc.AddString("name", "OK")
	case 2:
		enc.AddString("name", "ERROR")
	case 3:
		enc.AddString("name", "WARNING")
	case 4:
		enc.AddString("name", "AUTH_FAILED")
	case 5:
		enc.AddString("name", "JOB_UPDATING_ERROR")
	case 6:
		enc.AddString("name", "ERROR_TRANSIENT")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v ResponseCode) Ptr() *ResponseCode {
	return &v
}

// ToWire translates ResponseCode into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v ResponseCode) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes ResponseCode from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return ResponseCode(0), err
//   }
//
//   var v ResponseCode
//   if err := v.FromWire(x); err != nil {
//     return ResponseCode(0), err
//   }
//   return v, nil
func (v *ResponseCode) FromWire(w wire.Value) error {
	*v = (ResponseCode)(w.GetI32())
	return nil
}

// String returns a readable string representation of ResponseCode.
func (v ResponseCode) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "INVALID_REQUEST"
	case 1:
		return "OK"
	case 2:
		return "ERROR"
	case 3:
		return "WARNING"
	case 4:
		return "AUTH_FAILED"
	case 5:
		return "JOB_UPDATING_ERROR"
	case 6:
		return "ERROR_TRANSIENT"
	}
	return fmt.Sprintf("ResponseCode(%d)", w)
}

// Equals returns true if this ResponseCode value matches the provided
// value.
func (v ResponseCode) Equals(rhs ResponseCode) bool {
	return v == rhs
}

// MarshalJSON serializes ResponseCode into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v ResponseCode) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"INVALID_REQUEST\""), nil
	case 1:
		return ([]byte)("\"OK\""), nil
	case 2:
		return ([]byte)("\"ERROR\""), nil
	case 3:
		return ([]byte)("\"WARNING\""), nil
	case 4:
		return ([]byte)("\"AUTH_FAILED\""), nil
	case 5:
		return ([]byte)("\"JOB_UPDATING_ERROR\""), nil
	case 6:
		return ([]byte)("\"ERROR_TRANSIENT\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode ResponseCode from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *ResponseCode) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "ResponseCode")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "ResponseCode")
		}
		*v = (ResponseCode)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "ResponseCode")
	}
}

type ResponseDetail struct {
	Message *string `json:"message,omitempty"`
}

// ToWire translates a ResponseDetail struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ResponseDetail) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ResponseDetail struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ResponseDetail struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ResponseDetail
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ResponseDetail) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ResponseDetail
// struct.
func (v *ResponseDetail) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}

	return fmt.Sprintf("ResponseDetail{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ResponseDetail match the
// provided ResponseDetail.
//
// This function performs a deep comparison.
func (v *ResponseDetail) Equals(rhs *ResponseDetail) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Message, rhs.Message) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ResponseDetail.
func (v *ResponseDetail) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Message != nil {
		enc.AddString("message", *v.Message)
	}
	return err
}

// GetMessage returns the value of Message if it is set or its
// zero value if it is unset.
func (v *ResponseDetail) GetMessage() (o string) {
	if v != nil && v.Message != nil {
		return *v.Message
	}

	return
}

// IsSetMessage returns true if Message is not nil.
func (v *ResponseDetail) IsSetMessage() bool {
	return v != nil && v.Message != nil
}

type Result struct {
	PopulateJobResult           *PopulateJobResult           `json:"populateJobResult,omitempty"`
	ScheduleStatusResult        *ScheduleStatusResult        `json:"scheduleStatusResult,omitempty"`
	GetJobsResult               *GetJobsResult               `json:"getJobsResult,omitempty"`
	GetQuotaResult              *GetQuotaResult              `json:"getQuotaResult,omitempty"`
	ListBackupsResult           *ListBackupsResult           `json:"listBackupsResult,omitempty"`
	StartMaintenanceResult      *StartMaintenanceResult      `json:"startMaintenanceResult,omitempty"`
	DrainHostsResult            *DrainHostsResult            `json:"drainHostsResult,omitempty"`
	QueryRecoveryResult         *QueryRecoveryResult         `json:"queryRecoveryResult,omitempty"`
	MaintenanceStatusResult     *MaintenanceStatusResult     `json:"maintenanceStatusResult,omitempty"`
	EndMaintenanceResult        *EndMaintenanceResult        `json:"endMaintenanceResult,omitempty"`
	RoleSummaryResult           *RoleSummaryResult           `json:"roleSummaryResult,omitempty"`
	JobSummaryResult            *JobSummaryResult            `json:"jobSummaryResult,omitempty"`
	ConfigSummaryResult         *ConfigSummaryResult         `json:"configSummaryResult,omitempty"`
	GetPendingReasonResult      *GetPendingReasonResult      `json:"getPendingReasonResult,omitempty"`
	StartJobUpdateResult        *StartJobUpdateResult        `json:"startJobUpdateResult,omitempty"`
	GetJobUpdateSummariesResult *GetJobUpdateSummariesResult `json:"getJobUpdateSummariesResult,omitempty"`
	GetJobUpdateDetailsResult   *GetJobUpdateDetailsResult   `json:"getJobUpdateDetailsResult,omitempty"`
	PulseJobUpdateResult        *PulseJobUpdateResult        `json:"pulseJobUpdateResult,omitempty"`
	GetJobUpdateDiffResult      *GetJobUpdateDiffResult      `json:"getJobUpdateDiffResult,omitempty"`
	GetTierConfigResult         *GetTierConfigResult         `json:"getTierConfigResult,omitempty"`
}

// ToWire translates a Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Result) ToWire() (wire.Value, error) {
	var (
		fields [20]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.PopulateJobResult != nil {
		w, err = v.PopulateJobResult.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ScheduleStatusResult != nil {
		w, err = v.ScheduleStatusResult.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.GetJobsResult != nil {
		w, err = v.GetJobsResult.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.GetQuotaResult != nil {
		w, err = v.GetQuotaResult.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.ListBackupsResult != nil {
		w, err = v.ListBackupsResult.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	if v.StartMaintenanceResult != nil {
		w, err = v.StartMaintenanceResult.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}
	if v.DrainHostsResult != nil {
		w, err = v.DrainHostsResult.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 8, Value: w}
		i++
	}
	if v.QueryRecoveryResult != nil {
		w, err = v.QueryRecoveryResult.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 9, Value: w}
		i++
	}
	if v.MaintenanceStatusResult != nil {
		w, err = v.MaintenanceStatusResult.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.EndMaintenanceResult != nil {
		w, err = v.EndMaintenanceResult.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 11, Value: w}
		i++
	}
	if v.RoleSummaryResult != nil {
		w, err = v.RoleSummaryResult.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 17, Value: w}
		i++
	}
	if v.JobSummaryResult != nil {
		w, err = v.JobSummaryResult.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 18, Value: w}
		i++
	}
	if v.ConfigSummaryResult != nil {
		w, err = v.ConfigSummaryResult.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.GetPendingReasonResult != nil {
		w, err = v.GetPendingReasonResult.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 21, Value: w}
		i++
	}
	if v.StartJobUpdateResult != nil {
		w, err = v.StartJobUpdateResult.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 22, Value: w}
		i++
	}
	if v.GetJobUpdateSummariesResult != nil {
		w, err = v.GetJobUpdateSummariesResult.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 23, Value: w}
		i++
	}
	if v.GetJobUpdateDetailsResult != nil {
		w, err = v.GetJobUpdateDetailsResult.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 24, Value: w}
		i++
	}
	if v.PulseJobUpdateResult != nil {
		w, err = v.PulseJobUpdateResult.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 25, Value: w}
		i++
	}
	if v.GetJobUpdateDiffResult != nil {
		w, err = v.GetJobUpdateDiffResult.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 26, Value: w}
		i++
	}
	if v.GetTierConfigResult != nil {
		w, err = v.GetTierConfigResult.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 27, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _PopulateJobResult_Read(w wire.Value) (*PopulateJobResult, error) {
	var v PopulateJobResult
	err := v.FromWire(w)
	return &v, err
}

func _ScheduleStatusResult_Read(w wire.Value) (*ScheduleStatusResult, error) {
	var v ScheduleStatusResult
	err := v.FromWire(w)
	return &v, err
}

func _GetJobsResult_Read(w wire.Value) (*GetJobsResult, error) {
	var v GetJobsResult
	err := v.FromWire(w)
	return &v, err
}

func _GetQuotaResult_Read(w wire.Value) (*GetQuotaResult, error) {
	var v GetQuotaResult
	err := v.FromWire(w)
	return &v, err
}

func _ListBackupsResult_Read(w wire.Value) (*ListBackupsResult, error) {
	var v ListBackupsResult
	err := v.FromWire(w)
	return &v, err
}

func _StartMaintenanceResult_Read(w wire.Value) (*StartMaintenanceResult, error) {
	var v StartMaintenanceResult
	err := v.FromWire(w)
	return &v, err
}

func _DrainHostsResult_Read(w wire.Value) (*DrainHostsResult, error) {
	var v DrainHostsResult
	err := v.FromWire(w)
	return &v, err
}

func _QueryRecoveryResult_Read(w wire.Value) (*QueryRecoveryResult, error) {
	var v QueryRecoveryResult
	err := v.FromWire(w)
	return &v, err
}

func _MaintenanceStatusResult_Read(w wire.Value) (*MaintenanceStatusResult, error) {
	var v MaintenanceStatusResult
	err := v.FromWire(w)
	return &v, err
}

func _EndMaintenanceResult_Read(w wire.Value) (*EndMaintenanceResult, error) {
	var v EndMaintenanceResult
	err := v.FromWire(w)
	return &v, err
}

func _RoleSummaryResult_Read(w wire.Value) (*RoleSummaryResult, error) {
	var v RoleSummaryResult
	err := v.FromWire(w)
	return &v, err
}

func _JobSummaryResult_Read(w wire.Value) (*JobSummaryResult, error) {
	var v JobSummaryResult
	err := v.FromWire(w)
	return &v, err
}

func _ConfigSummaryResult_Read(w wire.Value) (*ConfigSummaryResult, error) {
	var v ConfigSummaryResult
	err := v.FromWire(w)
	return &v, err
}

func _GetPendingReasonResult_Read(w wire.Value) (*GetPendingReasonResult, error) {
	var v GetPendingReasonResult
	err := v.FromWire(w)
	return &v, err
}

func _StartJobUpdateResult_Read(w wire.Value) (*StartJobUpdateResult, error) {
	var v StartJobUpdateResult
	err := v.FromWire(w)
	return &v, err
}

func _GetJobUpdateSummariesResult_Read(w wire.Value) (*GetJobUpdateSummariesResult, error) {
	var v GetJobUpdateSummariesResult
	err := v.FromWire(w)
	return &v, err
}

func _GetJobUpdateDetailsResult_Read(w wire.Value) (*GetJobUpdateDetailsResult, error) {
	var v GetJobUpdateDetailsResult
	err := v.FromWire(w)
	return &v, err
}

func _PulseJobUpdateResult_Read(w wire.Value) (*PulseJobUpdateResult, error) {
	var v PulseJobUpdateResult
	err := v.FromWire(w)
	return &v, err
}

func _GetJobUpdateDiffResult_Read(w wire.Value) (*GetJobUpdateDiffResult, error) {
	var v GetJobUpdateDiffResult
	err := v.FromWire(w)
	return &v, err
}

func _GetTierConfigResult_Read(w wire.Value) (*GetTierConfigResult, error) {
	var v GetTierConfigResult
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.PopulateJobResult, err = _PopulateJobResult_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.ScheduleStatusResult, err = _ScheduleStatusResult_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TStruct {
				v.GetJobsResult, err = _GetJobsResult_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TStruct {
				v.GetQuotaResult, err = _GetQuotaResult_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TStruct {
				v.ListBackupsResult, err = _ListBackupsResult_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 7:
			if field.Value.Type() == wire.TStruct {
				v.StartMaintenanceResult, err = _StartMaintenanceResult_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 8:
			if field.Value.Type() == wire.TStruct {
				v.DrainHostsResult, err = _DrainHostsResult_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 9:
			if field.Value.Type() == wire.TStruct {
				v.QueryRecoveryResult, err = _QueryRecoveryResult_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 10:
			if field.Value.Type() == wire.TStruct {
				v.MaintenanceStatusResult, err = _MaintenanceStatusResult_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 11:
			if field.Value.Type() == wire.TStruct {
				v.EndMaintenanceResult, err = _EndMaintenanceResult_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 17:
			if field.Value.Type() == wire.TStruct {
				v.RoleSummaryResult, err = _RoleSummaryResult_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 18:
			if field.Value.Type() == wire.TStruct {
				v.JobSummaryResult, err = _JobSummaryResult_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TStruct {
				v.ConfigSummaryResult, err = _ConfigSummaryResult_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 21:
			if field.Value.Type() == wire.TStruct {
				v.GetPendingReasonResult, err = _GetPendingReasonResult_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 22:
			if field.Value.Type() == wire.TStruct {
				v.StartJobUpdateResult, err = _StartJobUpdateResult_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 23:
			if field.Value.Type() == wire.TStruct {
				v.GetJobUpdateSummariesResult, err = _GetJobUpdateSummariesResult_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 24:
			if field.Value.Type() == wire.TStruct {
				v.GetJobUpdateDetailsResult, err = _GetJobUpdateDetailsResult_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 25:
			if field.Value.Type() == wire.TStruct {
				v.PulseJobUpdateResult, err = _PulseJobUpdateResult_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 26:
			if field.Value.Type() == wire.TStruct {
				v.GetJobUpdateDiffResult, err = _GetJobUpdateDiffResult_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 27:
			if field.Value.Type() == wire.TStruct {
				v.GetTierConfigResult, err = _GetTierConfigResult_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.PopulateJobResult != nil {
		count++
	}
	if v.ScheduleStatusResult != nil {
		count++
	}
	if v.GetJobsResult != nil {
		count++
	}
	if v.GetQuotaResult != nil {
		count++
	}
	if v.ListBackupsResult != nil {
		count++
	}
	if v.StartMaintenanceResult != nil {
		count++
	}
	if v.DrainHostsResult != nil {
		count++
	}
	if v.QueryRecoveryResult != nil {
		count++
	}
	if v.MaintenanceStatusResult != nil {
		count++
	}
	if v.EndMaintenanceResult != nil {
		count++
	}
	if v.RoleSummaryResult != nil {
		count++
	}
	if v.JobSummaryResult != nil {
		count++
	}
	if v.ConfigSummaryResult != nil {
		count++
	}
	if v.GetPendingReasonResult != nil {
		count++
	}
	if v.StartJobUpdateResult != nil {
		count++
	}
	if v.GetJobUpdateSummariesResult != nil {
		count++
	}
	if v.GetJobUpdateDetailsResult != nil {
		count++
	}
	if v.PulseJobUpdateResult != nil {
		count++
	}
	if v.GetJobUpdateDiffResult != nil {
		count++
	}
	if v.GetTierConfigResult != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Result
// struct.
func (v *Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [20]string
	i := 0
	if v.PopulateJobResult != nil {
		fields[i] = fmt.Sprintf("PopulateJobResult: %v", v.PopulateJobResult)
		i++
	}
	if v.ScheduleStatusResult != nil {
		fields[i] = fmt.Sprintf("ScheduleStatusResult: %v", v.ScheduleStatusResult)
		i++
	}
	if v.GetJobsResult != nil {
		fields[i] = fmt.Sprintf("GetJobsResult: %v", v.GetJobsResult)
		i++
	}
	if v.GetQuotaResult != nil {
		fields[i] = fmt.Sprintf("GetQuotaResult: %v", v.GetQuotaResult)
		i++
	}
	if v.ListBackupsResult != nil {
		fields[i] = fmt.Sprintf("ListBackupsResult: %v", v.ListBackupsResult)
		i++
	}
	if v.StartMaintenanceResult != nil {
		fields[i] = fmt.Sprintf("StartMaintenanceResult: %v", v.StartMaintenanceResult)
		i++
	}
	if v.DrainHostsResult != nil {
		fields[i] = fmt.Sprintf("DrainHostsResult: %v", v.DrainHostsResult)
		i++
	}
	if v.QueryRecoveryResult != nil {
		fields[i] = fmt.Sprintf("QueryRecoveryResult: %v", v.QueryRecoveryResult)
		i++
	}
	if v.MaintenanceStatusResult != nil {
		fields[i] = fmt.Sprintf("MaintenanceStatusResult: %v", v.MaintenanceStatusResult)
		i++
	}
	if v.EndMaintenanceResult != nil {
		fields[i] = fmt.Sprintf("EndMaintenanceResult: %v", v.EndMaintenanceResult)
		i++
	}
	if v.RoleSummaryResult != nil {
		fields[i] = fmt.Sprintf("RoleSummaryResult: %v", v.RoleSummaryResult)
		i++
	}
	if v.JobSummaryResult != nil {
		fields[i] = fmt.Sprintf("JobSummaryResult: %v", v.JobSummaryResult)
		i++
	}
	if v.ConfigSummaryResult != nil {
		fields[i] = fmt.Sprintf("ConfigSummaryResult: %v", v.ConfigSummaryResult)
		i++
	}
	if v.GetPendingReasonResult != nil {
		fields[i] = fmt.Sprintf("GetPendingReasonResult: %v", v.GetPendingReasonResult)
		i++
	}
	if v.StartJobUpdateResult != nil {
		fields[i] = fmt.Sprintf("StartJobUpdateResult: %v", v.StartJobUpdateResult)
		i++
	}
	if v.GetJobUpdateSummariesResult != nil {
		fields[i] = fmt.Sprintf("GetJobUpdateSummariesResult: %v", v.GetJobUpdateSummariesResult)
		i++
	}
	if v.GetJobUpdateDetailsResult != nil {
		fields[i] = fmt.Sprintf("GetJobUpdateDetailsResult: %v", v.GetJobUpdateDetailsResult)
		i++
	}
	if v.PulseJobUpdateResult != nil {
		fields[i] = fmt.Sprintf("PulseJobUpdateResult: %v", v.PulseJobUpdateResult)
		i++
	}
	if v.GetJobUpdateDiffResult != nil {
		fields[i] = fmt.Sprintf("GetJobUpdateDiffResult: %v", v.GetJobUpdateDiffResult)
		i++
	}
	if v.GetTierConfigResult != nil {
		fields[i] = fmt.Sprintf("GetTierConfigResult: %v", v.GetTierConfigResult)
		i++
	}

	return fmt.Sprintf("Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Result match the
// provided Result.
//
// This function performs a deep comparison.
func (v *Result) Equals(rhs *Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.PopulateJobResult == nil && rhs.PopulateJobResult == nil) || (v.PopulateJobResult != nil && rhs.PopulateJobResult != nil && v.PopulateJobResult.Equals(rhs.PopulateJobResult))) {
		return false
	}
	if !((v.ScheduleStatusResult == nil && rhs.ScheduleStatusResult == nil) || (v.ScheduleStatusResult != nil && rhs.ScheduleStatusResult != nil && v.ScheduleStatusResult.Equals(rhs.ScheduleStatusResult))) {
		return false
	}
	if !((v.GetJobsResult == nil && rhs.GetJobsResult == nil) || (v.GetJobsResult != nil && rhs.GetJobsResult != nil && v.GetJobsResult.Equals(rhs.GetJobsResult))) {
		return false
	}
	if !((v.GetQuotaResult == nil && rhs.GetQuotaResult == nil) || (v.GetQuotaResult != nil && rhs.GetQuotaResult != nil && v.GetQuotaResult.Equals(rhs.GetQuotaResult))) {
		return false
	}
	if !((v.ListBackupsResult == nil && rhs.ListBackupsResult == nil) || (v.ListBackupsResult != nil && rhs.ListBackupsResult != nil && v.ListBackupsResult.Equals(rhs.ListBackupsResult))) {
		return false
	}
	if !((v.StartMaintenanceResult == nil && rhs.StartMaintenanceResult == nil) || (v.StartMaintenanceResult != nil && rhs.StartMaintenanceResult != nil && v.StartMaintenanceResult.Equals(rhs.StartMaintenanceResult))) {
		return false
	}
	if !((v.DrainHostsResult == nil && rhs.DrainHostsResult == nil) || (v.DrainHostsResult != nil && rhs.DrainHostsResult != nil && v.DrainHostsResult.Equals(rhs.DrainHostsResult))) {
		return false
	}
	if !((v.QueryRecoveryResult == nil && rhs.QueryRecoveryResult == nil) || (v.QueryRecoveryResult != nil && rhs.QueryRecoveryResult != nil && v.QueryRecoveryResult.Equals(rhs.QueryRecoveryResult))) {
		return false
	}
	if !((v.MaintenanceStatusResult == nil && rhs.MaintenanceStatusResult == nil) || (v.MaintenanceStatusResult != nil && rhs.MaintenanceStatusResult != nil && v.MaintenanceStatusResult.Equals(rhs.MaintenanceStatusResult))) {
		return false
	}
	if !((v.EndMaintenanceResult == nil && rhs.EndMaintenanceResult == nil) || (v.EndMaintenanceResult != nil && rhs.EndMaintenanceResult != nil && v.EndMaintenanceResult.Equals(rhs.EndMaintenanceResult))) {
		return false
	}
	if !((v.RoleSummaryResult == nil && rhs.RoleSummaryResult == nil) || (v.RoleSummaryResult != nil && rhs.RoleSummaryResult != nil && v.RoleSummaryResult.Equals(rhs.RoleSummaryResult))) {
		return false
	}
	if !((v.JobSummaryResult == nil && rhs.JobSummaryResult == nil) || (v.JobSummaryResult != nil && rhs.JobSummaryResult != nil && v.JobSummaryResult.Equals(rhs.JobSummaryResult))) {
		return false
	}
	if !((v.ConfigSummaryResult == nil && rhs.ConfigSummaryResult == nil) || (v.ConfigSummaryResult != nil && rhs.ConfigSummaryResult != nil && v.ConfigSummaryResult.Equals(rhs.ConfigSummaryResult))) {
		return false
	}
	if !((v.GetPendingReasonResult == nil && rhs.GetPendingReasonResult == nil) || (v.GetPendingReasonResult != nil && rhs.GetPendingReasonResult != nil && v.GetPendingReasonResult.Equals(rhs.GetPendingReasonResult))) {
		return false
	}
	if !((v.StartJobUpdateResult == nil && rhs.StartJobUpdateResult == nil) || (v.StartJobUpdateResult != nil && rhs.StartJobUpdateResult != nil && v.StartJobUpdateResult.Equals(rhs.StartJobUpdateResult))) {
		return false
	}
	if !((v.GetJobUpdateSummariesResult == nil && rhs.GetJobUpdateSummariesResult == nil) || (v.GetJobUpdateSummariesResult != nil && rhs.GetJobUpdateSummariesResult != nil && v.GetJobUpdateSummariesResult.Equals(rhs.GetJobUpdateSummariesResult))) {
		return false
	}
	if !((v.GetJobUpdateDetailsResult == nil && rhs.GetJobUpdateDetailsResult == nil) || (v.GetJobUpdateDetailsResult != nil && rhs.GetJobUpdateDetailsResult != nil && v.GetJobUpdateDetailsResult.Equals(rhs.GetJobUpdateDetailsResult))) {
		return false
	}
	if !((v.PulseJobUpdateResult == nil && rhs.PulseJobUpdateResult == nil) || (v.PulseJobUpdateResult != nil && rhs.PulseJobUpdateResult != nil && v.PulseJobUpdateResult.Equals(rhs.PulseJobUpdateResult))) {
		return false
	}
	if !((v.GetJobUpdateDiffResult == nil && rhs.GetJobUpdateDiffResult == nil) || (v.GetJobUpdateDiffResult != nil && rhs.GetJobUpdateDiffResult != nil && v.GetJobUpdateDiffResult.Equals(rhs.GetJobUpdateDiffResult))) {
		return false
	}
	if !((v.GetTierConfigResult == nil && rhs.GetTierConfigResult == nil) || (v.GetTierConfigResult != nil && rhs.GetTierConfigResult != nil && v.GetTierConfigResult.Equals(rhs.GetTierConfigResult))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Result.
func (v *Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.PopulateJobResult != nil {
		err = multierr.Append(err, enc.AddObject("populateJobResult", v.PopulateJobResult))
	}
	if v.ScheduleStatusResult != nil {
		err = multierr.Append(err, enc.AddObject("scheduleStatusResult", v.ScheduleStatusResult))
	}
	if v.GetJobsResult != nil {
		err = multierr.Append(err, enc.AddObject("getJobsResult", v.GetJobsResult))
	}
	if v.GetQuotaResult != nil {
		err = multierr.Append(err, enc.AddObject("getQuotaResult", v.GetQuotaResult))
	}
	if v.ListBackupsResult != nil {
		err = multierr.Append(err, enc.AddObject("listBackupsResult", v.ListBackupsResult))
	}
	if v.StartMaintenanceResult != nil {
		err = multierr.Append(err, enc.AddObject("startMaintenanceResult", v.StartMaintenanceResult))
	}
	if v.DrainHostsResult != nil {
		err = multierr.Append(err, enc.AddObject("drainHostsResult", v.DrainHostsResult))
	}
	if v.QueryRecoveryResult != nil {
		err = multierr.Append(err, enc.AddObject("queryRecoveryResult", v.QueryRecoveryResult))
	}
	if v.MaintenanceStatusResult != nil {
		err = multierr.Append(err, enc.AddObject("maintenanceStatusResult", v.MaintenanceStatusResult))
	}
	if v.EndMaintenanceResult != nil {
		err = multierr.Append(err, enc.AddObject("endMaintenanceResult", v.EndMaintenanceResult))
	}
	if v.RoleSummaryResult != nil {
		err = multierr.Append(err, enc.AddObject("roleSummaryResult", v.RoleSummaryResult))
	}
	if v.JobSummaryResult != nil {
		err = multierr.Append(err, enc.AddObject("jobSummaryResult", v.JobSummaryResult))
	}
	if v.ConfigSummaryResult != nil {
		err = multierr.Append(err, enc.AddObject("configSummaryResult", v.ConfigSummaryResult))
	}
	if v.GetPendingReasonResult != nil {
		err = multierr.Append(err, enc.AddObject("getPendingReasonResult", v.GetPendingReasonResult))
	}
	if v.StartJobUpdateResult != nil {
		err = multierr.Append(err, enc.AddObject("startJobUpdateResult", v.StartJobUpdateResult))
	}
	if v.GetJobUpdateSummariesResult != nil {
		err = multierr.Append(err, enc.AddObject("getJobUpdateSummariesResult", v.GetJobUpdateSummariesResult))
	}
	if v.GetJobUpdateDetailsResult != nil {
		err = multierr.Append(err, enc.AddObject("getJobUpdateDetailsResult", v.GetJobUpdateDetailsResult))
	}
	if v.PulseJobUpdateResult != nil {
		err = multierr.Append(err, enc.AddObject("pulseJobUpdateResult", v.PulseJobUpdateResult))
	}
	if v.GetJobUpdateDiffResult != nil {
		err = multierr.Append(err, enc.AddObject("getJobUpdateDiffResult", v.GetJobUpdateDiffResult))
	}
	if v.GetTierConfigResult != nil {
		err = multierr.Append(err, enc.AddObject("getTierConfigResult", v.GetTierConfigResult))
	}
	return err
}

// GetPopulateJobResult returns the value of PopulateJobResult if it is set or its
// zero value if it is unset.
func (v *Result) GetPopulateJobResult() (o *PopulateJobResult) {
	if v != nil && v.PopulateJobResult != nil {
		return v.PopulateJobResult
	}

	return
}

// IsSetPopulateJobResult returns true if PopulateJobResult is not nil.
func (v *Result) IsSetPopulateJobResult() bool {
	return v != nil && v.PopulateJobResult != nil
}

// GetScheduleStatusResult returns the value of ScheduleStatusResult if it is set or its
// zero value if it is unset.
func (v *Result) GetScheduleStatusResult() (o *ScheduleStatusResult) {
	if v != nil && v.ScheduleStatusResult != nil {
		return v.ScheduleStatusResult
	}

	return
}

// IsSetScheduleStatusResult returns true if ScheduleStatusResult is not nil.
func (v *Result) IsSetScheduleStatusResult() bool {
	return v != nil && v.ScheduleStatusResult != nil
}

// GetGetJobsResult returns the value of GetJobsResult if it is set or its
// zero value if it is unset.
func (v *Result) GetGetJobsResult() (o *GetJobsResult) {
	if v != nil && v.GetJobsResult != nil {
		return v.GetJobsResult
	}

	return
}

// IsSetGetJobsResult returns true if GetJobsResult is not nil.
func (v *Result) IsSetGetJobsResult() bool {
	return v != nil && v.GetJobsResult != nil
}

// GetGetQuotaResult returns the value of GetQuotaResult if it is set or its
// zero value if it is unset.
func (v *Result) GetGetQuotaResult() (o *GetQuotaResult) {
	if v != nil && v.GetQuotaResult != nil {
		return v.GetQuotaResult
	}

	return
}

// IsSetGetQuotaResult returns true if GetQuotaResult is not nil.
func (v *Result) IsSetGetQuotaResult() bool {
	return v != nil && v.GetQuotaResult != nil
}

// GetListBackupsResult returns the value of ListBackupsResult if it is set or its
// zero value if it is unset.
func (v *Result) GetListBackupsResult() (o *ListBackupsResult) {
	if v != nil && v.ListBackupsResult != nil {
		return v.ListBackupsResult
	}

	return
}

// IsSetListBackupsResult returns true if ListBackupsResult is not nil.
func (v *Result) IsSetListBackupsResult() bool {
	return v != nil && v.ListBackupsResult != nil
}

// GetStartMaintenanceResult returns the value of StartMaintenanceResult if it is set or its
// zero value if it is unset.
func (v *Result) GetStartMaintenanceResult() (o *StartMaintenanceResult) {
	if v != nil && v.StartMaintenanceResult != nil {
		return v.StartMaintenanceResult
	}

	return
}

// IsSetStartMaintenanceResult returns true if StartMaintenanceResult is not nil.
func (v *Result) IsSetStartMaintenanceResult() bool {
	return v != nil && v.StartMaintenanceResult != nil
}

// GetDrainHostsResult returns the value of DrainHostsResult if it is set or its
// zero value if it is unset.
func (v *Result) GetDrainHostsResult() (o *DrainHostsResult) {
	if v != nil && v.DrainHostsResult != nil {
		return v.DrainHostsResult
	}

	return
}

// IsSetDrainHostsResult returns true if DrainHostsResult is not nil.
func (v *Result) IsSetDrainHostsResult() bool {
	return v != nil && v.DrainHostsResult != nil
}

// GetQueryRecoveryResult returns the value of QueryRecoveryResult if it is set or its
// zero value if it is unset.
func (v *Result) GetQueryRecoveryResult() (o *QueryRecoveryResult) {
	if v != nil && v.QueryRecoveryResult != nil {
		return v.QueryRecoveryResult
	}

	return
}

// IsSetQueryRecoveryResult returns true if QueryRecoveryResult is not nil.
func (v *Result) IsSetQueryRecoveryResult() bool {
	return v != nil && v.QueryRecoveryResult != nil
}

// GetMaintenanceStatusResult returns the value of MaintenanceStatusResult if it is set or its
// zero value if it is unset.
func (v *Result) GetMaintenanceStatusResult() (o *MaintenanceStatusResult) {
	if v != nil && v.MaintenanceStatusResult != nil {
		return v.MaintenanceStatusResult
	}

	return
}

// IsSetMaintenanceStatusResult returns true if MaintenanceStatusResult is not nil.
func (v *Result) IsSetMaintenanceStatusResult() bool {
	return v != nil && v.MaintenanceStatusResult != nil
}

// GetEndMaintenanceResult returns the value of EndMaintenanceResult if it is set or its
// zero value if it is unset.
func (v *Result) GetEndMaintenanceResult() (o *EndMaintenanceResult) {
	if v != nil && v.EndMaintenanceResult != nil {
		return v.EndMaintenanceResult
	}

	return
}

// IsSetEndMaintenanceResult returns true if EndMaintenanceResult is not nil.
func (v *Result) IsSetEndMaintenanceResult() bool {
	return v != nil && v.EndMaintenanceResult != nil
}

// GetRoleSummaryResult returns the value of RoleSummaryResult if it is set or its
// zero value if it is unset.
func (v *Result) GetRoleSummaryResult() (o *RoleSummaryResult) {
	if v != nil && v.RoleSummaryResult != nil {
		return v.RoleSummaryResult
	}

	return
}

// IsSetRoleSummaryResult returns true if RoleSummaryResult is not nil.
func (v *Result) IsSetRoleSummaryResult() bool {
	return v != nil && v.RoleSummaryResult != nil
}

// GetJobSummaryResult returns the value of JobSummaryResult if it is set or its
// zero value if it is unset.
func (v *Result) GetJobSummaryResult() (o *JobSummaryResult) {
	if v != nil && v.JobSummaryResult != nil {
		return v.JobSummaryResult
	}

	return
}

// IsSetJobSummaryResult returns true if JobSummaryResult is not nil.
func (v *Result) IsSetJobSummaryResult() bool {
	return v != nil && v.JobSummaryResult != nil
}

// GetConfigSummaryResult returns the value of ConfigSummaryResult if it is set or its
// zero value if it is unset.
func (v *Result) GetConfigSummaryResult() (o *ConfigSummaryResult) {
	if v != nil && v.ConfigSummaryResult != nil {
		return v.ConfigSummaryResult
	}

	return
}

// IsSetConfigSummaryResult returns true if ConfigSummaryResult is not nil.
func (v *Result) IsSetConfigSummaryResult() bool {
	return v != nil && v.ConfigSummaryResult != nil
}

// GetGetPendingReasonResult returns the value of GetPendingReasonResult if it is set or its
// zero value if it is unset.
func (v *Result) GetGetPendingReasonResult() (o *GetPendingReasonResult) {
	if v != nil && v.GetPendingReasonResult != nil {
		return v.GetPendingReasonResult
	}

	return
}

// IsSetGetPendingReasonResult returns true if GetPendingReasonResult is not nil.
func (v *Result) IsSetGetPendingReasonResult() bool {
	return v != nil && v.GetPendingReasonResult != nil
}

// GetStartJobUpdateResult returns the value of StartJobUpdateResult if it is set or its
// zero value if it is unset.
func (v *Result) GetStartJobUpdateResult() (o *StartJobUpdateResult) {
	if v != nil && v.StartJobUpdateResult != nil {
		return v.StartJobUpdateResult
	}

	return
}

// IsSetStartJobUpdateResult returns true if StartJobUpdateResult is not nil.
func (v *Result) IsSetStartJobUpdateResult() bool {
	return v != nil && v.StartJobUpdateResult != nil
}

// GetGetJobUpdateSummariesResult returns the value of GetJobUpdateSummariesResult if it is set or its
// zero value if it is unset.
func (v *Result) GetGetJobUpdateSummariesResult() (o *GetJobUpdateSummariesResult) {
	if v != nil && v.GetJobUpdateSummariesResult != nil {
		return v.GetJobUpdateSummariesResult
	}

	return
}

// IsSetGetJobUpdateSummariesResult returns true if GetJobUpdateSummariesResult is not nil.
func (v *Result) IsSetGetJobUpdateSummariesResult() bool {
	return v != nil && v.GetJobUpdateSummariesResult != nil
}

// GetGetJobUpdateDetailsResult returns the value of GetJobUpdateDetailsResult if it is set or its
// zero value if it is unset.
func (v *Result) GetGetJobUpdateDetailsResult() (o *GetJobUpdateDetailsResult) {
	if v != nil && v.GetJobUpdateDetailsResult != nil {
		return v.GetJobUpdateDetailsResult
	}

	return
}

// IsSetGetJobUpdateDetailsResult returns true if GetJobUpdateDetailsResult is not nil.
func (v *Result) IsSetGetJobUpdateDetailsResult() bool {
	return v != nil && v.GetJobUpdateDetailsResult != nil
}

// GetPulseJobUpdateResult returns the value of PulseJobUpdateResult if it is set or its
// zero value if it is unset.
func (v *Result) GetPulseJobUpdateResult() (o *PulseJobUpdateResult) {
	if v != nil && v.PulseJobUpdateResult != nil {
		return v.PulseJobUpdateResult
	}

	return
}

// IsSetPulseJobUpdateResult returns true if PulseJobUpdateResult is not nil.
func (v *Result) IsSetPulseJobUpdateResult() bool {
	return v != nil && v.PulseJobUpdateResult != nil
}

// GetGetJobUpdateDiffResult returns the value of GetJobUpdateDiffResult if it is set or its
// zero value if it is unset.
func (v *Result) GetGetJobUpdateDiffResult() (o *GetJobUpdateDiffResult) {
	if v != nil && v.GetJobUpdateDiffResult != nil {
		return v.GetJobUpdateDiffResult
	}

	return
}

// IsSetGetJobUpdateDiffResult returns true if GetJobUpdateDiffResult is not nil.
func (v *Result) IsSetGetJobUpdateDiffResult() bool {
	return v != nil && v.GetJobUpdateDiffResult != nil
}

// GetGetTierConfigResult returns the value of GetTierConfigResult if it is set or its
// zero value if it is unset.
func (v *Result) GetGetTierConfigResult() (o *GetTierConfigResult) {
	if v != nil && v.GetTierConfigResult != nil {
		return v.GetTierConfigResult
	}

	return
}

// IsSetGetTierConfigResult returns true if GetTierConfigResult is not nil.
func (v *Result) IsSetGetTierConfigResult() bool {
	return v != nil && v.GetTierConfigResult != nil
}

type RoleSummary struct {
	Role         *string `json:"role,omitempty"`
	JobCount     *int32  `json:"jobCount,omitempty"`
	CronJobCount *int32  `json:"cronJobCount,omitempty"`
}

// ToWire translates a RoleSummary struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RoleSummary) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Role != nil {
		w, err = wire.NewValueString(*(v.Role)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.JobCount != nil {
		w, err = wire.NewValueI32(*(v.JobCount)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.CronJobCount != nil {
		w, err = wire.NewValueI32(*(v.CronJobCount)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a RoleSummary struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RoleSummary struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RoleSummary
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RoleSummary) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Role = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.JobCount = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.CronJobCount = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a RoleSummary
// struct.
func (v *RoleSummary) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Role != nil {
		fields[i] = fmt.Sprintf("Role: %v", *(v.Role))
		i++
	}
	if v.JobCount != nil {
		fields[i] = fmt.Sprintf("JobCount: %v", *(v.JobCount))
		i++
	}
	if v.CronJobCount != nil {
		fields[i] = fmt.Sprintf("CronJobCount: %v", *(v.CronJobCount))
		i++
	}

	return fmt.Sprintf("RoleSummary{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this RoleSummary match the
// provided RoleSummary.
//
// This function performs a deep comparison.
func (v *RoleSummary) Equals(rhs *RoleSummary) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Role, rhs.Role) {
		return false
	}
	if !_I32_EqualsPtr(v.JobCount, rhs.JobCount) {
		return false
	}
	if !_I32_EqualsPtr(v.CronJobCount, rhs.CronJobCount) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RoleSummary.
func (v *RoleSummary) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Role != nil {
		enc.AddString("role", *v.Role)
	}
	if v.JobCount != nil {
		enc.AddInt32("jobCount", *v.JobCount)
	}
	if v.CronJobCount != nil {
		enc.AddInt32("cronJobCount", *v.CronJobCount)
	}
	return err
}

// GetRole returns the value of Role if it is set or its
// zero value if it is unset.
func (v *RoleSummary) GetRole() (o string) {
	if v != nil && v.Role != nil {
		return *v.Role
	}

	return
}

// IsSetRole returns true if Role is not nil.
func (v *RoleSummary) IsSetRole() bool {
	return v != nil && v.Role != nil
}

// GetJobCount returns the value of JobCount if it is set or its
// zero value if it is unset.
func (v *RoleSummary) GetJobCount() (o int32) {
	if v != nil && v.JobCount != nil {
		return *v.JobCount
	}

	return
}

// IsSetJobCount returns true if JobCount is not nil.
func (v *RoleSummary) IsSetJobCount() bool {
	return v != nil && v.JobCount != nil
}

// GetCronJobCount returns the value of CronJobCount if it is set or its
// zero value if it is unset.
func (v *RoleSummary) GetCronJobCount() (o int32) {
	if v != nil && v.CronJobCount != nil {
		return *v.CronJobCount
	}

	return
}

// IsSetCronJobCount returns true if CronJobCount is not nil.
func (v *RoleSummary) IsSetCronJobCount() bool {
	return v != nil && v.CronJobCount != nil
}

type RoleSummaryResult struct {
	Summaries []*RoleSummary `json:"summaries,omitempty"`
}

type _Set_RoleSummary_sliceType_ValueList []*RoleSummary

func (v _Set_RoleSummary_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_RoleSummary_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_RoleSummary_sliceType_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_RoleSummary_sliceType_ValueList) Close() {}

// ToWire translates a RoleSummaryResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RoleSummaryResult) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Summaries != nil {
		w, err = wire.NewValueSet(_Set_RoleSummary_sliceType_ValueList(v.Summaries)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _RoleSummary_Read(w wire.Value) (*RoleSummary, error) {
	var v RoleSummary
	err := v.FromWire(w)
	return &v, err
}

func _Set_RoleSummary_sliceType_Read(s wire.ValueList) ([]*RoleSummary, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*RoleSummary, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _RoleSummary_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

// FromWire deserializes a RoleSummaryResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RoleSummaryResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RoleSummaryResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RoleSummaryResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TSet {
				v.Summaries, err = _Set_RoleSummary_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a RoleSummaryResult
// struct.
func (v *RoleSummaryResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Summaries != nil {
		fields[i] = fmt.Sprintf("Summaries: %v", v.Summaries)
		i++
	}

	return fmt.Sprintf("RoleSummaryResult{%v}", strings.Join(fields[:i], ", "))
}

func _Set_RoleSummary_sliceType_Equals(lhs, rhs []*RoleSummary) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this RoleSummaryResult match the
// provided RoleSummaryResult.
//
// This function performs a deep comparison.
func (v *RoleSummaryResult) Equals(rhs *RoleSummaryResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Summaries == nil && rhs.Summaries == nil) || (v.Summaries != nil && rhs.Summaries != nil && _Set_RoleSummary_sliceType_Equals(v.Summaries, rhs.Summaries))) {
		return false
	}

	return true
}

type _Set_RoleSummary_sliceType_Zapper []*RoleSummary

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_RoleSummary_sliceType_Zapper.
func (s _Set_RoleSummary_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RoleSummaryResult.
func (v *RoleSummaryResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Summaries != nil {
		err = multierr.Append(err, enc.AddArray("summaries", (_Set_RoleSummary_sliceType_Zapper)(v.Summaries)))
	}
	return err
}

// GetSummaries returns the value of Summaries if it is set or its
// zero value if it is unset.
func (v *RoleSummaryResult) GetSummaries() (o []*RoleSummary) {
	if v != nil && v.Summaries != nil {
		return v.Summaries
	}

	return
}

// IsSetSummaries returns true if Summaries is not nil.
func (v *RoleSummaryResult) IsSetSummaries() bool {
	return v != nil && v.Summaries != nil
}

// States that a task may be in.
type ScheduleStatus int32

const (
	ScheduleStatusInit ScheduleStatus = 11
	// The task will be rescheduled, but is being throttled for restarting too frequently.
	ScheduleStatusThrottled ScheduleStatus = 16
	// Task is awaiting assignment to a slave.
	ScheduleStatusPending ScheduleStatus = 0
	// Task has been assigned to a slave.
	ScheduleStatusAssigned ScheduleStatus = 9
	// Slave has acknowledged receipt of task and is bootstrapping the task.
	ScheduleStatusStarting ScheduleStatus = 1
	// The task is running on the slave.
	ScheduleStatusRunning ScheduleStatus = 2
	// The task terminated with an exit code of zero.
	ScheduleStatusFinished ScheduleStatus = 3
	// The task is being preempted by another task.
	ScheduleStatusPreempting ScheduleStatus = 13
	// The task is being restarted in response to a user request.
	ScheduleStatusRestarting ScheduleStatus = 12
	// The task is being restarted in response to a host maintenance request.
	ScheduleStatusDraining ScheduleStatus = 17
	// The task terminated with a non-zero exit code.
	ScheduleStatusFailed ScheduleStatus = 4
	// Execution of the task was terminated by the system.
	ScheduleStatusKilled ScheduleStatus = 5
	// The task is being forcibly killed.
	ScheduleStatusKilling ScheduleStatus = 6
	// A fault in the task environment has caused the system to believe the task no longer exists.
	// This can happen, for example, when a slave process disappears.
	ScheduleStatusLost ScheduleStatus = 7
)

// ScheduleStatus_Values returns all recognized values of ScheduleStatus.
func ScheduleStatus_Values() []ScheduleStatus {
	return []ScheduleStatus{
		ScheduleStatusInit,
		ScheduleStatusThrottled,
		ScheduleStatusPending,
		ScheduleStatusAssigned,
		ScheduleStatusStarting,
		ScheduleStatusRunning,
		ScheduleStatusFinished,
		ScheduleStatusPreempting,
		ScheduleStatusRestarting,
		ScheduleStatusDraining,
		ScheduleStatusFailed,
		ScheduleStatusKilled,
		ScheduleStatusKilling,
		ScheduleStatusLost,
	}
}

// UnmarshalText tries to decode ScheduleStatus from a byte slice
// containing its name.
//
//   var v ScheduleStatus
//   err := v.UnmarshalText([]byte("INIT"))
func (v *ScheduleStatus) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "INIT":
		*v = ScheduleStatusInit
		return nil
	case "THROTTLED":
		*v = ScheduleStatusThrottled
		return nil
	case "PENDING":
		*v = ScheduleStatusPending
		return nil
	case "ASSIGNED":
		*v = ScheduleStatusAssigned
		return nil
	case "STARTING":
		*v = ScheduleStatusStarting
		return nil
	case "RUNNING":
		*v = ScheduleStatusRunning
		return nil
	case "FINISHED":
		*v = ScheduleStatusFinished
		return nil
	case "PREEMPTING":
		*v = ScheduleStatusPreempting
		return nil
	case "RESTARTING":
		*v = ScheduleStatusRestarting
		return nil
	case "DRAINING":
		*v = ScheduleStatusDraining
		return nil
	case "FAILED":
		*v = ScheduleStatusFailed
		return nil
	case "KILLED":
		*v = ScheduleStatusKilled
		return nil
	case "KILLING":
		*v = ScheduleStatusKilling
		return nil
	case "LOST":
		*v = ScheduleStatusLost
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "ScheduleStatus", err)
		}
		*v = ScheduleStatus(val)
		return nil
	}
}

// MarshalText encodes ScheduleStatus to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v ScheduleStatus) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 11:
		return []byte("INIT"), nil
	case 16:
		return []byte("THROTTLED"), nil
	case 0:
		return []byte("PENDING"), nil
	case 9:
		return []byte("ASSIGNED"), nil
	case 1:
		return []byte("STARTING"), nil
	case 2:
		return []byte("RUNNING"), nil
	case 3:
		return []byte("FINISHED"), nil
	case 13:
		return []byte("PREEMPTING"), nil
	case 12:
		return []byte("RESTARTING"), nil
	case 17:
		return []byte("DRAINING"), nil
	case 4:
		return []byte("FAILED"), nil
	case 5:
		return []byte("KILLED"), nil
	case 6:
		return []byte("KILLING"), nil
	case 7:
		return []byte("LOST"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ScheduleStatus.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v ScheduleStatus) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 11:
		enc.AddString("name", "INIT")
	case 16:
		enc.AddString("name", "THROTTLED")
	case 0:
		enc.AddString("name", "PENDING")
	case 9:
		enc.AddString("name", "ASSIGNED")
	case 1:
		enc.AddString("name", "STARTING")
	case 2:
		enc.AddString("name", "RUNNING")
	case 3:
		enc.AddString("name", "FINISHED")
	case 13:
		enc.AddString("name", "PREEMPTING")
	case 12:
		enc.AddString("name", "RESTARTING")
	case 17:
		enc.AddString("name", "DRAINING")
	case 4:
		enc.AddString("name", "FAILED")
	case 5:
		enc.AddString("name", "KILLED")
	case 6:
		enc.AddString("name", "KILLING")
	case 7:
		enc.AddString("name", "LOST")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v ScheduleStatus) Ptr() *ScheduleStatus {
	return &v
}

// ToWire translates ScheduleStatus into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v ScheduleStatus) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes ScheduleStatus from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return ScheduleStatus(0), err
//   }
//
//   var v ScheduleStatus
//   if err := v.FromWire(x); err != nil {
//     return ScheduleStatus(0), err
//   }
//   return v, nil
func (v *ScheduleStatus) FromWire(w wire.Value) error {
	*v = (ScheduleStatus)(w.GetI32())
	return nil
}

// String returns a readable string representation of ScheduleStatus.
func (v ScheduleStatus) String() string {
	w := int32(v)
	switch w {
	case 11:
		return "INIT"
	case 16:
		return "THROTTLED"
	case 0:
		return "PENDING"
	case 9:
		return "ASSIGNED"
	case 1:
		return "STARTING"
	case 2:
		return "RUNNING"
	case 3:
		return "FINISHED"
	case 13:
		return "PREEMPTING"
	case 12:
		return "RESTARTING"
	case 17:
		return "DRAINING"
	case 4:
		return "FAILED"
	case 5:
		return "KILLED"
	case 6:
		return "KILLING"
	case 7:
		return "LOST"
	}
	return fmt.Sprintf("ScheduleStatus(%d)", w)
}

// Equals returns true if this ScheduleStatus value matches the provided
// value.
func (v ScheduleStatus) Equals(rhs ScheduleStatus) bool {
	return v == rhs
}

// MarshalJSON serializes ScheduleStatus into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v ScheduleStatus) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 11:
		return ([]byte)("\"INIT\""), nil
	case 16:
		return ([]byte)("\"THROTTLED\""), nil
	case 0:
		return ([]byte)("\"PENDING\""), nil
	case 9:
		return ([]byte)("\"ASSIGNED\""), nil
	case 1:
		return ([]byte)("\"STARTING\""), nil
	case 2:
		return ([]byte)("\"RUNNING\""), nil
	case 3:
		return ([]byte)("\"FINISHED\""), nil
	case 13:
		return ([]byte)("\"PREEMPTING\""), nil
	case 12:
		return ([]byte)("\"RESTARTING\""), nil
	case 17:
		return ([]byte)("\"DRAINING\""), nil
	case 4:
		return ([]byte)("\"FAILED\""), nil
	case 5:
		return ([]byte)("\"KILLED\""), nil
	case 6:
		return ([]byte)("\"KILLING\""), nil
	case 7:
		return ([]byte)("\"LOST\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode ScheduleStatus from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *ScheduleStatus) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "ScheduleStatus")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "ScheduleStatus")
		}
		*v = (ScheduleStatus)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "ScheduleStatus")
	}
}

type ScheduleStatusResult struct {
	Tasks []*ScheduledTask `json:"tasks,omitempty"`
}

type _List_ScheduledTask_ValueList []*ScheduledTask

func (v _List_ScheduledTask_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_ScheduledTask_ValueList) Size() int {
	return len(v)
}

func (_List_ScheduledTask_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_ScheduledTask_ValueList) Close() {}

// ToWire translates a ScheduleStatusResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ScheduleStatusResult) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Tasks != nil {
		w, err = wire.NewValueList(_List_ScheduledTask_ValueList(v.Tasks)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_ScheduledTask_Read(l wire.ValueList) ([]*ScheduledTask, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*ScheduledTask, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _ScheduledTask_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a ScheduleStatusResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ScheduleStatusResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ScheduleStatusResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ScheduleStatusResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Tasks, err = _List_ScheduledTask_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ScheduleStatusResult
// struct.
func (v *ScheduleStatusResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Tasks != nil {
		fields[i] = fmt.Sprintf("Tasks: %v", v.Tasks)
		i++
	}

	return fmt.Sprintf("ScheduleStatusResult{%v}", strings.Join(fields[:i], ", "))
}

func _List_ScheduledTask_Equals(lhs, rhs []*ScheduledTask) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this ScheduleStatusResult match the
// provided ScheduleStatusResult.
//
// This function performs a deep comparison.
func (v *ScheduleStatusResult) Equals(rhs *ScheduleStatusResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Tasks == nil && rhs.Tasks == nil) || (v.Tasks != nil && rhs.Tasks != nil && _List_ScheduledTask_Equals(v.Tasks, rhs.Tasks))) {
		return false
	}

	return true
}

type _List_ScheduledTask_Zapper []*ScheduledTask

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_ScheduledTask_Zapper.
func (l _List_ScheduledTask_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ScheduleStatusResult.
func (v *ScheduleStatusResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Tasks != nil {
		err = multierr.Append(err, enc.AddArray("tasks", (_List_ScheduledTask_Zapper)(v.Tasks)))
	}
	return err
}

// GetTasks returns the value of Tasks if it is set or its
// zero value if it is unset.
func (v *ScheduleStatusResult) GetTasks() (o []*ScheduledTask) {
	if v != nil && v.Tasks != nil {
		return v.Tasks
	}

	return
}

// IsSetTasks returns true if Tasks is not nil.
func (v *ScheduleStatusResult) IsSetTasks() bool {
	return v != nil && v.Tasks != nil
}

// A task that has been scheduled.
type ScheduledTask struct {
	// The task that was scheduled.
	AssignedTask *AssignedTask `json:"assignedTask,omitempty"`
	// The current status of this task.
	Status *ScheduleStatus `json:"status,omitempty"`
	// The number of failures that this task has accumulated over the multi-generational history of
	// this task.
	FailureCount *int32 `json:"failureCount,omitempty"`
	// State change history for this task.
	TaskEvents []*TaskEvent `json:"taskEvents,omitempty"`
	// The task ID of the previous generation of this task.  When a task is automatically rescheduled,
	// a copy of the task is created and ancestor ID of the previous task's task ID.
	AncestorId *string `json:"ancestorId,omitempty"`
}

type _List_TaskEvent_ValueList []*TaskEvent

func (v _List_TaskEvent_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_TaskEvent_ValueList) Size() int {
	return len(v)
}

func (_List_TaskEvent_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_TaskEvent_ValueList) Close() {}

// ToWire translates a ScheduledTask struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ScheduledTask) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.AssignedTask != nil {
		w, err = v.AssignedTask.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Status != nil {
		w, err = v.Status.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.FailureCount != nil {
		w, err = wire.NewValueI32(*(v.FailureCount)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.TaskEvents != nil {
		w, err = wire.NewValueList(_List_TaskEvent_ValueList(v.TaskEvents)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.AncestorId != nil {
		w, err = wire.NewValueString(*(v.AncestorId)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _AssignedTask_Read(w wire.Value) (*AssignedTask, error) {
	var v AssignedTask
	err := v.FromWire(w)
	return &v, err
}

func _ScheduleStatus_Read(w wire.Value) (ScheduleStatus, error) {
	var v ScheduleStatus
	err := v.FromWire(w)
	return v, err
}

func _TaskEvent_Read(w wire.Value) (*TaskEvent, error) {
	var v TaskEvent
	err := v.FromWire(w)
	return &v, err
}

func _List_TaskEvent_Read(l wire.ValueList) ([]*TaskEvent, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*TaskEvent, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _TaskEvent_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a ScheduledTask struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ScheduledTask struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ScheduledTask
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ScheduledTask) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.AssignedTask, err = _AssignedTask_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x ScheduleStatus
				x, err = _ScheduleStatus_Read(field.Value)
				v.Status = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.FailureCount = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TList {
				v.TaskEvents, err = _List_TaskEvent_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.AncestorId = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ScheduledTask
// struct.
func (v *ScheduledTask) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [5]string
	i := 0
	if v.AssignedTask != nil {
		fields[i] = fmt.Sprintf("AssignedTask: %v", v.AssignedTask)
		i++
	}
	if v.Status != nil {
		fields[i] = fmt.Sprintf("Status: %v", *(v.Status))
		i++
	}
	if v.FailureCount != nil {
		fields[i] = fmt.Sprintf("FailureCount: %v", *(v.FailureCount))
		i++
	}
	if v.TaskEvents != nil {
		fields[i] = fmt.Sprintf("TaskEvents: %v", v.TaskEvents)
		i++
	}
	if v.AncestorId != nil {
		fields[i] = fmt.Sprintf("AncestorId: %v", *(v.AncestorId))
		i++
	}

	return fmt.Sprintf("ScheduledTask{%v}", strings.Join(fields[:i], ", "))
}

func _ScheduleStatus_EqualsPtr(lhs, rhs *ScheduleStatus) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

func _List_TaskEvent_Equals(lhs, rhs []*TaskEvent) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this ScheduledTask match the
// provided ScheduledTask.
//
// This function performs a deep comparison.
func (v *ScheduledTask) Equals(rhs *ScheduledTask) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.AssignedTask == nil && rhs.AssignedTask == nil) || (v.AssignedTask != nil && rhs.AssignedTask != nil && v.AssignedTask.Equals(rhs.AssignedTask))) {
		return false
	}
	if !_ScheduleStatus_EqualsPtr(v.Status, rhs.Status) {
		return false
	}
	if !_I32_EqualsPtr(v.FailureCount, rhs.FailureCount) {
		return false
	}
	if !((v.TaskEvents == nil && rhs.TaskEvents == nil) || (v.TaskEvents != nil && rhs.TaskEvents != nil && _List_TaskEvent_Equals(v.TaskEvents, rhs.TaskEvents))) {
		return false
	}
	if !_String_EqualsPtr(v.AncestorId, rhs.AncestorId) {
		return false
	}

	return true
}

type _List_TaskEvent_Zapper []*TaskEvent

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_TaskEvent_Zapper.
func (l _List_TaskEvent_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ScheduledTask.
func (v *ScheduledTask) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.AssignedTask != nil {
		err = multierr.Append(err, enc.AddObject("assignedTask", v.AssignedTask))
	}
	if v.Status != nil {
		err = multierr.Append(err, enc.AddObject("status", *v.Status))
	}
	if v.FailureCount != nil {
		enc.AddInt32("failureCount", *v.FailureCount)
	}
	if v.TaskEvents != nil {
		err = multierr.Append(err, enc.AddArray("taskEvents", (_List_TaskEvent_Zapper)(v.TaskEvents)))
	}
	if v.AncestorId != nil {
		enc.AddString("ancestorId", *v.AncestorId)
	}
	return err
}

// GetAssignedTask returns the value of AssignedTask if it is set or its
// zero value if it is unset.
func (v *ScheduledTask) GetAssignedTask() (o *AssignedTask) {
	if v != nil && v.AssignedTask != nil {
		return v.AssignedTask
	}

	return
}

// IsSetAssignedTask returns true if AssignedTask is not nil.
func (v *ScheduledTask) IsSetAssignedTask() bool {
	return v != nil && v.AssignedTask != nil
}

// GetStatus returns the value of Status if it is set or its
// zero value if it is unset.
func (v *ScheduledTask) GetStatus() (o ScheduleStatus) {
	if v != nil && v.Status != nil {
		return *v.Status
	}

	return
}

// IsSetStatus returns true if Status is not nil.
func (v *ScheduledTask) IsSetStatus() bool {
	return v != nil && v.Status != nil
}

// GetFailureCount returns the value of FailureCount if it is set or its
// zero value if it is unset.
func (v *ScheduledTask) GetFailureCount() (o int32) {
	if v != nil && v.FailureCount != nil {
		return *v.FailureCount
	}

	return
}

// IsSetFailureCount returns true if FailureCount is not nil.
func (v *ScheduledTask) IsSetFailureCount() bool {
	return v != nil && v.FailureCount != nil
}

// GetTaskEvents returns the value of TaskEvents if it is set or its
// zero value if it is unset.
func (v *ScheduledTask) GetTaskEvents() (o []*TaskEvent) {
	if v != nil && v.TaskEvents != nil {
		return v.TaskEvents
	}

	return
}

// IsSetTaskEvents returns true if TaskEvents is not nil.
func (v *ScheduledTask) IsSetTaskEvents() bool {
	return v != nil && v.TaskEvents != nil
}

// GetAncestorId returns the value of AncestorId if it is set or its
// zero value if it is unset.
func (v *ScheduledTask) GetAncestorId() (o string) {
	if v != nil && v.AncestorId != nil {
		return *v.AncestorId
	}

	return
}

// IsSetAncestorId returns true if AncestorId is not nil.
func (v *ScheduledTask) IsSetAncestorId() bool {
	return v != nil && v.AncestorId != nil
}

// Information about the scheduler.
type ServerInfo struct {
	ClusterName *string `json:"clusterName,omitempty"`
	// A url prefix for job container stats.
	StatsUrlPrefix *string `json:"statsUrlPrefix,omitempty"`
}

// ToWire translates a ServerInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ServerInfo) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ClusterName != nil {
		w, err = wire.NewValueString(*(v.ClusterName)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.StatsUrlPrefix != nil {
		w, err = wire.NewValueString(*(v.StatsUrlPrefix)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ServerInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ServerInfo struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ServerInfo
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ServerInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ClusterName = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StatsUrlPrefix = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ServerInfo
// struct.
func (v *ServerInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.ClusterName != nil {
		fields[i] = fmt.Sprintf("ClusterName: %v", *(v.ClusterName))
		i++
	}
	if v.StatsUrlPrefix != nil {
		fields[i] = fmt.Sprintf("StatsUrlPrefix: %v", *(v.StatsUrlPrefix))
		i++
	}

	return fmt.Sprintf("ServerInfo{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ServerInfo match the
// provided ServerInfo.
//
// This function performs a deep comparison.
func (v *ServerInfo) Equals(rhs *ServerInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.ClusterName, rhs.ClusterName) {
		return false
	}
	if !_String_EqualsPtr(v.StatsUrlPrefix, rhs.StatsUrlPrefix) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ServerInfo.
func (v *ServerInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ClusterName != nil {
		enc.AddString("clusterName", *v.ClusterName)
	}
	if v.StatsUrlPrefix != nil {
		enc.AddString("statsUrlPrefix", *v.StatsUrlPrefix)
	}
	return err
}

// GetClusterName returns the value of ClusterName if it is set or its
// zero value if it is unset.
func (v *ServerInfo) GetClusterName() (o string) {
	if v != nil && v.ClusterName != nil {
		return *v.ClusterName
	}

	return
}

// IsSetClusterName returns true if ClusterName is not nil.
func (v *ServerInfo) IsSetClusterName() bool {
	return v != nil && v.ClusterName != nil
}

// GetStatsUrlPrefix returns the value of StatsUrlPrefix if it is set or its
// zero value if it is unset.
func (v *ServerInfo) GetStatsUrlPrefix() (o string) {
	if v != nil && v.StatsUrlPrefix != nil {
		return *v.StatsUrlPrefix
	}

	return
}

// IsSetStatsUrlPrefix returns true if StatsUrlPrefix is not nil.
func (v *ServerInfo) IsSetStatsUrlPrefix() bool {
	return v != nil && v.StatsUrlPrefix != nil
}

// Result of the startUpdate call.
type StartJobUpdateResult struct {
	// Unique identifier for the job update.
	Key *JobUpdateKey `json:"key,omitempty"`
	// Summary of the update that is in progress for the given JobKey.
	UpdateSummary *JobUpdateSummary `json:"updateSummary,omitempty"`
}

// ToWire translates a StartJobUpdateResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *StartJobUpdateResult) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Key != nil {
		w, err = v.Key.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.UpdateSummary != nil {
		w, err = v.UpdateSummary.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a StartJobUpdateResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a StartJobUpdateResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v StartJobUpdateResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *StartJobUpdateResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Key, err = _JobUpdateKey_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.UpdateSummary, err = _JobUpdateSummary_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a StartJobUpdateResult
// struct.
func (v *StartJobUpdateResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Key != nil {
		fields[i] = fmt.Sprintf("Key: %v", v.Key)
		i++
	}
	if v.UpdateSummary != nil {
		fields[i] = fmt.Sprintf("UpdateSummary: %v", v.UpdateSummary)
		i++
	}

	return fmt.Sprintf("StartJobUpdateResult{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this StartJobUpdateResult match the
// provided StartJobUpdateResult.
//
// This function performs a deep comparison.
func (v *StartJobUpdateResult) Equals(rhs *StartJobUpdateResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Key == nil && rhs.Key == nil) || (v.Key != nil && rhs.Key != nil && v.Key.Equals(rhs.Key))) {
		return false
	}
	if !((v.UpdateSummary == nil && rhs.UpdateSummary == nil) || (v.UpdateSummary != nil && rhs.UpdateSummary != nil && v.UpdateSummary.Equals(rhs.UpdateSummary))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of StartJobUpdateResult.
func (v *StartJobUpdateResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Key != nil {
		err = multierr.Append(err, enc.AddObject("key", v.Key))
	}
	if v.UpdateSummary != nil {
		err = multierr.Append(err, enc.AddObject("updateSummary", v.UpdateSummary))
	}
	return err
}

// GetKey returns the value of Key if it is set or its
// zero value if it is unset.
func (v *StartJobUpdateResult) GetKey() (o *JobUpdateKey) {
	if v != nil && v.Key != nil {
		return v.Key
	}

	return
}

// IsSetKey returns true if Key is not nil.
func (v *StartJobUpdateResult) IsSetKey() bool {
	return v != nil && v.Key != nil
}

// GetUpdateSummary returns the value of UpdateSummary if it is set or its
// zero value if it is unset.
func (v *StartJobUpdateResult) GetUpdateSummary() (o *JobUpdateSummary) {
	if v != nil && v.UpdateSummary != nil {
		return v.UpdateSummary
	}

	return
}

// IsSetUpdateSummary returns true if UpdateSummary is not nil.
func (v *StartJobUpdateResult) IsSetUpdateSummary() bool {
	return v != nil && v.UpdateSummary != nil
}

type StartMaintenanceResult struct {
	Statuses []*HostStatus `json:"statuses,omitempty"`
}

// ToWire translates a StartMaintenanceResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *StartMaintenanceResult) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Statuses != nil {
		w, err = wire.NewValueSet(_Set_HostStatus_sliceType_ValueList(v.Statuses)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a StartMaintenanceResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a StartMaintenanceResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v StartMaintenanceResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *StartMaintenanceResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TSet {
				v.Statuses, err = _Set_HostStatus_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a StartMaintenanceResult
// struct.
func (v *StartMaintenanceResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Statuses != nil {
		fields[i] = fmt.Sprintf("Statuses: %v", v.Statuses)
		i++
	}

	return fmt.Sprintf("StartMaintenanceResult{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this StartMaintenanceResult match the
// provided StartMaintenanceResult.
//
// This function performs a deep comparison.
func (v *StartMaintenanceResult) Equals(rhs *StartMaintenanceResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Statuses == nil && rhs.Statuses == nil) || (v.Statuses != nil && rhs.Statuses != nil && _Set_HostStatus_sliceType_Equals(v.Statuses, rhs.Statuses))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of StartMaintenanceResult.
func (v *StartMaintenanceResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Statuses != nil {
		err = multierr.Append(err, enc.AddArray("statuses", (_Set_HostStatus_sliceType_Zapper)(v.Statuses)))
	}
	return err
}

// GetStatuses returns the value of Statuses if it is set or its
// zero value if it is unset.
func (v *StartMaintenanceResult) GetStatuses() (o []*HostStatus) {
	if v != nil && v.Statuses != nil {
		return v.Statuses
	}

	return
}

// IsSetStatuses returns true if Statuses is not nil.
func (v *StartMaintenanceResult) IsSetStatuses() bool {
	return v != nil && v.Statuses != nil
}

// Description of the tasks contained within a job.
type TaskConfig struct {
	// Job task belongs to.
	Job *JobKey `json:"job,omitempty"`
	// contains the role component of JobKey
	Owner           *Identity `json:"owner,omitempty"`
	IsService       *bool     `json:"isService,omitempty"`
	NumCpus         *float64  `json:"numCpus,omitempty"`
	RamMb           *int64    `json:"ramMb,omitempty"`
	DiskMb          *int64    `json:"diskMb,omitempty"`
	Priority        *int32    `json:"priority,omitempty"`
	MaxTaskFailures *int32    `json:"maxTaskFailures,omitempty"`
	// Whether this is a production task, which can preempt.
	Production *bool `json:"production,omitempty"`
	// Task tier type.
	Tier *string `json:"tier,omitempty"`
	// All resources required to run a task.
	Resources   []*Resource   `json:"resources,omitempty"`
	Constraints []*Constraint `json:"constraints,omitempty"`
	// a list of named ports this task requests
	RequestedPorts map[string]struct{} `json:"requestedPorts,omitempty"`
	// Resources to retrieve with Mesos Fetcher
	MesosFetcherUris []*MesosFetcherURI `json:"mesosFetcherUris,omitempty"`
	// Custom links to include when displaying this task on the scheduler dashboard. Keys are anchor
	// text, values are URLs. Wildcards are supported for dynamic link crafting based on host, ports,
	// instance, etc.
	TaskLinks    map[string]string `json:"taskLinks,omitempty"`
	ContactEmail *string           `json:"contactEmail,omitempty"`
	// Executor configuration
	ExecutorConfig *ExecutorConfig `json:"executorConfig,omitempty"`
	// Used to display additional details in the UI.
	Metadata []*Metadata `json:"metadata,omitempty"`
	// the container the task should use to execute
	Container *Container `json:"container,omitempty"`
}

type _Set_Constraint_sliceType_ValueList []*Constraint

func (v _Set_Constraint_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_Constraint_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_Constraint_sliceType_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_Constraint_sliceType_ValueList) Close() {}

type _Set_MesosFetcherURI_sliceType_ValueList []*MesosFetcherURI

func (v _Set_MesosFetcherURI_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_MesosFetcherURI_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_MesosFetcherURI_sliceType_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_MesosFetcherURI_sliceType_ValueList) Close() {}

type _Map_String_String_MapItemList map[string]string

func (m _Map_String_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueString(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_String_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) Close() {}

// ToWire translates a TaskConfig struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *TaskConfig) ToWire() (wire.Value, error) {
	var (
		fields [19]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Job != nil {
		w, err = v.Job.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 28, Value: w}
		i++
	}
	if v.Owner != nil {
		w, err = v.Owner.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 17, Value: w}
		i++
	}
	if v.IsService != nil {
		w, err = wire.NewValueBool(*(v.IsService)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}
	if v.NumCpus != nil {
		w, err = wire.NewValueDouble(*(v.NumCpus)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 8, Value: w}
		i++
	}
	if v.RamMb != nil {
		w, err = wire.NewValueI64(*(v.RamMb)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 9, Value: w}
		i++
	}
	if v.DiskMb != nil {
		w, err = wire.NewValueI64(*(v.DiskMb)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Priority != nil {
		w, err = wire.NewValueI32(*(v.Priority)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 11, Value: w}
		i++
	}
	if v.MaxTaskFailures != nil {
		w, err = wire.NewValueI32(*(v.MaxTaskFailures)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 13, Value: w}
		i++
	}
	if v.Production != nil {
		w, err = wire.NewValueBool(*(v.Production)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 18, Value: w}
		i++
	}
	if v.Tier != nil {
		w, err = wire.NewValueString(*(v.Tier)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.Resources != nil {
		w, err = wire.NewValueSet(_Set_Resource_sliceType_ValueList(v.Resources)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 32, Value: w}
		i++
	}
	if v.Constraints != nil {
		w, err = wire.NewValueSet(_Set_Constraint_sliceType_ValueList(v.Constraints)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.RequestedPorts != nil {
		w, err = wire.NewValueSet(_Set_String_mapType_ValueList(v.RequestedPorts)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 21, Value: w}
		i++
	}
	if v.MesosFetcherUris != nil {
		w, err = wire.NewValueSet(_Set_MesosFetcherURI_sliceType_ValueList(v.MesosFetcherUris)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 33, Value: w}
		i++
	}
	if v.TaskLinks != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.TaskLinks)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 22, Value: w}
		i++
	}
	if v.ContactEmail != nil {
		w, err = wire.NewValueString(*(v.ContactEmail)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 23, Value: w}
		i++
	}
	if v.ExecutorConfig != nil {
		w, err = v.ExecutorConfig.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 25, Value: w}
		i++
	}
	if v.Metadata != nil {
		w, err = wire.NewValueSet(_Set_Metadata_sliceType_ValueList(v.Metadata)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 27, Value: w}
		i++
	}
	if v.Container == nil {
		v.Container = &Container{
			Mesos: &MesosContainer{},
		}
	}
	{
		w, err = v.Container.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 29, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Constraint_Read(w wire.Value) (*Constraint, error) {
	var v Constraint
	err := v.FromWire(w)
	return &v, err
}

func _Set_Constraint_sliceType_Read(s wire.ValueList) ([]*Constraint, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Constraint, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _Constraint_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

func _MesosFetcherURI_Read(w wire.Value) (*MesosFetcherURI, error) {
	var v MesosFetcherURI
	err := v.FromWire(w)
	return &v, err
}

func _Set_MesosFetcherURI_sliceType_Read(s wire.ValueList) ([]*MesosFetcherURI, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*MesosFetcherURI, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _MesosFetcherURI_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

func _Map_String_String_Read(m wire.MapItemList) (map[string]string, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string]string, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _ExecutorConfig_Read(w wire.Value) (*ExecutorConfig, error) {
	var v ExecutorConfig
	err := v.FromWire(w)
	return &v, err
}

func _Container_Read(w wire.Value) (*Container, error) {
	var v Container
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a TaskConfig struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TaskConfig struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v TaskConfig
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *TaskConfig) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 28:
			if field.Value.Type() == wire.TStruct {
				v.Job, err = _JobKey_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 17:
			if field.Value.Type() == wire.TStruct {
				v.Owner, err = _Identity_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 7:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.IsService = &x
				if err != nil {
					return err
				}

			}
		case 8:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.NumCpus = &x
				if err != nil {
					return err
				}

			}
		case 9:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.RamMb = &x
				if err != nil {
					return err
				}

			}
		case 10:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.DiskMb = &x
				if err != nil {
					return err
				}

			}
		case 11:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Priority = &x
				if err != nil {
					return err
				}

			}
		case 13:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.MaxTaskFailures = &x
				if err != nil {
					return err
				}

			}
		case 18:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.Production = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Tier = &x
				if err != nil {
					return err
				}

			}
		case 32:
			if field.Value.Type() == wire.TSet {
				v.Resources, err = _Set_Resource_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TSet {
				v.Constraints, err = _Set_Constraint_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 21:
			if field.Value.Type() == wire.TSet {
				v.RequestedPorts, err = _Set_String_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 33:
			if field.Value.Type() == wire.TSet {
				v.MesosFetcherUris, err = _Set_MesosFetcherURI_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 22:
			if field.Value.Type() == wire.TMap {
				v.TaskLinks, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 23:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ContactEmail = &x
				if err != nil {
					return err
				}

			}
		case 25:
			if field.Value.Type() == wire.TStruct {
				v.ExecutorConfig, err = _ExecutorConfig_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 27:
			if field.Value.Type() == wire.TSet {
				v.Metadata, err = _Set_Metadata_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 29:
			if field.Value.Type() == wire.TStruct {
				v.Container, err = _Container_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	if v.Container == nil {
		v.Container = &Container{
			Mesos: &MesosContainer{},
		}
	}

	return nil
}

// String returns a readable string representation of a TaskConfig
// struct.
func (v *TaskConfig) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [19]string
	i := 0
	if v.Job != nil {
		fields[i] = fmt.Sprintf("Job: %v", v.Job)
		i++
	}
	if v.Owner != nil {
		fields[i] = fmt.Sprintf("Owner: %v", v.Owner)
		i++
	}
	if v.IsService != nil {
		fields[i] = fmt.Sprintf("IsService: %v", *(v.IsService))
		i++
	}
	if v.NumCpus != nil {
		fields[i] = fmt.Sprintf("NumCpus: %v", *(v.NumCpus))
		i++
	}
	if v.RamMb != nil {
		fields[i] = fmt.Sprintf("RamMb: %v", *(v.RamMb))
		i++
	}
	if v.DiskMb != nil {
		fields[i] = fmt.Sprintf("DiskMb: %v", *(v.DiskMb))
		i++
	}
	if v.Priority != nil {
		fields[i] = fmt.Sprintf("Priority: %v", *(v.Priority))
		i++
	}
	if v.MaxTaskFailures != nil {
		fields[i] = fmt.Sprintf("MaxTaskFailures: %v", *(v.MaxTaskFailures))
		i++
	}
	if v.Production != nil {
		fields[i] = fmt.Sprintf("Production: %v", *(v.Production))
		i++
	}
	if v.Tier != nil {
		fields[i] = fmt.Sprintf("Tier: %v", *(v.Tier))
		i++
	}
	if v.Resources != nil {
		fields[i] = fmt.Sprintf("Resources: %v", v.Resources)
		i++
	}
	if v.Constraints != nil {
		fields[i] = fmt.Sprintf("Constraints: %v", v.Constraints)
		i++
	}
	if v.RequestedPorts != nil {
		fields[i] = fmt.Sprintf("RequestedPorts: %v", v.RequestedPorts)
		i++
	}
	if v.MesosFetcherUris != nil {
		fields[i] = fmt.Sprintf("MesosFetcherUris: %v", v.MesosFetcherUris)
		i++
	}
	if v.TaskLinks != nil {
		fields[i] = fmt.Sprintf("TaskLinks: %v", v.TaskLinks)
		i++
	}
	if v.ContactEmail != nil {
		fields[i] = fmt.Sprintf("ContactEmail: %v", *(v.ContactEmail))
		i++
	}
	if v.ExecutorConfig != nil {
		fields[i] = fmt.Sprintf("ExecutorConfig: %v", v.ExecutorConfig)
		i++
	}
	if v.Metadata != nil {
		fields[i] = fmt.Sprintf("Metadata: %v", v.Metadata)
		i++
	}
	if v.Container != nil {
		fields[i] = fmt.Sprintf("Container: %v", v.Container)
		i++
	}

	return fmt.Sprintf("TaskConfig{%v}", strings.Join(fields[:i], ", "))
}

func _Set_Constraint_sliceType_Equals(lhs, rhs []*Constraint) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

func _Set_MesosFetcherURI_sliceType_Equals(lhs, rhs []*MesosFetcherURI) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

func _Map_String_String_Equals(lhs, rhs map[string]string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this TaskConfig match the
// provided TaskConfig.
//
// This function performs a deep comparison.
func (v *TaskConfig) Equals(rhs *TaskConfig) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Job == nil && rhs.Job == nil) || (v.Job != nil && rhs.Job != nil && v.Job.Equals(rhs.Job))) {
		return false
	}
	if !((v.Owner == nil && rhs.Owner == nil) || (v.Owner != nil && rhs.Owner != nil && v.Owner.Equals(rhs.Owner))) {
		return false
	}
	if !_Bool_EqualsPtr(v.IsService, rhs.IsService) {
		return false
	}
	if !_Double_EqualsPtr(v.NumCpus, rhs.NumCpus) {
		return false
	}
	if !_I64_EqualsPtr(v.RamMb, rhs.RamMb) {
		return false
	}
	if !_I64_EqualsPtr(v.DiskMb, rhs.DiskMb) {
		return false
	}
	if !_I32_EqualsPtr(v.Priority, rhs.Priority) {
		return false
	}
	if !_I32_EqualsPtr(v.MaxTaskFailures, rhs.MaxTaskFailures) {
		return false
	}
	if !_Bool_EqualsPtr(v.Production, rhs.Production) {
		return false
	}
	if !_String_EqualsPtr(v.Tier, rhs.Tier) {
		return false
	}
	if !((v.Resources == nil && rhs.Resources == nil) || (v.Resources != nil && rhs.Resources != nil && _Set_Resource_sliceType_Equals(v.Resources, rhs.Resources))) {
		return false
	}
	if !((v.Constraints == nil && rhs.Constraints == nil) || (v.Constraints != nil && rhs.Constraints != nil && _Set_Constraint_sliceType_Equals(v.Constraints, rhs.Constraints))) {
		return false
	}
	if !((v.RequestedPorts == nil && rhs.RequestedPorts == nil) || (v.RequestedPorts != nil && rhs.RequestedPorts != nil && _Set_String_mapType_Equals(v.RequestedPorts, rhs.RequestedPorts))) {
		return false
	}
	if !((v.MesosFetcherUris == nil && rhs.MesosFetcherUris == nil) || (v.MesosFetcherUris != nil && rhs.MesosFetcherUris != nil && _Set_MesosFetcherURI_sliceType_Equals(v.MesosFetcherUris, rhs.MesosFetcherUris))) {
		return false
	}
	if !((v.TaskLinks == nil && rhs.TaskLinks == nil) || (v.TaskLinks != nil && rhs.TaskLinks != nil && _Map_String_String_Equals(v.TaskLinks, rhs.TaskLinks))) {
		return false
	}
	if !_String_EqualsPtr(v.ContactEmail, rhs.ContactEmail) {
		return false
	}
	if !((v.ExecutorConfig == nil && rhs.ExecutorConfig == nil) || (v.ExecutorConfig != nil && rhs.ExecutorConfig != nil && v.ExecutorConfig.Equals(rhs.ExecutorConfig))) {
		return false
	}
	if !((v.Metadata == nil && rhs.Metadata == nil) || (v.Metadata != nil && rhs.Metadata != nil && _Set_Metadata_sliceType_Equals(v.Metadata, rhs.Metadata))) {
		return false
	}
	if !((v.Container == nil && rhs.Container == nil) || (v.Container != nil && rhs.Container != nil && v.Container.Equals(rhs.Container))) {
		return false
	}

	return true
}

type _Set_Constraint_sliceType_Zapper []*Constraint

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_Constraint_sliceType_Zapper.
func (s _Set_Constraint_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

type _Set_MesosFetcherURI_sliceType_Zapper []*MesosFetcherURI

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_MesosFetcherURI_sliceType_Zapper.
func (s _Set_MesosFetcherURI_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

type _Map_String_String_Zapper map[string]string

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_String_Zapper.
func (m _Map_String_String_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		enc.AddString((string)(k), v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TaskConfig.
func (v *TaskConfig) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Job != nil {
		err = multierr.Append(err, enc.AddObject("job", v.Job))
	}
	if v.Owner != nil {
		err = multierr.Append(err, enc.AddObject("owner", v.Owner))
	}
	if v.IsService != nil {
		enc.AddBool("isService", *v.IsService)
	}
	if v.NumCpus != nil {
		enc.AddFloat64("numCpus", *v.NumCpus)
	}
	if v.RamMb != nil {
		enc.AddInt64("ramMb", *v.RamMb)
	}
	if v.DiskMb != nil {
		enc.AddInt64("diskMb", *v.DiskMb)
	}
	if v.Priority != nil {
		enc.AddInt32("priority", *v.Priority)
	}
	if v.MaxTaskFailures != nil {
		enc.AddInt32("maxTaskFailures", *v.MaxTaskFailures)
	}
	if v.Production != nil {
		enc.AddBool("production", *v.Production)
	}
	if v.Tier != nil {
		enc.AddString("tier", *v.Tier)
	}
	if v.Resources != nil {
		err = multierr.Append(err, enc.AddArray("resources", (_Set_Resource_sliceType_Zapper)(v.Resources)))
	}
	if v.Constraints != nil {
		err = multierr.Append(err, enc.AddArray("constraints", (_Set_Constraint_sliceType_Zapper)(v.Constraints)))
	}
	if v.RequestedPorts != nil {
		err = multierr.Append(err, enc.AddArray("requestedPorts", (_Set_String_mapType_Zapper)(v.RequestedPorts)))
	}
	if v.MesosFetcherUris != nil {
		err = multierr.Append(err, enc.AddArray("mesosFetcherUris", (_Set_MesosFetcherURI_sliceType_Zapper)(v.MesosFetcherUris)))
	}
	if v.TaskLinks != nil {
		err = multierr.Append(err, enc.AddObject("taskLinks", (_Map_String_String_Zapper)(v.TaskLinks)))
	}
	if v.ContactEmail != nil {
		enc.AddString("contactEmail", *v.ContactEmail)
	}
	if v.ExecutorConfig != nil {
		err = multierr.Append(err, enc.AddObject("executorConfig", v.ExecutorConfig))
	}
	if v.Metadata != nil {
		err = multierr.Append(err, enc.AddArray("metadata", (_Set_Metadata_sliceType_Zapper)(v.Metadata)))
	}
	if v.Container != nil {
		err = multierr.Append(err, enc.AddObject("container", v.Container))
	}
	return err
}

// GetJob returns the value of Job if it is set or its
// zero value if it is unset.
func (v *TaskConfig) GetJob() (o *JobKey) {
	if v != nil && v.Job != nil {
		return v.Job
	}

	return
}

// IsSetJob returns true if Job is not nil.
func (v *TaskConfig) IsSetJob() bool {
	return v != nil && v.Job != nil
}

// GetOwner returns the value of Owner if it is set or its
// zero value if it is unset.
func (v *TaskConfig) GetOwner() (o *Identity) {
	if v != nil && v.Owner != nil {
		return v.Owner
	}

	return
}

// IsSetOwner returns true if Owner is not nil.
func (v *TaskConfig) IsSetOwner() bool {
	return v != nil && v.Owner != nil
}

// GetIsService returns the value of IsService if it is set or its
// zero value if it is unset.
func (v *TaskConfig) GetIsService() (o bool) {
	if v != nil && v.IsService != nil {
		return *v.IsService
	}

	return
}

// IsSetIsService returns true if IsService is not nil.
func (v *TaskConfig) IsSetIsService() bool {
	return v != nil && v.IsService != nil
}

// GetNumCpus returns the value of NumCpus if it is set or its
// zero value if it is unset.
func (v *TaskConfig) GetNumCpus() (o float64) {
	if v != nil && v.NumCpus != nil {
		return *v.NumCpus
	}

	return
}

// IsSetNumCpus returns true if NumCpus is not nil.
func (v *TaskConfig) IsSetNumCpus() bool {
	return v != nil && v.NumCpus != nil
}

// GetRamMb returns the value of RamMb if it is set or its
// zero value if it is unset.
func (v *TaskConfig) GetRamMb() (o int64) {
	if v != nil && v.RamMb != nil {
		return *v.RamMb
	}

	return
}

// IsSetRamMb returns true if RamMb is not nil.
func (v *TaskConfig) IsSetRamMb() bool {
	return v != nil && v.RamMb != nil
}

// GetDiskMb returns the value of DiskMb if it is set or its
// zero value if it is unset.
func (v *TaskConfig) GetDiskMb() (o int64) {
	if v != nil && v.DiskMb != nil {
		return *v.DiskMb
	}

	return
}

// IsSetDiskMb returns true if DiskMb is not nil.
func (v *TaskConfig) IsSetDiskMb() bool {
	return v != nil && v.DiskMb != nil
}

// GetPriority returns the value of Priority if it is set or its
// zero value if it is unset.
func (v *TaskConfig) GetPriority() (o int32) {
	if v != nil && v.Priority != nil {
		return *v.Priority
	}

	return
}

// IsSetPriority returns true if Priority is not nil.
func (v *TaskConfig) IsSetPriority() bool {
	return v != nil && v.Priority != nil
}

// GetMaxTaskFailures returns the value of MaxTaskFailures if it is set or its
// zero value if it is unset.
func (v *TaskConfig) GetMaxTaskFailures() (o int32) {
	if v != nil && v.MaxTaskFailures != nil {
		return *v.MaxTaskFailures
	}

	return
}

// IsSetMaxTaskFailures returns true if MaxTaskFailures is not nil.
func (v *TaskConfig) IsSetMaxTaskFailures() bool {
	return v != nil && v.MaxTaskFailures != nil
}

// GetProduction returns the value of Production if it is set or its
// zero value if it is unset.
func (v *TaskConfig) GetProduction() (o bool) {
	if v != nil && v.Production != nil {
		return *v.Production
	}

	return
}

// IsSetProduction returns true if Production is not nil.
func (v *TaskConfig) IsSetProduction() bool {
	return v != nil && v.Production != nil
}

// GetTier returns the value of Tier if it is set or its
// zero value if it is unset.
func (v *TaskConfig) GetTier() (o string) {
	if v != nil && v.Tier != nil {
		return *v.Tier
	}

	return
}

// IsSetTier returns true if Tier is not nil.
func (v *TaskConfig) IsSetTier() bool {
	return v != nil && v.Tier != nil
}

// GetResources returns the value of Resources if it is set or its
// zero value if it is unset.
func (v *TaskConfig) GetResources() (o []*Resource) {
	if v != nil && v.Resources != nil {
		return v.Resources
	}

	return
}

// IsSetResources returns true if Resources is not nil.
func (v *TaskConfig) IsSetResources() bool {
	return v != nil && v.Resources != nil
}

// GetConstraints returns the value of Constraints if it is set or its
// zero value if it is unset.
func (v *TaskConfig) GetConstraints() (o []*Constraint) {
	if v != nil && v.Constraints != nil {
		return v.Constraints
	}

	return
}

// IsSetConstraints returns true if Constraints is not nil.
func (v *TaskConfig) IsSetConstraints() bool {
	return v != nil && v.Constraints != nil
}

// GetRequestedPorts returns the value of RequestedPorts if it is set or its
// zero value if it is unset.
func (v *TaskConfig) GetRequestedPorts() (o map[string]struct{}) {
	if v != nil && v.RequestedPorts != nil {
		return v.RequestedPorts
	}

	return
}

// IsSetRequestedPorts returns true if RequestedPorts is not nil.
func (v *TaskConfig) IsSetRequestedPorts() bool {
	return v != nil && v.RequestedPorts != nil
}

// GetMesosFetcherUris returns the value of MesosFetcherUris if it is set or its
// zero value if it is unset.
func (v *TaskConfig) GetMesosFetcherUris() (o []*MesosFetcherURI) {
	if v != nil && v.MesosFetcherUris != nil {
		return v.MesosFetcherUris
	}

	return
}

// IsSetMesosFetcherUris returns true if MesosFetcherUris is not nil.
func (v *TaskConfig) IsSetMesosFetcherUris() bool {
	return v != nil && v.MesosFetcherUris != nil
}

// GetTaskLinks returns the value of TaskLinks if it is set or its
// zero value if it is unset.
func (v *TaskConfig) GetTaskLinks() (o map[string]string) {
	if v != nil && v.TaskLinks != nil {
		return v.TaskLinks
	}

	return
}

// IsSetTaskLinks returns true if TaskLinks is not nil.
func (v *TaskConfig) IsSetTaskLinks() bool {
	return v != nil && v.TaskLinks != nil
}

// GetContactEmail returns the value of ContactEmail if it is set or its
// zero value if it is unset.
func (v *TaskConfig) GetContactEmail() (o string) {
	if v != nil && v.ContactEmail != nil {
		return *v.ContactEmail
	}

	return
}

// IsSetContactEmail returns true if ContactEmail is not nil.
func (v *TaskConfig) IsSetContactEmail() bool {
	return v != nil && v.ContactEmail != nil
}

// GetExecutorConfig returns the value of ExecutorConfig if it is set or its
// zero value if it is unset.
func (v *TaskConfig) GetExecutorConfig() (o *ExecutorConfig) {
	if v != nil && v.ExecutorConfig != nil {
		return v.ExecutorConfig
	}

	return
}

// IsSetExecutorConfig returns true if ExecutorConfig is not nil.
func (v *TaskConfig) IsSetExecutorConfig() bool {
	return v != nil && v.ExecutorConfig != nil
}

// GetMetadata returns the value of Metadata if it is set or its
// zero value if it is unset.
func (v *TaskConfig) GetMetadata() (o []*Metadata) {
	if v != nil && v.Metadata != nil {
		return v.Metadata
	}

	return
}

// IsSetMetadata returns true if Metadata is not nil.
func (v *TaskConfig) IsSetMetadata() bool {
	return v != nil && v.Metadata != nil
}

// GetContainer returns the value of Container if it is set or its
// default value if it is unset.
func (v *TaskConfig) GetContainer() (o *Container) {
	if v != nil && v.Container != nil {
		return v.Container
	}
	o = &Container{
		Mesos: &MesosContainer{},
	}
	return
}

// IsSetContainer returns true if Container is not nil.
func (v *TaskConfig) IsSetContainer() bool {
	return v != nil && v.Container != nil
}

// Types of constraints that may be applied to a task.
type TaskConstraint struct {
	Value *ValueConstraint `json:"value,omitempty"`
	Limit *LimitConstraint `json:"limit,omitempty"`
}

// ToWire translates a TaskConstraint struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *TaskConstraint) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Value != nil {
		w, err = v.Value.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Limit != nil {
		w, err = v.Limit.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("TaskConstraint should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ValueConstraint_Read(w wire.Value) (*ValueConstraint, error) {
	var v ValueConstraint
	err := v.FromWire(w)
	return &v, err
}

func _LimitConstraint_Read(w wire.Value) (*LimitConstraint, error) {
	var v LimitConstraint
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a TaskConstraint struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TaskConstraint struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v TaskConstraint
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *TaskConstraint) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Value, err = _ValueConstraint_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Limit, err = _LimitConstraint_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Value != nil {
		count++
	}
	if v.Limit != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("TaskConstraint should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a TaskConstraint
// struct.
func (v *TaskConstraint) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Value != nil {
		fields[i] = fmt.Sprintf("Value: %v", v.Value)
		i++
	}
	if v.Limit != nil {
		fields[i] = fmt.Sprintf("Limit: %v", v.Limit)
		i++
	}

	return fmt.Sprintf("TaskConstraint{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this TaskConstraint match the
// provided TaskConstraint.
//
// This function performs a deep comparison.
func (v *TaskConstraint) Equals(rhs *TaskConstraint) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Value == nil && rhs.Value == nil) || (v.Value != nil && rhs.Value != nil && v.Value.Equals(rhs.Value))) {
		return false
	}
	if !((v.Limit == nil && rhs.Limit == nil) || (v.Limit != nil && rhs.Limit != nil && v.Limit.Equals(rhs.Limit))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TaskConstraint.
func (v *TaskConstraint) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Value != nil {
		err = multierr.Append(err, enc.AddObject("value", v.Value))
	}
	if v.Limit != nil {
		err = multierr.Append(err, enc.AddObject("limit", v.Limit))
	}
	return err
}

// GetValue returns the value of Value if it is set or its
// zero value if it is unset.
func (v *TaskConstraint) GetValue() (o *ValueConstraint) {
	if v != nil && v.Value != nil {
		return v.Value
	}

	return
}

// IsSetValue returns true if Value is not nil.
func (v *TaskConstraint) IsSetValue() bool {
	return v != nil && v.Value != nil
}

// GetLimit returns the value of Limit if it is set or its
// zero value if it is unset.
func (v *TaskConstraint) GetLimit() (o *LimitConstraint) {
	if v != nil && v.Limit != nil {
		return v.Limit
	}

	return
}

// IsSetLimit returns true if Limit is not nil.
func (v *TaskConstraint) IsSetLimit() bool {
	return v != nil && v.Limit != nil
}

// Event marking a state transition within a task's lifecycle.
type TaskEvent struct {
	// Epoch timestamp in milliseconds.
	Timestamp *int64 `json:"timestamp,omitempty"`
	// New status of the task.
	Status *ScheduleStatus `json:"status,omitempty"`
	// Audit message that explains why a transition occurred.
	Message *string `json:"message,omitempty"`
	// Hostname of the scheduler machine that performed the event.
	Scheduler *string `json:"scheduler,omitempty"`
}

// ToWire translates a TaskEvent struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *TaskEvent) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Timestamp != nil {
		w, err = wire.NewValueI64(*(v.Timestamp)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Status != nil {
		w, err = v.Status.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Scheduler != nil {
		w, err = wire.NewValueString(*(v.Scheduler)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a TaskEvent struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TaskEvent struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v TaskEvent
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *TaskEvent) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Timestamp = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x ScheduleStatus
				x, err = _ScheduleStatus_Read(field.Value)
				v.Status = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Scheduler = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a TaskEvent
// struct.
func (v *TaskEvent) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Timestamp != nil {
		fields[i] = fmt.Sprintf("Timestamp: %v", *(v.Timestamp))
		i++
	}
	if v.Status != nil {
		fields[i] = fmt.Sprintf("Status: %v", *(v.Status))
		i++
	}
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}
	if v.Scheduler != nil {
		fields[i] = fmt.Sprintf("Scheduler: %v", *(v.Scheduler))
		i++
	}

	return fmt.Sprintf("TaskEvent{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this TaskEvent match the
// provided TaskEvent.
//
// This function performs a deep comparison.
func (v *TaskEvent) Equals(rhs *TaskEvent) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.Timestamp, rhs.Timestamp) {
		return false
	}
	if !_ScheduleStatus_EqualsPtr(v.Status, rhs.Status) {
		return false
	}
	if !_String_EqualsPtr(v.Message, rhs.Message) {
		return false
	}
	if !_String_EqualsPtr(v.Scheduler, rhs.Scheduler) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TaskEvent.
func (v *TaskEvent) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Timestamp != nil {
		enc.AddInt64("timestamp", *v.Timestamp)
	}
	if v.Status != nil {
		err = multierr.Append(err, enc.AddObject("status", *v.Status))
	}
	if v.Message != nil {
		enc.AddString("message", *v.Message)
	}
	if v.Scheduler != nil {
		enc.AddString("scheduler", *v.Scheduler)
	}
	return err
}

// GetTimestamp returns the value of Timestamp if it is set or its
// zero value if it is unset.
func (v *TaskEvent) GetTimestamp() (o int64) {
	if v != nil && v.Timestamp != nil {
		return *v.Timestamp
	}

	return
}

// IsSetTimestamp returns true if Timestamp is not nil.
func (v *TaskEvent) IsSetTimestamp() bool {
	return v != nil && v.Timestamp != nil
}

// GetStatus returns the value of Status if it is set or its
// zero value if it is unset.
func (v *TaskEvent) GetStatus() (o ScheduleStatus) {
	if v != nil && v.Status != nil {
		return *v.Status
	}

	return
}

// IsSetStatus returns true if Status is not nil.
func (v *TaskEvent) IsSetStatus() bool {
	return v != nil && v.Status != nil
}

// GetMessage returns the value of Message if it is set or its
// zero value if it is unset.
func (v *TaskEvent) GetMessage() (o string) {
	if v != nil && v.Message != nil {
		return *v.Message
	}

	return
}

// IsSetMessage returns true if Message is not nil.
func (v *TaskEvent) IsSetMessage() bool {
	return v != nil && v.Message != nil
}

// GetScheduler returns the value of Scheduler if it is set or its
// zero value if it is unset.
func (v *TaskEvent) GetScheduler() (o string) {
	if v != nil && v.Scheduler != nil {
		return *v.Scheduler
	}

	return
}

// IsSetScheduler returns true if Scheduler is not nil.
func (v *TaskEvent) IsSetScheduler() bool {
	return v != nil && v.Scheduler != nil
}

// Contains a set of restrictions on matching tasks where all restrictions must be met
// (terms are AND'ed together).
type TaskQuery struct {
	Role        *string                     `json:"role,omitempty"`
	Environment *string                     `json:"environment,omitempty"`
	JobName     *string                     `json:"jobName,omitempty"`
	TaskIds     map[string]struct{}         `json:"taskIds,omitempty"`
	Statuses    map[ScheduleStatus]struct{} `json:"statuses,omitempty"`
	InstanceIds map[int32]struct{}          `json:"instanceIds,omitempty"`
	SlaveHosts  map[string]struct{}         `json:"slaveHosts,omitempty"`
	JobKeys     []*JobKey                   `json:"jobKeys,omitempty"`
	Offset      *int32                      `json:"offset,omitempty"`
	Limit       *int32                      `json:"limit,omitempty"`
}

type _Set_ScheduleStatus_mapType_ValueList map[ScheduleStatus]struct{}

func (v _Set_ScheduleStatus_mapType_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_ScheduleStatus_mapType_ValueList) Size() int {
	return len(v)
}

func (_Set_ScheduleStatus_mapType_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_Set_ScheduleStatus_mapType_ValueList) Close() {}

type _Set_I32_mapType_ValueList map[int32]struct{}

func (v _Set_I32_mapType_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		w, err := wire.NewValueI32(x), error(nil)
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_I32_mapType_ValueList) Size() int {
	return len(v)
}

func (_Set_I32_mapType_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_Set_I32_mapType_ValueList) Close() {}

type _Set_JobKey_sliceType_ValueList []*JobKey

func (v _Set_JobKey_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_JobKey_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_JobKey_sliceType_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_JobKey_sliceType_ValueList) Close() {}

// ToWire translates a TaskQuery struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *TaskQuery) ToWire() (wire.Value, error) {
	var (
		fields [10]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Role != nil {
		w, err = wire.NewValueString(*(v.Role)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}
	if v.Environment != nil {
		w, err = wire.NewValueString(*(v.Environment)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 9, Value: w}
		i++
	}
	if v.JobName != nil {
		w, err = wire.NewValueString(*(v.JobName)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.TaskIds != nil {
		w, err = wire.NewValueSet(_Set_String_mapType_ValueList(v.TaskIds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Statuses != nil {
		w, err = wire.NewValueSet(_Set_ScheduleStatus_mapType_ValueList(v.Statuses)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.InstanceIds != nil {
		w, err = wire.NewValueSet(_Set_I32_mapType_ValueList(v.InstanceIds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}
	if v.SlaveHosts != nil {
		w, err = wire.NewValueSet(_Set_String_mapType_ValueList(v.SlaveHosts)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.JobKeys != nil {
		w, err = wire.NewValueSet(_Set_JobKey_sliceType_ValueList(v.JobKeys)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 11, Value: w}
		i++
	}
	if v.Offset != nil {
		w, err = wire.NewValueI32(*(v.Offset)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	if v.Limit != nil {
		w, err = wire.NewValueI32(*(v.Limit)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 13, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Set_ScheduleStatus_mapType_Read(s wire.ValueList) (map[ScheduleStatus]struct{}, error) {
	if s.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make(map[ScheduleStatus]struct{}, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _ScheduleStatus_Read(x)
		if err != nil {
			return err
		}

		o[i] = struct{}{}
		return nil
	})
	s.Close()
	return o, err
}

func _Set_I32_mapType_Read(s wire.ValueList) (map[int32]struct{}, error) {
	if s.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make(map[int32]struct{}, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := x.GetI32(), error(nil)
		if err != nil {
			return err
		}

		o[i] = struct{}{}
		return nil
	})
	s.Close()
	return o, err
}

func _Set_JobKey_sliceType_Read(s wire.ValueList) ([]*JobKey, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*JobKey, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _JobKey_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

// FromWire deserializes a TaskQuery struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TaskQuery struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v TaskQuery
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *TaskQuery) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 14:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Role = &x
				if err != nil {
					return err
				}

			}
		case 9:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Environment = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.JobName = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TSet {
				v.TaskIds, err = _Set_String_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TSet {
				v.Statuses, err = _Set_ScheduleStatus_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 7:
			if field.Value.Type() == wire.TSet {
				v.InstanceIds, err = _Set_I32_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 10:
			if field.Value.Type() == wire.TSet {
				v.SlaveHosts, err = _Set_String_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 11:
			if field.Value.Type() == wire.TSet {
				v.JobKeys, err = _Set_JobKey_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Offset = &x
				if err != nil {
					return err
				}

			}
		case 13:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Limit = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a TaskQuery
// struct.
func (v *TaskQuery) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [10]string
	i := 0
	if v.Role != nil {
		fields[i] = fmt.Sprintf("Role: %v", *(v.Role))
		i++
	}
	if v.Environment != nil {
		fields[i] = fmt.Sprintf("Environment: %v", *(v.Environment))
		i++
	}
	if v.JobName != nil {
		fields[i] = fmt.Sprintf("JobName: %v", *(v.JobName))
		i++
	}
	if v.TaskIds != nil {
		fields[i] = fmt.Sprintf("TaskIds: %v", v.TaskIds)
		i++
	}
	if v.Statuses != nil {
		fields[i] = fmt.Sprintf("Statuses: %v", v.Statuses)
		i++
	}
	if v.InstanceIds != nil {
		fields[i] = fmt.Sprintf("InstanceIds: %v", v.InstanceIds)
		i++
	}
	if v.SlaveHosts != nil {
		fields[i] = fmt.Sprintf("SlaveHosts: %v", v.SlaveHosts)
		i++
	}
	if v.JobKeys != nil {
		fields[i] = fmt.Sprintf("JobKeys: %v", v.JobKeys)
		i++
	}
	if v.Offset != nil {
		fields[i] = fmt.Sprintf("Offset: %v", *(v.Offset))
		i++
	}
	if v.Limit != nil {
		fields[i] = fmt.Sprintf("Limit: %v", *(v.Limit))
		i++
	}

	return fmt.Sprintf("TaskQuery{%v}", strings.Join(fields[:i], ", "))
}

func _Set_ScheduleStatus_mapType_Equals(lhs, rhs map[ScheduleStatus]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for x := range rhs {
		if _, ok := lhs[x]; !ok {
			return false
		}
	}

	return true
}

func _Set_I32_mapType_Equals(lhs, rhs map[int32]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for x := range rhs {
		if _, ok := lhs[x]; !ok {
			return false
		}
	}

	return true
}

func _Set_JobKey_sliceType_Equals(lhs, rhs []*JobKey) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this TaskQuery match the
// provided TaskQuery.
//
// This function performs a deep comparison.
func (v *TaskQuery) Equals(rhs *TaskQuery) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Role, rhs.Role) {
		return false
	}
	if !_String_EqualsPtr(v.Environment, rhs.Environment) {
		return false
	}
	if !_String_EqualsPtr(v.JobName, rhs.JobName) {
		return false
	}
	if !((v.TaskIds == nil && rhs.TaskIds == nil) || (v.TaskIds != nil && rhs.TaskIds != nil && _Set_String_mapType_Equals(v.TaskIds, rhs.TaskIds))) {
		return false
	}
	if !((v.Statuses == nil && rhs.Statuses == nil) || (v.Statuses != nil && rhs.Statuses != nil && _Set_ScheduleStatus_mapType_Equals(v.Statuses, rhs.Statuses))) {
		return false
	}
	if !((v.InstanceIds == nil && rhs.InstanceIds == nil) || (v.InstanceIds != nil && rhs.InstanceIds != nil && _Set_I32_mapType_Equals(v.InstanceIds, rhs.InstanceIds))) {
		return false
	}
	if !((v.SlaveHosts == nil && rhs.SlaveHosts == nil) || (v.SlaveHosts != nil && rhs.SlaveHosts != nil && _Set_String_mapType_Equals(v.SlaveHosts, rhs.SlaveHosts))) {
		return false
	}
	if !((v.JobKeys == nil && rhs.JobKeys == nil) || (v.JobKeys != nil && rhs.JobKeys != nil && _Set_JobKey_sliceType_Equals(v.JobKeys, rhs.JobKeys))) {
		return false
	}
	if !_I32_EqualsPtr(v.Offset, rhs.Offset) {
		return false
	}
	if !_I32_EqualsPtr(v.Limit, rhs.Limit) {
		return false
	}

	return true
}

type _Set_ScheduleStatus_mapType_Zapper map[ScheduleStatus]struct{}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_ScheduleStatus_mapType_Zapper.
func (s _Set_ScheduleStatus_mapType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

type _Set_I32_mapType_Zapper map[int32]struct{}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_I32_mapType_Zapper.
func (s _Set_I32_mapType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for v := range s {
		enc.AppendInt32(v)
	}
	return err
}

type _Set_JobKey_sliceType_Zapper []*JobKey

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_JobKey_sliceType_Zapper.
func (s _Set_JobKey_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TaskQuery.
func (v *TaskQuery) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Role != nil {
		enc.AddString("role", *v.Role)
	}
	if v.Environment != nil {
		enc.AddString("environment", *v.Environment)
	}
	if v.JobName != nil {
		enc.AddString("jobName", *v.JobName)
	}
	if v.TaskIds != nil {
		err = multierr.Append(err, enc.AddArray("taskIds", (_Set_String_mapType_Zapper)(v.TaskIds)))
	}
	if v.Statuses != nil {
		err = multierr.Append(err, enc.AddArray("statuses", (_Set_ScheduleStatus_mapType_Zapper)(v.Statuses)))
	}
	if v.InstanceIds != nil {
		err = multierr.Append(err, enc.AddArray("instanceIds", (_Set_I32_mapType_Zapper)(v.InstanceIds)))
	}
	if v.SlaveHosts != nil {
		err = multierr.Append(err, enc.AddArray("slaveHosts", (_Set_String_mapType_Zapper)(v.SlaveHosts)))
	}
	if v.JobKeys != nil {
		err = multierr.Append(err, enc.AddArray("jobKeys", (_Set_JobKey_sliceType_Zapper)(v.JobKeys)))
	}
	if v.Offset != nil {
		enc.AddInt32("offset", *v.Offset)
	}
	if v.Limit != nil {
		enc.AddInt32("limit", *v.Limit)
	}
	return err
}

// GetRole returns the value of Role if it is set or its
// zero value if it is unset.
func (v *TaskQuery) GetRole() (o string) {
	if v != nil && v.Role != nil {
		return *v.Role
	}

	return
}

// IsSetRole returns true if Role is not nil.
func (v *TaskQuery) IsSetRole() bool {
	return v != nil && v.Role != nil
}

// GetEnvironment returns the value of Environment if it is set or its
// zero value if it is unset.
func (v *TaskQuery) GetEnvironment() (o string) {
	if v != nil && v.Environment != nil {
		return *v.Environment
	}

	return
}

// IsSetEnvironment returns true if Environment is not nil.
func (v *TaskQuery) IsSetEnvironment() bool {
	return v != nil && v.Environment != nil
}

// GetJobName returns the value of JobName if it is set or its
// zero value if it is unset.
func (v *TaskQuery) GetJobName() (o string) {
	if v != nil && v.JobName != nil {
		return *v.JobName
	}

	return
}

// IsSetJobName returns true if JobName is not nil.
func (v *TaskQuery) IsSetJobName() bool {
	return v != nil && v.JobName != nil
}

// GetTaskIds returns the value of TaskIds if it is set or its
// zero value if it is unset.
func (v *TaskQuery) GetTaskIds() (o map[string]struct{}) {
	if v != nil && v.TaskIds != nil {
		return v.TaskIds
	}

	return
}

// IsSetTaskIds returns true if TaskIds is not nil.
func (v *TaskQuery) IsSetTaskIds() bool {
	return v != nil && v.TaskIds != nil
}

// GetStatuses returns the value of Statuses if it is set or its
// zero value if it is unset.
func (v *TaskQuery) GetStatuses() (o map[ScheduleStatus]struct{}) {
	if v != nil && v.Statuses != nil {
		return v.Statuses
	}

	return
}

// IsSetStatuses returns true if Statuses is not nil.
func (v *TaskQuery) IsSetStatuses() bool {
	return v != nil && v.Statuses != nil
}

// GetInstanceIds returns the value of InstanceIds if it is set or its
// zero value if it is unset.
func (v *TaskQuery) GetInstanceIds() (o map[int32]struct{}) {
	if v != nil && v.InstanceIds != nil {
		return v.InstanceIds
	}

	return
}

// IsSetInstanceIds returns true if InstanceIds is not nil.
func (v *TaskQuery) IsSetInstanceIds() bool {
	return v != nil && v.InstanceIds != nil
}

// GetSlaveHosts returns the value of SlaveHosts if it is set or its
// zero value if it is unset.
func (v *TaskQuery) GetSlaveHosts() (o map[string]struct{}) {
	if v != nil && v.SlaveHosts != nil {
		return v.SlaveHosts
	}

	return
}

// IsSetSlaveHosts returns true if SlaveHosts is not nil.
func (v *TaskQuery) IsSetSlaveHosts() bool {
	return v != nil && v.SlaveHosts != nil
}

// GetJobKeys returns the value of JobKeys if it is set or its
// zero value if it is unset.
func (v *TaskQuery) GetJobKeys() (o []*JobKey) {
	if v != nil && v.JobKeys != nil {
		return v.JobKeys
	}

	return
}

// IsSetJobKeys returns true if JobKeys is not nil.
func (v *TaskQuery) IsSetJobKeys() bool {
	return v != nil && v.JobKeys != nil
}

// GetOffset returns the value of Offset if it is set or its
// zero value if it is unset.
func (v *TaskQuery) GetOffset() (o int32) {
	if v != nil && v.Offset != nil {
		return *v.Offset
	}

	return
}

// IsSetOffset returns true if Offset is not nil.
func (v *TaskQuery) IsSetOffset() bool {
	return v != nil && v.Offset != nil
}

// GetLimit returns the value of Limit if it is set or its
// zero value if it is unset.
func (v *TaskQuery) GetLimit() (o int32) {
	if v != nil && v.Limit != nil {
		return *v.Limit
	}

	return
}

// IsSetLimit returns true if Limit is not nil.
func (v *TaskQuery) IsSetLimit() bool {
	return v != nil && v.Limit != nil
}

// Tier information.
type TierConfig struct {
	// Name of tier.
	Name *string `json:"name,omitempty"`
	// Tier attributes.
	Settings map[string]string `json:"settings,omitempty"`
}

// ToWire translates a TierConfig struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *TierConfig) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Settings != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Settings)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a TierConfig struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TierConfig struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v TierConfig
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *TierConfig) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TMap {
				v.Settings, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a TierConfig
// struct.
func (v *TierConfig) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Settings != nil {
		fields[i] = fmt.Sprintf("Settings: %v", v.Settings)
		i++
	}

	return fmt.Sprintf("TierConfig{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this TierConfig match the
// provided TierConfig.
//
// This function performs a deep comparison.
func (v *TierConfig) Equals(rhs *TierConfig) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !((v.Settings == nil && rhs.Settings == nil) || (v.Settings != nil && rhs.Settings != nil && _Map_String_String_Equals(v.Settings, rhs.Settings))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TierConfig.
func (v *TierConfig) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.Settings != nil {
		err = multierr.Append(err, enc.AddObject("settings", (_Map_String_String_Zapper)(v.Settings)))
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *TierConfig) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *TierConfig) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetSettings returns the value of Settings if it is set or its
// zero value if it is unset.
func (v *TierConfig) GetSettings() (o map[string]string) {
	if v != nil && v.Settings != nil {
		return v.Settings
	}

	return
}

// IsSetSettings returns true if Settings is not nil.
func (v *TierConfig) IsSetSettings() bool {
	return v != nil && v.Settings != nil
}

// A constraint that specifies an explicit set of values, at least one of which must be present
// on a host for a task to be scheduled there.
type ValueConstraint struct {
	// If true, treat this as a 'not' - to avoid specific values.
	Negated *bool               `json:"negated,omitempty"`
	Values  map[string]struct{} `json:"values,omitempty"`
}

// ToWire translates a ValueConstraint struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ValueConstraint) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Negated != nil {
		w, err = wire.NewValueBool(*(v.Negated)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Values != nil {
		w, err = wire.NewValueSet(_Set_String_mapType_ValueList(v.Values)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ValueConstraint struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ValueConstraint struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ValueConstraint
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ValueConstraint) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.Negated = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TSet {
				v.Values, err = _Set_String_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ValueConstraint
// struct.
func (v *ValueConstraint) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Negated != nil {
		fields[i] = fmt.Sprintf("Negated: %v", *(v.Negated))
		i++
	}
	if v.Values != nil {
		fields[i] = fmt.Sprintf("Values: %v", v.Values)
		i++
	}

	return fmt.Sprintf("ValueConstraint{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ValueConstraint match the
// provided ValueConstraint.
//
// This function performs a deep comparison.
func (v *ValueConstraint) Equals(rhs *ValueConstraint) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Bool_EqualsPtr(v.Negated, rhs.Negated) {
		return false
	}
	if !((v.Values == nil && rhs.Values == nil) || (v.Values != nil && rhs.Values != nil && _Set_String_mapType_Equals(v.Values, rhs.Values))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ValueConstraint.
func (v *ValueConstraint) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Negated != nil {
		enc.AddBool("negated", *v.Negated)
	}
	if v.Values != nil {
		err = multierr.Append(err, enc.AddArray("values", (_Set_String_mapType_Zapper)(v.Values)))
	}
	return err
}

// GetNegated returns the value of Negated if it is set or its
// zero value if it is unset.
func (v *ValueConstraint) GetNegated() (o bool) {
	if v != nil && v.Negated != nil {
		return *v.Negated
	}

	return
}

// IsSetNegated returns true if Negated is not nil.
func (v *ValueConstraint) IsSetNegated() bool {
	return v != nil && v.Negated != nil
}

// GetValues returns the value of Values if it is set or its
// zero value if it is unset.
func (v *ValueConstraint) GetValues() (o map[string]struct{}) {
	if v != nil && v.Values != nil {
		return v.Values
	}

	return
}

// IsSetValues returns true if Values is not nil.
func (v *ValueConstraint) IsSetValues() bool {
	return v != nil && v.Values != nil
}

// A volume mount point within a container
type Volume struct {
	// The path inside the container where the mount will be created.
	ContainerPath *string `json:"containerPath,omitempty"`
	// The path on the host that will serve as the source for the mount.
	HostPath *string `json:"hostPath,omitempty"`
	// The access mode
	Mode *Mode `json:"mode,omitempty"`
}

// ToWire translates a Volume struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Volume) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ContainerPath != nil {
		w, err = wire.NewValueString(*(v.ContainerPath)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.HostPath != nil {
		w, err = wire.NewValueString(*(v.HostPath)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Mode != nil {
		w, err = v.Mode.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Mode_Read(w wire.Value) (Mode, error) {
	var v Mode
	err := v.FromWire(w)
	return v, err
}

// FromWire deserializes a Volume struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Volume struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Volume
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Volume) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ContainerPath = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.HostPath = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x Mode
				x, err = _Mode_Read(field.Value)
				v.Mode = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Volume
// struct.
func (v *Volume) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.ContainerPath != nil {
		fields[i] = fmt.Sprintf("ContainerPath: %v", *(v.ContainerPath))
		i++
	}
	if v.HostPath != nil {
		fields[i] = fmt.Sprintf("HostPath: %v", *(v.HostPath))
		i++
	}
	if v.Mode != nil {
		fields[i] = fmt.Sprintf("Mode: %v", *(v.Mode))
		i++
	}

	return fmt.Sprintf("Volume{%v}", strings.Join(fields[:i], ", "))
}

func _Mode_EqualsPtr(lhs, rhs *Mode) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this Volume match the
// provided Volume.
//
// This function performs a deep comparison.
func (v *Volume) Equals(rhs *Volume) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.ContainerPath, rhs.ContainerPath) {
		return false
	}
	if !_String_EqualsPtr(v.HostPath, rhs.HostPath) {
		return false
	}
	if !_Mode_EqualsPtr(v.Mode, rhs.Mode) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Volume.
func (v *Volume) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ContainerPath != nil {
		enc.AddString("containerPath", *v.ContainerPath)
	}
	if v.HostPath != nil {
		enc.AddString("hostPath", *v.HostPath)
	}
	if v.Mode != nil {
		err = multierr.Append(err, enc.AddObject("mode", *v.Mode))
	}
	return err
}

// GetContainerPath returns the value of ContainerPath if it is set or its
// zero value if it is unset.
func (v *Volume) GetContainerPath() (o string) {
	if v != nil && v.ContainerPath != nil {
		return *v.ContainerPath
	}

	return
}

// IsSetContainerPath returns true if ContainerPath is not nil.
func (v *Volume) IsSetContainerPath() bool {
	return v != nil && v.ContainerPath != nil
}

// GetHostPath returns the value of HostPath if it is set or its
// zero value if it is unset.
func (v *Volume) GetHostPath() (o string) {
	if v != nil && v.HostPath != nil {
		return *v.HostPath
	}

	return
}

// IsSetHostPath returns true if HostPath is not nil.
func (v *Volume) IsSetHostPath() bool {
	return v != nil && v.HostPath != nil
}

// GetMode returns the value of Mode if it is set or its
// zero value if it is unset.
func (v *Volume) GetMode() (o Mode) {
	if v != nil && v.Mode != nil {
		return *v.Mode
	}

	return
}

// IsSetMode returns true if Mode is not nil.
func (v *Volume) IsSetMode() bool {
	return v != nil && v.Mode != nil
}

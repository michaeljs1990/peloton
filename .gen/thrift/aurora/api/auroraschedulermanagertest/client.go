// Code generated by thriftrw-plugin-yarpc
// @generated

package auroraschedulermanagertest

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	api "github.com/uber/peloton/.gen/thrift/aurora/api"
	auroraschedulermanagerclient "github.com/uber/peloton/.gen/thrift/aurora/api/auroraschedulermanagerclient"
	yarpc "go.uber.org/yarpc"
)

// MockClient implements a gomock-compatible mock client for service
// AuroraSchedulerManager.
type MockClient struct {
	ctrl     *gomock.Controller
	recorder *_MockClientRecorder
}

var _ auroraschedulermanagerclient.Interface = (*MockClient)(nil)

type _MockClientRecorder struct {
	mock *MockClient
}

// Build a new mock client for service AuroraSchedulerManager.
//
// 	mockCtrl := gomock.NewController(t)
// 	client := auroraschedulermanagertest.NewMockClient(mockCtrl)
//
// Use EXPECT() to set expectations on the mock.
func NewMockClient(ctrl *gomock.Controller) *MockClient {
	mock := &MockClient{ctrl: ctrl}
	mock.recorder = &_MockClientRecorder{mock}
	return mock
}

// EXPECT returns an object that allows you to define an expectation on the
// AuroraSchedulerManager mock client.
func (m *MockClient) EXPECT() *_MockClientRecorder {
	return m.recorder
}

// AbortJobUpdate responds to a AbortJobUpdate call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().AbortJobUpdate(gomock.Any(), ...).Return(...)
// 	... := client.AbortJobUpdate(...)
func (m *MockClient) AbortJobUpdate(
	ctx context.Context,
	_Key *api.JobUpdateKey,
	_Message *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Key, _Message}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "AbortJobUpdate", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) AbortJobUpdate(
	ctx interface{},
	_Key interface{},
	_Message interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Key, _Message}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "AbortJobUpdate", args...)
}

// AddInstances responds to a AddInstances call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().AddInstances(gomock.Any(), ...).Return(...)
// 	... := client.AddInstances(...)
func (m *MockClient) AddInstances(
	ctx context.Context,
	_Key *api.InstanceKey,
	_Count *int32,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Key, _Count}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "AddInstances", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) AddInstances(
	ctx interface{},
	_Key interface{},
	_Count interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Key, _Count}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "AddInstances", args...)
}

// CreateJob responds to a CreateJob call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().CreateJob(gomock.Any(), ...).Return(...)
// 	... := client.CreateJob(...)
func (m *MockClient) CreateJob(
	ctx context.Context,
	_Description *api.JobConfiguration,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Description}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "CreateJob", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) CreateJob(
	ctx interface{},
	_Description interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Description}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "CreateJob", args...)
}

// DescheduleCronJob responds to a DescheduleCronJob call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().DescheduleCronJob(gomock.Any(), ...).Return(...)
// 	... := client.DescheduleCronJob(...)
func (m *MockClient) DescheduleCronJob(
	ctx context.Context,
	_Job *api.JobKey,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Job}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "DescheduleCronJob", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) DescheduleCronJob(
	ctx interface{},
	_Job interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Job}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "DescheduleCronJob", args...)
}

// KillTasks responds to a KillTasks call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().KillTasks(gomock.Any(), ...).Return(...)
// 	... := client.KillTasks(...)
func (m *MockClient) KillTasks(
	ctx context.Context,
	_Job *api.JobKey,
	_Instances map[int32]struct{},
	_Message *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Job, _Instances, _Message}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "KillTasks", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) KillTasks(
	ctx interface{},
	_Job interface{},
	_Instances interface{},
	_Message interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Job, _Instances, _Message}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "KillTasks", args...)
}

// PauseJobUpdate responds to a PauseJobUpdate call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().PauseJobUpdate(gomock.Any(), ...).Return(...)
// 	... := client.PauseJobUpdate(...)
func (m *MockClient) PauseJobUpdate(
	ctx context.Context,
	_Key *api.JobUpdateKey,
	_Message *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Key, _Message}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "PauseJobUpdate", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) PauseJobUpdate(
	ctx interface{},
	_Key interface{},
	_Message interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Key, _Message}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "PauseJobUpdate", args...)
}

// PulseJobUpdate responds to a PulseJobUpdate call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().PulseJobUpdate(gomock.Any(), ...).Return(...)
// 	... := client.PulseJobUpdate(...)
func (m *MockClient) PulseJobUpdate(
	ctx context.Context,
	_Key *api.JobUpdateKey,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Key}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "PulseJobUpdate", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) PulseJobUpdate(
	ctx interface{},
	_Key interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Key}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "PulseJobUpdate", args...)
}

// ReplaceCronTemplate responds to a ReplaceCronTemplate call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().ReplaceCronTemplate(gomock.Any(), ...).Return(...)
// 	... := client.ReplaceCronTemplate(...)
func (m *MockClient) ReplaceCronTemplate(
	ctx context.Context,
	_Config *api.JobConfiguration,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Config}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "ReplaceCronTemplate", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) ReplaceCronTemplate(
	ctx interface{},
	_Config interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Config}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "ReplaceCronTemplate", args...)
}

// RestartShards responds to a RestartShards call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().RestartShards(gomock.Any(), ...).Return(...)
// 	... := client.RestartShards(...)
func (m *MockClient) RestartShards(
	ctx context.Context,
	_Job *api.JobKey,
	_ShardIds map[int32]struct{},
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Job, _ShardIds}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "RestartShards", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) RestartShards(
	ctx interface{},
	_Job interface{},
	_ShardIds interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Job, _ShardIds}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "RestartShards", args...)
}

// ResumeJobUpdate responds to a ResumeJobUpdate call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().ResumeJobUpdate(gomock.Any(), ...).Return(...)
// 	... := client.ResumeJobUpdate(...)
func (m *MockClient) ResumeJobUpdate(
	ctx context.Context,
	_Key *api.JobUpdateKey,
	_Message *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Key, _Message}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "ResumeJobUpdate", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) ResumeJobUpdate(
	ctx interface{},
	_Key interface{},
	_Message interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Key, _Message}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "ResumeJobUpdate", args...)
}

// RollbackJobUpdate responds to a RollbackJobUpdate call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().RollbackJobUpdate(gomock.Any(), ...).Return(...)
// 	... := client.RollbackJobUpdate(...)
func (m *MockClient) RollbackJobUpdate(
	ctx context.Context,
	_Key *api.JobUpdateKey,
	_Message *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Key, _Message}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "RollbackJobUpdate", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) RollbackJobUpdate(
	ctx interface{},
	_Key interface{},
	_Message interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Key, _Message}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "RollbackJobUpdate", args...)
}

// ScheduleCronJob responds to a ScheduleCronJob call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().ScheduleCronJob(gomock.Any(), ...).Return(...)
// 	... := client.ScheduleCronJob(...)
func (m *MockClient) ScheduleCronJob(
	ctx context.Context,
	_Description *api.JobConfiguration,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Description}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "ScheduleCronJob", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) ScheduleCronJob(
	ctx interface{},
	_Description interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Description}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "ScheduleCronJob", args...)
}

// StartCronJob responds to a StartCronJob call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().StartCronJob(gomock.Any(), ...).Return(...)
// 	... := client.StartCronJob(...)
func (m *MockClient) StartCronJob(
	ctx context.Context,
	_Job *api.JobKey,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Job}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "StartCronJob", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) StartCronJob(
	ctx interface{},
	_Job interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Job}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "StartCronJob", args...)
}

// StartJobUpdate responds to a StartJobUpdate call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().StartJobUpdate(gomock.Any(), ...).Return(...)
// 	... := client.StartJobUpdate(...)
func (m *MockClient) StartJobUpdate(
	ctx context.Context,
	_Request *api.JobUpdateRequest,
	_Message *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Request, _Message}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "StartJobUpdate", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) StartJobUpdate(
	ctx interface{},
	_Request interface{},
	_Message interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Request, _Message}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "StartJobUpdate", args...)
}

// GetConfigSummary responds to a GetConfigSummary call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetConfigSummary(gomock.Any(), ...).Return(...)
// 	... := client.GetConfigSummary(...)
func (m *MockClient) GetConfigSummary(
	ctx context.Context,
	_Job *api.JobKey,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Job}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetConfigSummary", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetConfigSummary(
	ctx interface{},
	_Job interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Job}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetConfigSummary", args...)
}

// GetJobSummary responds to a GetJobSummary call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetJobSummary(gomock.Any(), ...).Return(...)
// 	... := client.GetJobSummary(...)
func (m *MockClient) GetJobSummary(
	ctx context.Context,
	_Role *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Role}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetJobSummary", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetJobSummary(
	ctx interface{},
	_Role interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Role}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetJobSummary", args...)
}

// GetJobUpdateDetails responds to a GetJobUpdateDetails call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetJobUpdateDetails(gomock.Any(), ...).Return(...)
// 	... := client.GetJobUpdateDetails(...)
func (m *MockClient) GetJobUpdateDetails(
	ctx context.Context,
	_Key *api.JobUpdateKey,
	_Query *api.JobUpdateQuery,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Key, _Query}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetJobUpdateDetails", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetJobUpdateDetails(
	ctx interface{},
	_Key interface{},
	_Query interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Key, _Query}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetJobUpdateDetails", args...)
}

// GetJobUpdateDiff responds to a GetJobUpdateDiff call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetJobUpdateDiff(gomock.Any(), ...).Return(...)
// 	... := client.GetJobUpdateDiff(...)
func (m *MockClient) GetJobUpdateDiff(
	ctx context.Context,
	_Request *api.JobUpdateRequest,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Request}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetJobUpdateDiff", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetJobUpdateDiff(
	ctx interface{},
	_Request interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Request}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetJobUpdateDiff", args...)
}

// GetJobUpdateSummaries responds to a GetJobUpdateSummaries call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetJobUpdateSummaries(gomock.Any(), ...).Return(...)
// 	... := client.GetJobUpdateSummaries(...)
func (m *MockClient) GetJobUpdateSummaries(
	ctx context.Context,
	_JobUpdateQuery *api.JobUpdateQuery,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _JobUpdateQuery}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetJobUpdateSummaries", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetJobUpdateSummaries(
	ctx interface{},
	_JobUpdateQuery interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _JobUpdateQuery}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetJobUpdateSummaries", args...)
}

// GetJobs responds to a GetJobs call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetJobs(gomock.Any(), ...).Return(...)
// 	... := client.GetJobs(...)
func (m *MockClient) GetJobs(
	ctx context.Context,
	_OwnerRole *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _OwnerRole}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetJobs", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetJobs(
	ctx interface{},
	_OwnerRole interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _OwnerRole}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetJobs", args...)
}

// GetPendingReason responds to a GetPendingReason call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetPendingReason(gomock.Any(), ...).Return(...)
// 	... := client.GetPendingReason(...)
func (m *MockClient) GetPendingReason(
	ctx context.Context,
	_Query *api.TaskQuery,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Query}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetPendingReason", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetPendingReason(
	ctx interface{},
	_Query interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Query}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetPendingReason", args...)
}

// GetQuota responds to a GetQuota call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetQuota(gomock.Any(), ...).Return(...)
// 	... := client.GetQuota(...)
func (m *MockClient) GetQuota(
	ctx context.Context,
	_OwnerRole *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _OwnerRole}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetQuota", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetQuota(
	ctx interface{},
	_OwnerRole interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _OwnerRole}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetQuota", args...)
}

// GetRoleSummary responds to a GetRoleSummary call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetRoleSummary(gomock.Any(), ...).Return(...)
// 	... := client.GetRoleSummary(...)
func (m *MockClient) GetRoleSummary(
	ctx context.Context,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetRoleSummary", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetRoleSummary(
	ctx interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetRoleSummary", args...)
}

// GetTasksStatus responds to a GetTasksStatus call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetTasksStatus(gomock.Any(), ...).Return(...)
// 	... := client.GetTasksStatus(...)
func (m *MockClient) GetTasksStatus(
	ctx context.Context,
	_Query *api.TaskQuery,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Query}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetTasksStatus", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetTasksStatus(
	ctx interface{},
	_Query interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Query}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetTasksStatus", args...)
}

// GetTasksWithoutConfigs responds to a GetTasksWithoutConfigs call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetTasksWithoutConfigs(gomock.Any(), ...).Return(...)
// 	... := client.GetTasksWithoutConfigs(...)
func (m *MockClient) GetTasksWithoutConfigs(
	ctx context.Context,
	_Query *api.TaskQuery,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Query}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetTasksWithoutConfigs", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetTasksWithoutConfigs(
	ctx interface{},
	_Query interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Query}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetTasksWithoutConfigs", args...)
}

// GetTierConfigs responds to a GetTierConfigs call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetTierConfigs(gomock.Any(), ...).Return(...)
// 	... := client.GetTierConfigs(...)
func (m *MockClient) GetTierConfigs(
	ctx context.Context,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetTierConfigs", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetTierConfigs(
	ctx interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetTierConfigs", args...)
}

// PopulateJobConfig responds to a PopulateJobConfig call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().PopulateJobConfig(gomock.Any(), ...).Return(...)
// 	... := client.PopulateJobConfig(...)
func (m *MockClient) PopulateJobConfig(
	ctx context.Context,
	_Description *api.JobConfiguration,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Description}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "PopulateJobConfig", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) PopulateJobConfig(
	ctx interface{},
	_Description interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Description}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "PopulateJobConfig", args...)
}

// Code generated by thriftrw v1.19.1. DO NOT EDIT.
// @generated

package api

import thriftreflect "go.uber.org/thriftrw/thriftreflect"

// ThriftModule represents the IDL file used to generate this package.
var ThriftModule = &thriftreflect.ThriftModule{
	Name:     "api",
	Package:  "github.com/uber/peloton/.gen/thrift/aurora/api",
	FilePath: "api.thrift",
	SHA1:     "c92e367815162477870d6e9f0372c01fa165b988",
	Raw:      rawIDL,
}

const rawIDL = "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Copy api.thrift file from master branch of internal apache-aurora fork.\n// To support yarpc thrift bindings for aurora thrift api, file is updated with\n// optional tag for struct fields.\n\nnamespace java org.apache.aurora.gen\nnamespace py gen.apache.aurora.api\n\n// Thrift interface definition for the aurora scheduler.\n\n/*\n * TODO(wfarner): It would be nice if we could put some HTML tags here, regex doesn't handle it though.\n * The result of an API operation.  A result may only be specified when this is OK.\n */\nenum ResponseCode {\n  INVALID_REQUEST = 0,\n  OK              = 1,\n  ERROR           = 2,\n  WARNING         = 3,\n  AUTH_FAILED     = 4,\n  /** Raised when an operation was unable to proceed due to an in-progress job update. */\n  JOB_UPDATING_ERROR = 5,\n  /** Raised when a scheduler is transiently unavailable and later retry is recommended. */\n  ERROR_TRANSIENT = 6\n}\n\n// Aurora executor framework name.\nconst string AURORA_EXECUTOR_NAME = 'AuroraExecutor'\n\n// TODO(maxim): Remove in 0.7.0. (AURORA-749)\nstruct Identity {\n  2: optional string user\n}\n\n/** A single host attribute. */\nstruct Attribute {\n  1: optional string name\n  2: optional set<string> values\n}\n\nenum MaintenanceMode {\n  NONE      = 1,\n  SCHEDULED = 2,\n  DRAINING  = 3,\n  DRAINED   = 4\n}\n\n/** The attributes assigned to a host. */\nstruct HostAttributes {\n  1: optional  string          host\n  2: optional set<Attribute>  attributes\n  3: optional MaintenanceMode mode\n  4: optional string slaveId\n}\n\n/**\n * A constraint that specifies an explicit set of values, at least one of which must be present\n * on a host for a task to be scheduled there.\n */\nstruct ValueConstraint {\n  /** If true, treat this as a 'not' - to avoid specific values. */\n  1: optional bool negated\n  2: optional set<string> values\n}\n\n/**\n * A constraint the specifies the maximum number of active tasks on a host with a matching\n * attribute that may be scheduled simultaneously.\n */\nstruct LimitConstraint {\n  1: optional i32 limit\n}\n\n/** Types of constraints that may be applied to a task. */\nunion TaskConstraint {\n  1: ValueConstraint value\n  2: LimitConstraint limit\n}\n\n/** A constraint that defines whether a task may be scheduled on a host. */\nstruct Constraint {\n  /** Mesos slave attribute that the constraint is matched against. */\n  1: optional string name\n  2: optional TaskConstraint constraint\n}\n\nstruct Package {\n  1: optional string role\n  2: optional string name\n  3: optional i32 version\n}\n\n/** Arbitrary key-value metadata to be included into TaskConfig. */\nstruct Metadata {\n  1: optional string key\n  2: optional string value\n}\n\n/** A unique identifier for a Job. */\nstruct JobKey {\n  /** User role (Unix service account), for example \"mesos\" */\n  1: optional string role\n  /** Environment, for example \"devel\" */\n  2: optional string environment\n  /** Name, for example \"labrat\" */\n  3: optional string name\n}\n\n/** A unique lock key. */\nunion LockKey {\n  1: optional JobKey job\n}\n\n/** A generic lock struct to facilitate context specific resource/operation serialization. */\nstruct Lock {\n  /** ID of the lock - unique per storage */\n  1: optional LockKey key\n  /** UUID - facilitating soft lock authorization */\n  2: optional string token\n  /** Lock creator */\n  3: optional string user\n  /** Lock creation timestamp in milliseconds */\n  4: optional i64 timestampMs\n  /** Optional message to record with the lock */\n  5: optional string message\n}\n\n/** A unique identifier for the active task within a job. */\nstruct InstanceKey {\n  /** Key identifying the job. */\n  1: optional JobKey jobKey\n  /** Unique instance ID for the active task in a job. */\n  2: optional i32 instanceId\n}\n\n/** URI which mirrors CommandInfo.URI in the Mesos Protobuf */\nstruct MesosFetcherURI {\n  /** Where to get the resource from */\n  1: optional string value\n  /** Extract compressed archive after downloading */\n  2: optional bool extract\n  /** Cache value using Mesos Fetcher caching mechanism **/\n  3: optional bool cache\n}\n\nstruct ExecutorConfig {\n  /** Name identifying the Executor. */\n  1: optional string name\n  /** Executor configuration data. */\n  2: optional string data\n}\n\n/** The mode for a volume mount */\nenum Mode {\n  /** Read Write */\n  RW = 1\n  /** Read Only */\n  RO = 2\n}\n\n/** A volume mount point within a container */\nstruct Volume {\n  /** The path inside the container where the mount will be created. */\n  1: optional string containerPath\n  /** The path on the host that will serve as the source for the mount. */\n  2: optional string hostPath\n  /** The access mode */\n  3: optional Mode mode\n}\n\n/** Describes an image for use with the Mesos unified containerizer in the Docker format */\nstruct DockerImage {\n  /** The name of the image to run */\n  1: optional string name\n  /** The Docker tag identifying the image */\n  2: optional string tag\n}\n\n/** Describes an image for use with the Mesos unified containerizer in the AppC format */\nstruct AppcImage {\n  /** The name of the image to run */\n  1: optional string name\n  /** The appc image id identifying the image */\n  2: optional string imageId\n}\n\n/** Describes an image to be used with the Mesos unified containerizer */\nunion Image {\n  1: DockerImage docker\n  2: AppcImage appc\n}\n\n/** Describes a mesos container, this is the default */\nstruct MesosContainer {\n  /** the optional filesystem image to use when launching this task. */\n  1: optional Image image\n  /** the optional list of volumes to mount into the task. */\n  2: optional list<Volume> volumes\n}\n\n/** Describes a parameter passed to docker cli */\nstruct DockerParameter {\n  /** a parameter to pass to docker. (e.g. volume) */\n  1: optional string name\n  /** the value to pass to a parameter (e.g. /src/webapp:/opt/webapp) */\n  2: optional string value\n}\n\n/** Describes a docker container */\nstruct DockerContainer {\n  /** The container image to be run */\n  1: optional string image\n  /** The arbitrary parameters to pass to container */\n  2: optional list<DockerParameter> parameters\n}\n\n/** Describes a container to be used in a task */\nunion Container {\n  1: MesosContainer mesos\n  2: DockerContainer docker\n}\n\n/** Describes resource value required to run a task. */\nunion Resource {\n  1: double numCpus\n  2: i64 ramMb\n  3: i64 diskMb\n  4: string namedPort\n  5: i64 numGpus\n}\n\n/** Description of the tasks contained within a job. */\nstruct TaskConfig {\n /** Job task belongs to. */\n 28: optional JobKey job\n // TODO(maxim): Deprecated. See AURORA-749.\n /** contains the role component of JobKey */\n 17: optional Identity owner\n  7: optional bool isService\n  // TODO(maxim): Deprecated. See AURORA-1707.\n  8: optional double numCpus\n  // TODO(maxim): Deprecated. See AURORA-1707.\n  9: optional i64 ramMb\n  // TODO(maxim): Deprecated. See AURORA-1707.\n 10: optional i64 diskMb\n 11: optional i32 priority\n 13: optional i32 maxTaskFailures\n // TODO(mnurolahzade): Deprecated. See AURORA-1708.\n /** Whether this is a production task, which can preempt. */\n 18: optional bool production\n /** Task tier type. */\n 30: optional string tier\n /** All resources required to run a task. */\n 32: optional set<Resource> resources\n\n 20: optional set<Constraint> constraints\n /** a list of named ports this task requests */\n 21: optional set<string> requestedPorts\n /** Resources to retrieve with Mesos Fetcher */\n 33: optional set<MesosFetcherURI> mesosFetcherUris\n /**\n  * Custom links to include when displaying this task on the scheduler dashboard. Keys are anchor\n  * text, values are URLs. Wildcards are supported for dynamic link crafting based on host, ports,\n  * instance, etc.\n  */\n 22: optional map<string, string> taskLinks\n 23: optional string contactEmail\n /** Executor configuration */\n 25: optional ExecutorConfig executorConfig\n /** Used to display additional details in the UI. */\n 27: optional set<Metadata> metadata\n\n // This field is deliberately placed at the end to work around a bug in the immutable wrapper\n // code generator.  See AURORA-1185 for details.\n /** the container the task should use to execute */\n 29: optional Container container = { \"mesos\": {} }\n}\n\nstruct ResourceAggregate {\n  // TODO(maxim): Deprecated. See AURORA-1707.\n  /** Number of CPU cores allotted. */\n  1: optional double numCpus\n  // TODO(maxim): Deprecated. See AURORA-1707.\n  /** Megabytes of RAM allotted. */\n  2: optional i64 ramMb\n  // TODO(maxim): Deprecated. See AURORA-1707.\n  /** Megabytes of disk space allotted. */\n  3: optional i64 diskMb\n  /** Aggregated resource values. */\n  4: optional set<Resource> resources\n}\n\n/** Defines the policy for launching a new cron job when one is already running. */\nenum CronCollisionPolicy {\n  /** Kills the existing job with the colliding name, and runs the new cron job. */\n  KILL_EXISTING = 0,\n  /** Cancels execution of the new job, leaving the running job in tact. */\n  CANCEL_NEW    = 1,\n  /**\n   * DEPRECATED. For existing jobs, treated the same as CANCEL_NEW.\n   * createJob will reject jobs with this policy.\n   */\n  RUN_OVERLAP   = 2\n}\n\n/**\n * Description of an Aurora job. One task will be scheduled for each instance within the job.\n */\nstruct JobConfiguration {\n  /**\n   * Key for this job. If not specified name, owner.role, and a reasonable default environment are\n   * used to construct it server-side.\n   */\n  9: optional JobKey key\n  // TODO(maxim): optional Deprecated. See AURORA-749.\n  /** Owner of this job. */\n  7: optional Identity owner\n  /**\n   * If present, the job will be handled as a cron job with this crontab-syntax schedule.\n   */\n  4: optional string cronSchedule\n  /** Collision policy to use when handling overlapping cron runs.  Default is KILL_EXISTING. */\n  5: optional CronCollisionPolicy cronCollisionPolicy\n  /** Task configuration for this job. */\n  6: optional TaskConfig taskConfig\n  /**\n   * The number of instances in the job. Generated instance IDs for tasks will be in the range\n   * [0, instances).\n   */\n  8: optional i32 instanceCount\n}\n\nstruct JobStats {\n  /** Number of tasks in active state for this job. */\n  1: optional i32 activeTaskCount\n  /** Number of tasks in finished state for this job. */\n  2: optional i32 finishedTaskCount\n  /** Number of failed tasks for this job. */\n  3: optional i32 failedTaskCount\n  /** Number of tasks in pending state for this job. */\n  4: optional i32 pendingTaskCount\n}\n\nstruct JobSummary {\n  1: optional JobConfiguration job\n  2: optional JobStats stats\n  /** Timestamp of next cron run in ms since epoch, for a cron job */\n  3: optional i64 nextCronRunMs\n}\n\n/** Closed range of integers. */\nstruct Range {\n  1: optional i32 first\n  2: optional i32 last\n}\n\nstruct ConfigGroup {\n  1: optional TaskConfig config\n  3: optional set<Range> instances\n}\n\nstruct ConfigSummary {\n  1: optional JobKey key\n  2: optional set<ConfigGroup> groups\n}\n\nstruct PopulateJobResult {\n  2: optional TaskConfig taskConfig\n}\n\nstruct GetQuotaResult {\n  /** Total allocated resource quota. */\n  1: optional ResourceAggregate quota\n  /** Resources consumed by production jobs from a shared resource pool. */\n  2: optional ResourceAggregate prodSharedConsumption\n  /** Resources consumed by non-production jobs from a shared resource pool. */\n  3: optional ResourceAggregate nonProdSharedConsumption\n  /** Resources consumed by production jobs from a dedicated resource pool. */\n  4: optional ResourceAggregate prodDedicatedConsumption\n  /** Resources consumed by non-production jobs from a dedicated resource pool. */\n  5: optional ResourceAggregate nonProdDedicatedConsumption\n}\n\n/** States that a task may be in. */\nenum ScheduleStatus {\n  // TODO(maxim): This state does not add much value. Consider dropping it completely.\n  /* Initial state for a task.  A task will remain in this state until it has been persisted. */\n  INIT             = 11,\n  /** The task will be rescheduled, but is being throttled for restarting too frequently. */\n  THROTTLED        = 16,\n  /** Task is awaiting assignment to a slave. */\n  PENDING          = 0,\n  /** Task has been assigned to a slave. */\n  ASSIGNED         = 9,\n  /** Slave has acknowledged receipt of task and is bootstrapping the task. */\n  STARTING         = 1,\n  /** The task is running on the slave. */\n  RUNNING          = 2,\n  /** The task terminated with an exit code of zero. */\n  FINISHED         = 3,\n  /** The task is being preempted by another task. */\n  PREEMPTING       = 13,\n  /** The task is being restarted in response to a user request. */\n  RESTARTING       = 12,\n  /** The task is being restarted in response to a host maintenance request. */\n  DRAINING         = 17,\n  /** The task terminated with a non-zero exit code. */\n  FAILED           = 4,\n  /** Execution of the task was terminated by the system. */\n  KILLED           = 5,\n  /** The task is being forcibly killed. */\n  KILLING          = 6,\n  /** A fault in the task environment has caused the system to believe the task no longer exists.\n   * This can happen, for example, when a slave process disappears.\n   */\n  LOST             = 7\n}\n\n// States that a task may be in while still considered active.\nconst set<ScheduleStatus> ACTIVE_STATES = [ScheduleStatus.ASSIGNED,\n                                           ScheduleStatus.DRAINING,\n                                           ScheduleStatus.KILLING,\n                                           ScheduleStatus.PENDING,\n                                           ScheduleStatus.PREEMPTING,\n                                           ScheduleStatus.RESTARTING\n                                           ScheduleStatus.RUNNING,\n                                           ScheduleStatus.STARTING,\n                                           ScheduleStatus.THROTTLED]\n\n// States that a task may be in while associated with a slave machine and non-terminal.\nconst set<ScheduleStatus> SLAVE_ASSIGNED_STATES = [ScheduleStatus.ASSIGNED,\n                                                   ScheduleStatus.DRAINING,\n                                                   ScheduleStatus.KILLING,\n                                                   ScheduleStatus.PREEMPTING,\n                                                   ScheduleStatus.RESTARTING,\n                                                   ScheduleStatus.RUNNING,\n                                                   ScheduleStatus.STARTING]\n\n// States that a task may be in while in an active sandbox.\nconst set<ScheduleStatus> LIVE_STATES = [ScheduleStatus.KILLING,\n                                         ScheduleStatus.PREEMPTING,\n                                         ScheduleStatus.RESTARTING,\n                                         ScheduleStatus.DRAINING,\n                                         ScheduleStatus.RUNNING]\n\n// States a completed task may be in.\nconst set<ScheduleStatus> TERMINAL_STATES = [ScheduleStatus.FAILED,\n                                             ScheduleStatus.FINISHED,\n                                             ScheduleStatus.KILLED,\n                                             ScheduleStatus.LOST]\n\n// Regular expressions for matching valid identifiers for job path components. All expressions\n// below should accept and reject the same set of inputs.\nconst string GOOD_IDENTIFIER_PATTERN = \"^[\\\\w\\\\-\\\\.]+$\"\n// JVM: Use with java.util.regex.Pattern#compile\nconst string GOOD_IDENTIFIER_PATTERN_JVM = GOOD_IDENTIFIER_PATTERN\n// Python: Use with re.compile\nconst string GOOD_IDENTIFIER_PATTERN_PYTHON = GOOD_IDENTIFIER_PATTERN\n\n/** Event marking a state transition within a task's lifecycle. */\nstruct TaskEvent {\n  /** Epoch timestamp in milliseconds. */\n  1: optional i64 timestamp\n  /** New status of the task. */\n  2: optional ScheduleStatus status\n  /** Audit message that explains why a transition occurred. */\n  3: optional string message\n  /** Hostname of the scheduler machine that performed the event. */\n  4: optional string scheduler\n}\n\n/** A task assignment that is provided to an executor. */\nstruct AssignedTask {\n  /** The mesos task ID for this task.  Guaranteed to be globally unique */\n  1: optional string taskId\n\n  /**\n   * The mesos slave ID that this task has been assigned to.\n   * This will not be populated for a PENDING task.\n   */\n  2: optional string slaveId\n\n  /**\n   * The name of the machine that this task has been assigned to.\n   * This will not be populated for a PENDING task.\n   */\n  3: optional string slaveHost\n\n  /** Information about how to run this task. */\n  4: optional TaskConfig task\n  /** Ports reserved on the machine while this task is running. */\n  5: optional map<string, i32> assignedPorts\n\n  /**\n   * The instance ID assigned to this task. Instance IDs must be unique and contiguous within a\n   * job, and will be in the range [0, N-1] (inclusive) for a job that has N instances.\n   */\n  6: optional i32 instanceId\n}\n\n/** A task that has been scheduled. */\nstruct ScheduledTask {\n  /** The task that was scheduled. */\n  1: optional AssignedTask assignedTask\n  /** The current status of this task. */\n  2: optional ScheduleStatus status\n  /**\n   * The number of failures that this task has accumulated over the multi-generational history of\n   * this task.\n   */\n  3: optional i32 failureCount\n  /** State change history for this task. */\n  4: optional list<TaskEvent> taskEvents\n  /**\n   * The task ID of the previous generation of this task.  When a task is automatically rescheduled,\n   * a copy of the task is created and ancestor ID of the previous task's task ID.\n   */\n  5: optional string ancestorId\n}\n\nstruct ScheduleStatusResult {\n  1: optional list<ScheduledTask> tasks\n}\n\nstruct GetJobsResult {\n  1: optional set<JobConfiguration> configs\n}\n\n/**\n * Contains a set of restrictions on matching tasks where all restrictions must be met\n * (terms are AND'ed together).\n */\nstruct TaskQuery {\n  14: optional string role\n  9: optional string environment\n  2: optional string jobName\n  4: optional set<string> taskIds\n  5: optional set<ScheduleStatus> statuses\n  7: optional set<i32> instanceIds\n  10: optional set<string> slaveHosts\n  11: optional set<JobKey> jobKeys\n  12: optional i32 offset\n  13: optional i32 limit\n}\n\nstruct HostStatus {\n  1: optional string host\n  2: optional MaintenanceMode mode\n}\n\nstruct RoleSummary {\n  1: optional string role\n  2: optional i32 jobCount\n  3: optional i32 cronJobCount\n}\n\nstruct Hosts {\n  1: optional set<string> hostNames\n}\n\nstruct PendingReason {\n  1: optional string taskId\n  2: optional string reason\n}\n\n/** States that a job update may be in. */\nenum JobUpdateStatus {\n  /** Update is in progress. */\n  ROLLING_FORWARD = 0,\n\n  /** Update has failed and is being rolled back. */\n  ROLLING_BACK = 1,\n\n  /** Update has been paused while in progress. */\n  ROLL_FORWARD_PAUSED = 2,\n\n  /** Update has been paused during rollback. */\n  ROLL_BACK_PAUSED = 3,\n\n  /** Update has completed successfully. */\n  ROLLED_FORWARD = 4,\n\n  /** Update has failed and rolled back. */\n  ROLLED_BACK = 5,\n\n  /** Update was aborted. */\n  ABORTED = 6,\n\n  /** Unknown error during update. */\n  ERROR = 7,\n\n  /**\n   * Update failed to complete.\n   * This can happen if failure thresholds are met while rolling forward, but rollback is disabled,\n   * or if failure thresholds are met when rolling back.\n   */\n  FAILED = 8,\n\n  /** Update has been blocked while in progress due to missing/expired pulse. */\n  ROLL_FORWARD_AWAITING_PULSE = 9,\n\n  /** Update has been blocked during rollback due to missing/expired pulse. */\n  ROLL_BACK_AWAITING_PULSE = 10\n}\n\n/** States the job update can be in while still considered active. */\nconst set<JobUpdateStatus> ACTIVE_JOB_UPDATE_STATES = [JobUpdateStatus.ROLLING_FORWARD,\n                                                       JobUpdateStatus.ROLLING_BACK,\n                                                       JobUpdateStatus.ROLL_FORWARD_PAUSED,\n                                                       JobUpdateStatus.ROLL_BACK_PAUSED,\n                                                       JobUpdateStatus.ROLL_FORWARD_AWAITING_PULSE,\n                                                       JobUpdateStatus.ROLL_BACK_AWAITING_PULSE]\n/** States the job update can be in while waiting for a pulse. */\nconst set<JobUpdateStatus> AWAITNG_PULSE_JOB_UPDATE_STATES = [JobUpdateStatus.ROLL_FORWARD_AWAITING_PULSE,\n                                                              JobUpdateStatus.ROLL_BACK_AWAITING_PULSE]\n\n/** Job update actions that can be applied to job instances. */\nenum JobUpdateAction {\n  /**\n   * An instance was moved to the target state successfully, and declared healthy if the desired\n   * state did not involve deleting the instance.\n   */\n  INSTANCE_UPDATED = 1,\n\n  /**\n   * An instance was rolled back because the job update did not succeed.  The instance was reverted\n   * to the original state prior to the job update, which means that the instance was removed if\n   * the update added instances to the job.\n   */\n  INSTANCE_ROLLED_BACK = 2,\n\n  /**\n   * An instance is being moved from the original state to the desired state.\n   */\n  INSTANCE_UPDATING = 3,\n\n  /**\n   * An instance is being moved from the desired state back to the original state, because the job\n   * update failed.\n   */\n  INSTANCE_ROLLING_BACK = 4,\n\n  /** An instance update was attempted but failed and was not rolled back. */\n  INSTANCE_UPDATE_FAILED = 5,\n\n  /** An instance rollback was attempted but failed. */\n  INSTANCE_ROLLBACK_FAILED = 6\n}\n\n/** Status of the coordinated update. Intended as a response to pulseJobUpdate RPC. */\nenum JobUpdatePulseStatus {\n  /**\n   *  Update is active. See ACTIVE_JOB_UPDATE_STATES for statuses considered active.\n   */\n  OK = 1,\n\n  /**\n   * Update has reached terminal state. See TERMINAL_JOB_UPDATE_STATES for statuses\n   * considered terminal.\n   */\n  FINISHED = 2\n}\n\n/** Job update key. */\nstruct JobUpdateKey {\n  /** Job being updated */\n  1: optional JobKey job\n\n  /** Update ID. */\n  2: optional string id\n}\n\n/** Job update thresholds and limits. */\nstruct JobUpdateSettings {\n  /** Max number of instances being updated at any given moment. */\n  1: optional i32 updateGroupSize\n\n  /** Max number of instance failures to tolerate before marking instance as FAILED. */\n  2: optional i32 maxPerInstanceFailures\n\n  /** Max number of FAILED instances to tolerate before terminating the update. */\n  3: optional i32 maxFailedInstances\n\n  /** Min time to watch a RUNNING instance. */\n  5: optional i32 minWaitInInstanceRunningMs\n\n  /** If true, enables failed update rollback. */\n  6: optional bool rollbackOnFailure\n\n  /** Instance IDs to act on. All instances will be affected if this is not set. */\n  7: optional set<Range> updateOnlyTheseInstances\n\n  /**\n   * If true, use updateGroupSize as strict batching boundaries, and avoid proceeding to another\n   * batch until the preceding batch finishes updating.\n   */\n  8: optional bool waitForBatchCompletion\n\n /**\n  * If set, requires external calls to pulseJobUpdate RPC within the specified rate for the\n  * update to make progress. If no pulses received within specified interval the update will\n  * block. A blocked update is unable to continue but retains its current status. It may only get\n  * unblocked by a fresh pulseJobUpdate call.\n  */\n  9: optional i32 blockIfNoPulsesAfterMs\n}\n\n/** Event marking a state transition in job update lifecycle. */\nstruct JobUpdateEvent {\n  /** Update status. */\n  1: optional JobUpdateStatus status\n\n  /** Epoch timestamp in milliseconds. */\n  2: optional i64 timestampMs\n\n  /** User who performed this event (if user-initiated). */\n  3: optional string user\n\n  /**\n   * Message from the user (for user-initiated transitions) or the scheduler about why the state was\n   * changed.\n   */\n  4: optional string message\n}\n\n/** Event marking a state transition in job instance update lifecycle. */\nstruct JobInstanceUpdateEvent {\n  /** Job instance ID. */\n  1: optional i32 instanceId\n\n  /** Epoch timestamp in milliseconds. */\n  2: optional i64 timestampMs\n\n  /** Job update action taken on the instance. */\n  3: optional JobUpdateAction action\n}\n\n/** Maps instance IDs to TaskConfigs it. */\nstruct InstanceTaskConfig {\n  /** A TaskConfig associated with instances. */\n  1: optional TaskConfig task\n\n  /** Instances associated with the TaskConfig. */\n  2: optional set<Range> instances\n}\n\n/** Current job update state including status and created/modified timestamps. */\nstruct JobUpdateState {\n  /** Current status of the update. */\n  1: optional JobUpdateStatus status\n\n  /** Created timestamp in milliseconds. */\n  2: optional i64 createdTimestampMs\n\n  /** Last modified timestamp in milliseconds. */\n  3: optional i64 lastModifiedTimestampMs\n}\n\n/** Summary of the job update including job key, user and current state. */\nstruct JobUpdateSummary {\n  /** Unique identifier for the update. */\n  5: optional JobUpdateKey key\n\n  /** User initiated an update. */\n  3: optional string user\n\n  /** Current job update state. */\n  4: optional JobUpdateState state\n\n  /** Update metadata supplied by the client. */\n  6: optional set<Metadata> metadata\n}\n\n/** Update configuration and setting details. */\nstruct JobUpdateInstructions {\n  /** Actual InstanceId -> TaskConfig mapping when the update was requested. */\n  1: optional set<InstanceTaskConfig> initialState\n\n  /** Desired configuration when the update completes. */\n  2: optional InstanceTaskConfig desiredState\n\n  /** Update specific settings. */\n  3: optional JobUpdateSettings settings\n}\n\n/** Full definition of the job update. */\nstruct JobUpdate {\n  /** Update summary. */\n  1: optional JobUpdateSummary summary\n\n  /** Update configuration. */\n  2: optional JobUpdateInstructions instructions\n}\n\nstruct JobUpdateDetails {\n  /** Update definition. */\n  1: optional JobUpdate update\n\n  /** History for this update. */\n  2: optional list<JobUpdateEvent> updateEvents\n\n  /** History for the individual instances updated. */\n  3: optional list<JobInstanceUpdateEvent> instanceEvents\n}\n\n/** A request to update the following instances of an existing job. Used by startUpdate. */\nstruct JobUpdateRequest {\n  /** Desired TaskConfig to apply. */\n  1: optional TaskConfig taskConfig\n\n  /** Desired number of instances of the task config. */\n  2: optional i32 instanceCount\n\n  /** Update settings and limits. */\n  3: optional JobUpdateSettings settings\n\n  /** Update metadata supplied by the client issuing the JobUpdateRequest. */\n  4: optional set<Metadata> metadata\n}\n\n/**\n * Contains a set of restrictions on matching job updates where all restrictions must be met\n * (terms are AND'ed together).\n */\nstruct JobUpdateQuery {\n  /** Job role. */\n  2: optional string role\n\n  /** Unique identifier for a job update. */\n  8: optional JobUpdateKey key\n\n  /** Job key. */\n  3: optional JobKey jobKey\n\n  /** User who created the update. */\n  4: optional string user\n\n  /** Set of update statuses. */\n  5: optional set<JobUpdateStatus> updateStatuses\n\n  /** Offset to serve data from. Used by pagination. */\n  6: optional i32 offset\n\n  /** Number or records to serve. Used by pagination. */\n  7: optional i32 limit\n}\n\nstruct ListBackupsResult {\n  1: optional set<string> backups\n}\n\nstruct StartMaintenanceResult {\n  1: optional set<HostStatus> statuses\n}\n\nstruct DrainHostsResult {\n  1: optional set<HostStatus> statuses\n}\n\nstruct QueryRecoveryResult {\n  1: optional set<ScheduledTask> tasks\n}\n\nstruct MaintenanceStatusResult {\n  1: optional set<HostStatus> statuses\n}\n\nstruct EndMaintenanceResult {\n  1: optional set<HostStatus> statuses\n}\n\nstruct RoleSummaryResult {\n  1: optional set<RoleSummary> summaries\n}\n\nstruct JobSummaryResult {\n  1: optional set<JobSummary> summaries\n}\n\nstruct ConfigSummaryResult {\n  1: optional ConfigSummary summary\n}\n\nstruct GetPendingReasonResult {\n  1: optional set<PendingReason> reasons\n}\n\n/** Result of the startUpdate call. */\nstruct StartJobUpdateResult {\n  /** Unique identifier for the job update. */\n  1: optional JobUpdateKey key\n\n  /** Summary of the update that is in progress for the given JobKey. */\n  2: optional JobUpdateSummary updateSummary\n}\n\n/** Result of the getJobUpdateSummaries call. */\nstruct GetJobUpdateSummariesResult {\n  1: optional list<JobUpdateSummary> updateSummaries\n}\n\n/** Result of the getJobUpdateDetails call. */\nstruct GetJobUpdateDetailsResult {\n  // TODO(zmanji): Remove this once we complete AURORA-1765\n  1: optional JobUpdateDetails details\n  2: optional list<JobUpdateDetails> detailsList\n}\n\n/** Result of the pulseJobUpdate call. */\nstruct PulseJobUpdateResult {\n  1: optional JobUpdatePulseStatus status\n}\n\nstruct GetJobUpdateDiffResult {\n  /** Instance addition diff details. */\n  1: optional set<ConfigGroup> add\n\n  /** Instance removal diff details. */\n  2: optional set<ConfigGroup> remove\n\n  /** Instance update diff details. */\n  3: optional set<ConfigGroup> update\n\n  /** Instances unchanged by the update. */\n  4: optional set<ConfigGroup> unchanged\n}\n\n/** Tier information. */\nstruct TierConfig {\n  /** Name of tier. */\n  1: optional string name\n  /** Tier attributes. */\n  2: optional map<string, string> settings\n}\n\n/** Result of the getTierConfigResult call. */\nstruct GetTierConfigResult {\n  /** Name of the default tier. */\n  1: optional string defaultTierName\n  /** Set of tier configurations. */\n  2: optional set<TierConfig> tiers\n}\n\n/** Information about the scheduler. */\nstruct ServerInfo {\n  1: optional string clusterName\n  /** A url prefix for job container stats. */\n  3: optional string statsUrlPrefix\n}\n\nunion Result {\n  1: PopulateJobResult populateJobResult\n  3: ScheduleStatusResult scheduleStatusResult\n  4: GetJobsResult getJobsResult\n  5: GetQuotaResult getQuotaResult\n  6: ListBackupsResult listBackupsResult\n  7: StartMaintenanceResult startMaintenanceResult\n  8: DrainHostsResult drainHostsResult\n  9: QueryRecoveryResult queryRecoveryResult\n  10: MaintenanceStatusResult maintenanceStatusResult\n  11: EndMaintenanceResult endMaintenanceResult\n  17: RoleSummaryResult roleSummaryResult\n  18: JobSummaryResult jobSummaryResult\n  20: ConfigSummaryResult configSummaryResult\n  21: GetPendingReasonResult getPendingReasonResult\n  22: StartJobUpdateResult startJobUpdateResult\n  23: GetJobUpdateSummariesResult getJobUpdateSummariesResult\n  24: GetJobUpdateDetailsResult getJobUpdateDetailsResult\n  25: PulseJobUpdateResult pulseJobUpdateResult\n  26: GetJobUpdateDiffResult getJobUpdateDiffResult\n  27: GetTierConfigResult getTierConfigResult\n}\n\nstruct ResponseDetail {\n  1: optional string message\n}\n\nstruct Response {\n  1: optional ResponseCode responseCode\n  5: optional ServerInfo serverInfo\n  /** Payload from the invoked RPC. */\n  3: optional Result result\n  /**\n   * Messages from the server relevant to the request, such as warnings or use of deprecated\n   * features.\n   */\n  6: optional list<ResponseDetail> details\n}\n\n// A service that provides all the read only calls to the Aurora scheduler.\nservice ReadOnlyScheduler {\n  /** Returns a summary of the jobs grouped by role. */\n  Response getRoleSummary()\n\n  /** Returns a summary of jobs, optionally only those owned by a specific role. */\n  Response getJobSummary(1: string role)\n\n  /** Fetches the status of tasks. */\n  Response getTasksStatus(1: TaskQuery query)\n\n  /**\n   * Same as getTaskStatus but without the TaskConfig.ExecutorConfig data set.\n   * This is an interim solution until we have a better way to query TaskConfigs (AURORA-541).\n   */\n  Response getTasksWithoutConfigs(1: TaskQuery query)\n\n  /** Returns user-friendly reasons (if available) for tasks retained in PENDING state. */\n  Response getPendingReason(1: TaskQuery query)\n\n  /** Fetches the configuration summary of active tasks for the specified job. */\n  Response getConfigSummary(1: JobKey job)\n\n  /**\n   * Fetches the status of jobs.\n   * ownerRole is optional, in which case all jobs are returned.\n   */\n  Response getJobs(1: string ownerRole)\n\n  /** Fetches the quota allocated for a user. */\n  Response getQuota(1: string ownerRole)\n\n  /**\n   * Populates fields in a job configuration as though it were about to be run.\n   * This can be used to diff a configuration running tasks.\n   */\n  Response populateJobConfig(1: JobConfiguration description)\n\n  /** Gets job update summaries. */\n  Response getJobUpdateSummaries(1: JobUpdateQuery jobUpdateQuery)\n\n  /** Gets job update details. */\n  // TODO(zmanji): `key` is deprecated, remove this with AURORA-1765\n  Response getJobUpdateDetails(1: JobUpdateKey key, 2: JobUpdateQuery query)\n\n  /** Gets the diff between client (desired) and server (current) job states. */\n  Response getJobUpdateDiff(1: JobUpdateRequest request)\n\n  /** Gets tier configurations. */\n  Response getTierConfigs()\n}\n\nservice AuroraSchedulerManager extends ReadOnlyScheduler {\n  /**\n   * Creates a new job.  The request will be denied if a job with the provided name already exists\n   * in the cluster.\n   */\n  Response createJob(1: JobConfiguration description)\n\n  /**\n   * Enters a job into the cron schedule, without actually starting the job.\n   * If the job is already present in the schedule, this will update the schedule entry with the new\n   * configuration.\n   */\n  Response scheduleCronJob(1: JobConfiguration description)\n\n  /**\n   * Removes a job from the cron schedule. The request will be denied if the job was not previously\n   * scheduled with scheduleCronJob.\n   */\n  Response descheduleCronJob(4: JobKey job)\n\n  /**\n   * Starts a cron job immediately.  The request will be denied if the specified job does not\n   * exist for the role account, or the job is not a cron job.\n   */\n  Response startCronJob(4: JobKey job)\n\n  /** Restarts a batch of shards. */\n  Response restartShards(5: JobKey job, 3: set<i32> shardIds)\n\n  /** Initiates a kill on tasks. */\n  Response killTasks(4: JobKey job, 5: set<i32> instances, 6: string message)\n\n  /**\n   * Adds new instances with the TaskConfig of the existing instance pointed by the key.\n   */\n  Response addInstances(3: InstanceKey key, 4: i32 count)\n\n  // TODO(maxim): reevaluate if it's still needed when client updater is gone (AURORA-785).\n  /**\n   * Replaces the template (configuration) for the existing cron job.\n   * The cron job template (configuration) must exist for the call to succeed.\n   */\n  Response replaceCronTemplate(1: JobConfiguration config)\n\n  /** Starts update of the existing service job. */\n  Response startJobUpdate(\n      /** A description of how to change the job. */\n      1: JobUpdateRequest request,\n      /** A user-specified message to include with the induced job update state change. */\n      3: string message)\n\n  /**\n   * Pauses the specified job update. Can be resumed by resumeUpdate call.\n   */\n  Response pauseJobUpdate(\n      /** The update to pause. */\n      1: JobUpdateKey key,\n      /** A user-specified message to include with the induced job update state change. */\n      3: string message)\n\n  /** Resumes progress of a previously paused job update. */\n  Response resumeJobUpdate(\n      /** The update to resume. */\n      1: JobUpdateKey key,\n      /** A user-specified message to include with the induced job update state change. */\n      3: string message)\n\n  /** Permanently aborts the job update. Does not remove the update history. */\n  Response abortJobUpdate(\n      /** The update to abort. */\n      1: JobUpdateKey key,\n      /** A user-specified message to include with the induced job update state change. */\n      3: string message)\n\n  /**\n   * Rollbacks the specified active job update to the initial state.\n   */\n  Response rollbackJobUpdate(\n      /** The update to rollback. */\n      1: JobUpdateKey key,\n      /** A user-specified message to include with the induced job update state change. */\n      2: string message)\n\n  /**\n   * Allows progress of the job update in case blockIfNoPulsesAfterMs is specified in\n   * JobUpdateSettings. Unblocks progress if the update was previously blocked.\n   * Responds with ResponseCode.INVALID_REQUEST in case an unknown update key is specified.\n   */\n  Response pulseJobUpdate(1: JobUpdateKey key)\n}\n\nstruct ExplicitReconciliationSettings {\n  1: optional i32 batchSize\n}\n\n// It would be great to compose these services rather than extend, but that won't be possible until\n// https://issues.apache.org/jira/browse/THRIFT-66 is resolved.\nservice AuroraAdmin extends AuroraSchedulerManager {\n  /** Assign quota to a user.  This will overwrite any pre-existing quota for the user. */\n  Response setQuota(1: string ownerRole, 2: ResourceAggregate quota)\n\n  /**\n   * Forces a task into a specific state.  This does not guarantee the task will enter the given\n   * state, as the task must still transition within the bounds of the state machine.  However,\n   * it attempts to enter that state via the state machine.\n   */\n  Response forceTaskState(\n      1: string taskId,\n      2: ScheduleStatus status)\n\n  /** Immediately writes a storage snapshot to disk. */\n  Response performBackup()\n\n  /** Lists backups that are available for recovery. */\n  Response listBackups()\n\n  /** Loads a backup to an in-memory storage.  This must precede all other recovery operations. */\n  Response stageRecovery(1: string backupId)\n\n  /** Queries for tasks in a staged recovery. */\n  Response queryRecovery(1: TaskQuery query)\n\n  /** Deletes tasks from a staged recovery. */\n  Response deleteRecoveryTasks(1: TaskQuery query)\n\n  /** Commits a staged recovery, completely replacing the previous storage state. */\n  Response commitRecovery()\n\n  /** Unloads (aborts) a staged recovery. */\n  Response unloadRecovery()\n\n  /** Put the given hosts into maintenance mode. */\n  Response startMaintenance(1: Hosts hosts)\n\n  /** Ask scheduler to begin moving tasks scheduled on given hosts. */\n  Response drainHosts(1: Hosts hosts)\n\n  /** Retrieve the current maintenance states for a group of hosts. */\n  Response maintenanceStatus(1: Hosts hosts)\n\n  /** Set the given hosts back into serving mode. */\n  Response endMaintenance(1: Hosts hosts)\n\n  /** Start a storage snapshot and block until it completes. */\n  Response snapshot()\n\n  /** Tell scheduler to trigger an explicit task reconciliation with the given settings. */\n  Response triggerExplicitTaskReconciliation(1: ExplicitReconciliationSettings settings)\n\n  /** Tell scheduler to trigger an implicit task reconciliation. */\n  Response triggerImplicitTaskReconciliation()\n\n  /**\n   * Force prune any (terminal) tasks that match the query. If no statuses are supplied with the\n   * query, it will default to all terminal task states. If statuses are supplied, they must be\n   * terminal states.\n   */\n  Response pruneTasks(1: TaskQuery query)\n}\n\n// The name of the header that should be sent to bypass leader redirection in the Scheduler.\nconst string BYPASS_LEADER_REDIRECT_HEADER_NAME = 'Bypass-Leader-Redirect'\n\n// The path under which a task's filesystem should be mounted when using images and the Mesos\n// unified containerizer.\nconst string TASK_FILESYSTEM_MOUNT_POINT = 'taskfs'\n"

// Code generated by thriftrw-plugin-yarpc
// @generated

package auroraadmintest

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	api "github.com/uber/peloton/.gen/thrift/aurora/api"
	auroraadminclient "github.com/uber/peloton/.gen/thrift/aurora/api/auroraadminclient"
	yarpc "go.uber.org/yarpc"
)

// MockClient implements a gomock-compatible mock client for service
// AuroraAdmin.
type MockClient struct {
	ctrl     *gomock.Controller
	recorder *_MockClientRecorder
}

var _ auroraadminclient.Interface = (*MockClient)(nil)

type _MockClientRecorder struct {
	mock *MockClient
}

// Build a new mock client for service AuroraAdmin.
//
// 	mockCtrl := gomock.NewController(t)
// 	client := auroraadmintest.NewMockClient(mockCtrl)
//
// Use EXPECT() to set expectations on the mock.
func NewMockClient(ctrl *gomock.Controller) *MockClient {
	mock := &MockClient{ctrl: ctrl}
	mock.recorder = &_MockClientRecorder{mock}
	return mock
}

// EXPECT returns an object that allows you to define an expectation on the
// AuroraAdmin mock client.
func (m *MockClient) EXPECT() *_MockClientRecorder {
	return m.recorder
}

// CommitRecovery responds to a CommitRecovery call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().CommitRecovery(gomock.Any(), ...).Return(...)
// 	... := client.CommitRecovery(...)
func (m *MockClient) CommitRecovery(
	ctx context.Context,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "CommitRecovery", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) CommitRecovery(
	ctx interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "CommitRecovery", args...)
}

// DeleteRecoveryTasks responds to a DeleteRecoveryTasks call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().DeleteRecoveryTasks(gomock.Any(), ...).Return(...)
// 	... := client.DeleteRecoveryTasks(...)
func (m *MockClient) DeleteRecoveryTasks(
	ctx context.Context,
	_Query *api.TaskQuery,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Query}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "DeleteRecoveryTasks", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) DeleteRecoveryTasks(
	ctx interface{},
	_Query interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Query}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "DeleteRecoveryTasks", args...)
}

// DrainHosts responds to a DrainHosts call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().DrainHosts(gomock.Any(), ...).Return(...)
// 	... := client.DrainHosts(...)
func (m *MockClient) DrainHosts(
	ctx context.Context,
	_Hosts *api.Hosts,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Hosts}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "DrainHosts", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) DrainHosts(
	ctx interface{},
	_Hosts interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Hosts}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "DrainHosts", args...)
}

// EndMaintenance responds to a EndMaintenance call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().EndMaintenance(gomock.Any(), ...).Return(...)
// 	... := client.EndMaintenance(...)
func (m *MockClient) EndMaintenance(
	ctx context.Context,
	_Hosts *api.Hosts,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Hosts}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "EndMaintenance", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) EndMaintenance(
	ctx interface{},
	_Hosts interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Hosts}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "EndMaintenance", args...)
}

// ForceTaskState responds to a ForceTaskState call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().ForceTaskState(gomock.Any(), ...).Return(...)
// 	... := client.ForceTaskState(...)
func (m *MockClient) ForceTaskState(
	ctx context.Context,
	_TaskId *string,
	_Status *api.ScheduleStatus,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _TaskId, _Status}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "ForceTaskState", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) ForceTaskState(
	ctx interface{},
	_TaskId interface{},
	_Status interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _TaskId, _Status}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "ForceTaskState", args...)
}

// ListBackups responds to a ListBackups call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().ListBackups(gomock.Any(), ...).Return(...)
// 	... := client.ListBackups(...)
func (m *MockClient) ListBackups(
	ctx context.Context,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "ListBackups", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) ListBackups(
	ctx interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "ListBackups", args...)
}

// MaintenanceStatus responds to a MaintenanceStatus call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().MaintenanceStatus(gomock.Any(), ...).Return(...)
// 	... := client.MaintenanceStatus(...)
func (m *MockClient) MaintenanceStatus(
	ctx context.Context,
	_Hosts *api.Hosts,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Hosts}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "MaintenanceStatus", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) MaintenanceStatus(
	ctx interface{},
	_Hosts interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Hosts}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "MaintenanceStatus", args...)
}

// PerformBackup responds to a PerformBackup call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().PerformBackup(gomock.Any(), ...).Return(...)
// 	... := client.PerformBackup(...)
func (m *MockClient) PerformBackup(
	ctx context.Context,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "PerformBackup", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) PerformBackup(
	ctx interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "PerformBackup", args...)
}

// PruneTasks responds to a PruneTasks call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().PruneTasks(gomock.Any(), ...).Return(...)
// 	... := client.PruneTasks(...)
func (m *MockClient) PruneTasks(
	ctx context.Context,
	_Query *api.TaskQuery,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Query}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "PruneTasks", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) PruneTasks(
	ctx interface{},
	_Query interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Query}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "PruneTasks", args...)
}

// QueryRecovery responds to a QueryRecovery call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().QueryRecovery(gomock.Any(), ...).Return(...)
// 	... := client.QueryRecovery(...)
func (m *MockClient) QueryRecovery(
	ctx context.Context,
	_Query *api.TaskQuery,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Query}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "QueryRecovery", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) QueryRecovery(
	ctx interface{},
	_Query interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Query}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "QueryRecovery", args...)
}

// SetQuota responds to a SetQuota call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().SetQuota(gomock.Any(), ...).Return(...)
// 	... := client.SetQuota(...)
func (m *MockClient) SetQuota(
	ctx context.Context,
	_OwnerRole *string,
	_Quota *api.ResourceAggregate,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _OwnerRole, _Quota}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "SetQuota", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) SetQuota(
	ctx interface{},
	_OwnerRole interface{},
	_Quota interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _OwnerRole, _Quota}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "SetQuota", args...)
}

// Snapshot responds to a Snapshot call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().Snapshot(gomock.Any(), ...).Return(...)
// 	... := client.Snapshot(...)
func (m *MockClient) Snapshot(
	ctx context.Context,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "Snapshot", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) Snapshot(
	ctx interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "Snapshot", args...)
}

// StageRecovery responds to a StageRecovery call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().StageRecovery(gomock.Any(), ...).Return(...)
// 	... := client.StageRecovery(...)
func (m *MockClient) StageRecovery(
	ctx context.Context,
	_BackupId *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _BackupId}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "StageRecovery", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) StageRecovery(
	ctx interface{},
	_BackupId interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _BackupId}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "StageRecovery", args...)
}

// StartMaintenance responds to a StartMaintenance call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().StartMaintenance(gomock.Any(), ...).Return(...)
// 	... := client.StartMaintenance(...)
func (m *MockClient) StartMaintenance(
	ctx context.Context,
	_Hosts *api.Hosts,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Hosts}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "StartMaintenance", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) StartMaintenance(
	ctx interface{},
	_Hosts interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Hosts}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "StartMaintenance", args...)
}

// TriggerExplicitTaskReconciliation responds to a TriggerExplicitTaskReconciliation call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().TriggerExplicitTaskReconciliation(gomock.Any(), ...).Return(...)
// 	... := client.TriggerExplicitTaskReconciliation(...)
func (m *MockClient) TriggerExplicitTaskReconciliation(
	ctx context.Context,
	_Settings *api.ExplicitReconciliationSettings,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Settings}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "TriggerExplicitTaskReconciliation", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) TriggerExplicitTaskReconciliation(
	ctx interface{},
	_Settings interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Settings}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "TriggerExplicitTaskReconciliation", args...)
}

// TriggerImplicitTaskReconciliation responds to a TriggerImplicitTaskReconciliation call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().TriggerImplicitTaskReconciliation(gomock.Any(), ...).Return(...)
// 	... := client.TriggerImplicitTaskReconciliation(...)
func (m *MockClient) TriggerImplicitTaskReconciliation(
	ctx context.Context,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "TriggerImplicitTaskReconciliation", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) TriggerImplicitTaskReconciliation(
	ctx interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "TriggerImplicitTaskReconciliation", args...)
}

// UnloadRecovery responds to a UnloadRecovery call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().UnloadRecovery(gomock.Any(), ...).Return(...)
// 	... := client.UnloadRecovery(...)
func (m *MockClient) UnloadRecovery(
	ctx context.Context,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "UnloadRecovery", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) UnloadRecovery(
	ctx interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "UnloadRecovery", args...)
}

// AbortJobUpdate responds to a AbortJobUpdate call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().AbortJobUpdate(gomock.Any(), ...).Return(...)
// 	... := client.AbortJobUpdate(...)
func (m *MockClient) AbortJobUpdate(
	ctx context.Context,
	_Key *api.JobUpdateKey,
	_Message *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Key, _Message}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "AbortJobUpdate", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) AbortJobUpdate(
	ctx interface{},
	_Key interface{},
	_Message interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Key, _Message}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "AbortJobUpdate", args...)
}

// AddInstances responds to a AddInstances call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().AddInstances(gomock.Any(), ...).Return(...)
// 	... := client.AddInstances(...)
func (m *MockClient) AddInstances(
	ctx context.Context,
	_Key *api.InstanceKey,
	_Count *int32,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Key, _Count}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "AddInstances", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) AddInstances(
	ctx interface{},
	_Key interface{},
	_Count interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Key, _Count}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "AddInstances", args...)
}

// CreateJob responds to a CreateJob call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().CreateJob(gomock.Any(), ...).Return(...)
// 	... := client.CreateJob(...)
func (m *MockClient) CreateJob(
	ctx context.Context,
	_Description *api.JobConfiguration,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Description}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "CreateJob", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) CreateJob(
	ctx interface{},
	_Description interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Description}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "CreateJob", args...)
}

// DescheduleCronJob responds to a DescheduleCronJob call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().DescheduleCronJob(gomock.Any(), ...).Return(...)
// 	... := client.DescheduleCronJob(...)
func (m *MockClient) DescheduleCronJob(
	ctx context.Context,
	_Job *api.JobKey,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Job}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "DescheduleCronJob", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) DescheduleCronJob(
	ctx interface{},
	_Job interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Job}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "DescheduleCronJob", args...)
}

// KillTasks responds to a KillTasks call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().KillTasks(gomock.Any(), ...).Return(...)
// 	... := client.KillTasks(...)
func (m *MockClient) KillTasks(
	ctx context.Context,
	_Job *api.JobKey,
	_Instances map[int32]struct{},
	_Message *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Job, _Instances, _Message}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "KillTasks", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) KillTasks(
	ctx interface{},
	_Job interface{},
	_Instances interface{},
	_Message interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Job, _Instances, _Message}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "KillTasks", args...)
}

// PauseJobUpdate responds to a PauseJobUpdate call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().PauseJobUpdate(gomock.Any(), ...).Return(...)
// 	... := client.PauseJobUpdate(...)
func (m *MockClient) PauseJobUpdate(
	ctx context.Context,
	_Key *api.JobUpdateKey,
	_Message *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Key, _Message}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "PauseJobUpdate", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) PauseJobUpdate(
	ctx interface{},
	_Key interface{},
	_Message interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Key, _Message}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "PauseJobUpdate", args...)
}

// PulseJobUpdate responds to a PulseJobUpdate call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().PulseJobUpdate(gomock.Any(), ...).Return(...)
// 	... := client.PulseJobUpdate(...)
func (m *MockClient) PulseJobUpdate(
	ctx context.Context,
	_Key *api.JobUpdateKey,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Key}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "PulseJobUpdate", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) PulseJobUpdate(
	ctx interface{},
	_Key interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Key}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "PulseJobUpdate", args...)
}

// ReplaceCronTemplate responds to a ReplaceCronTemplate call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().ReplaceCronTemplate(gomock.Any(), ...).Return(...)
// 	... := client.ReplaceCronTemplate(...)
func (m *MockClient) ReplaceCronTemplate(
	ctx context.Context,
	_Config *api.JobConfiguration,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Config}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "ReplaceCronTemplate", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) ReplaceCronTemplate(
	ctx interface{},
	_Config interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Config}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "ReplaceCronTemplate", args...)
}

// RestartShards responds to a RestartShards call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().RestartShards(gomock.Any(), ...).Return(...)
// 	... := client.RestartShards(...)
func (m *MockClient) RestartShards(
	ctx context.Context,
	_Job *api.JobKey,
	_ShardIds map[int32]struct{},
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Job, _ShardIds}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "RestartShards", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) RestartShards(
	ctx interface{},
	_Job interface{},
	_ShardIds interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Job, _ShardIds}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "RestartShards", args...)
}

// ResumeJobUpdate responds to a ResumeJobUpdate call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().ResumeJobUpdate(gomock.Any(), ...).Return(...)
// 	... := client.ResumeJobUpdate(...)
func (m *MockClient) ResumeJobUpdate(
	ctx context.Context,
	_Key *api.JobUpdateKey,
	_Message *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Key, _Message}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "ResumeJobUpdate", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) ResumeJobUpdate(
	ctx interface{},
	_Key interface{},
	_Message interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Key, _Message}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "ResumeJobUpdate", args...)
}

// RollbackJobUpdate responds to a RollbackJobUpdate call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().RollbackJobUpdate(gomock.Any(), ...).Return(...)
// 	... := client.RollbackJobUpdate(...)
func (m *MockClient) RollbackJobUpdate(
	ctx context.Context,
	_Key *api.JobUpdateKey,
	_Message *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Key, _Message}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "RollbackJobUpdate", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) RollbackJobUpdate(
	ctx interface{},
	_Key interface{},
	_Message interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Key, _Message}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "RollbackJobUpdate", args...)
}

// ScheduleCronJob responds to a ScheduleCronJob call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().ScheduleCronJob(gomock.Any(), ...).Return(...)
// 	... := client.ScheduleCronJob(...)
func (m *MockClient) ScheduleCronJob(
	ctx context.Context,
	_Description *api.JobConfiguration,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Description}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "ScheduleCronJob", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) ScheduleCronJob(
	ctx interface{},
	_Description interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Description}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "ScheduleCronJob", args...)
}

// StartCronJob responds to a StartCronJob call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().StartCronJob(gomock.Any(), ...).Return(...)
// 	... := client.StartCronJob(...)
func (m *MockClient) StartCronJob(
	ctx context.Context,
	_Job *api.JobKey,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Job}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "StartCronJob", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) StartCronJob(
	ctx interface{},
	_Job interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Job}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "StartCronJob", args...)
}

// StartJobUpdate responds to a StartJobUpdate call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().StartJobUpdate(gomock.Any(), ...).Return(...)
// 	... := client.StartJobUpdate(...)
func (m *MockClient) StartJobUpdate(
	ctx context.Context,
	_Request *api.JobUpdateRequest,
	_Message *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Request, _Message}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "StartJobUpdate", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) StartJobUpdate(
	ctx interface{},
	_Request interface{},
	_Message interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Request, _Message}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "StartJobUpdate", args...)
}

// GetConfigSummary responds to a GetConfigSummary call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetConfigSummary(gomock.Any(), ...).Return(...)
// 	... := client.GetConfigSummary(...)
func (m *MockClient) GetConfigSummary(
	ctx context.Context,
	_Job *api.JobKey,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Job}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetConfigSummary", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetConfigSummary(
	ctx interface{},
	_Job interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Job}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetConfigSummary", args...)
}

// GetJobSummary responds to a GetJobSummary call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetJobSummary(gomock.Any(), ...).Return(...)
// 	... := client.GetJobSummary(...)
func (m *MockClient) GetJobSummary(
	ctx context.Context,
	_Role *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Role}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetJobSummary", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetJobSummary(
	ctx interface{},
	_Role interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Role}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetJobSummary", args...)
}

// GetJobUpdateDetails responds to a GetJobUpdateDetails call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetJobUpdateDetails(gomock.Any(), ...).Return(...)
// 	... := client.GetJobUpdateDetails(...)
func (m *MockClient) GetJobUpdateDetails(
	ctx context.Context,
	_Key *api.JobUpdateKey,
	_Query *api.JobUpdateQuery,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Key, _Query}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetJobUpdateDetails", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetJobUpdateDetails(
	ctx interface{},
	_Key interface{},
	_Query interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Key, _Query}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetJobUpdateDetails", args...)
}

// GetJobUpdateDiff responds to a GetJobUpdateDiff call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetJobUpdateDiff(gomock.Any(), ...).Return(...)
// 	... := client.GetJobUpdateDiff(...)
func (m *MockClient) GetJobUpdateDiff(
	ctx context.Context,
	_Request *api.JobUpdateRequest,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Request}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetJobUpdateDiff", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetJobUpdateDiff(
	ctx interface{},
	_Request interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Request}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetJobUpdateDiff", args...)
}

// GetJobUpdateSummaries responds to a GetJobUpdateSummaries call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetJobUpdateSummaries(gomock.Any(), ...).Return(...)
// 	... := client.GetJobUpdateSummaries(...)
func (m *MockClient) GetJobUpdateSummaries(
	ctx context.Context,
	_JobUpdateQuery *api.JobUpdateQuery,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _JobUpdateQuery}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetJobUpdateSummaries", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetJobUpdateSummaries(
	ctx interface{},
	_JobUpdateQuery interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _JobUpdateQuery}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetJobUpdateSummaries", args...)
}

// GetJobs responds to a GetJobs call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetJobs(gomock.Any(), ...).Return(...)
// 	... := client.GetJobs(...)
func (m *MockClient) GetJobs(
	ctx context.Context,
	_OwnerRole *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _OwnerRole}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetJobs", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetJobs(
	ctx interface{},
	_OwnerRole interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _OwnerRole}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetJobs", args...)
}

// GetPendingReason responds to a GetPendingReason call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetPendingReason(gomock.Any(), ...).Return(...)
// 	... := client.GetPendingReason(...)
func (m *MockClient) GetPendingReason(
	ctx context.Context,
	_Query *api.TaskQuery,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Query}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetPendingReason", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetPendingReason(
	ctx interface{},
	_Query interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Query}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetPendingReason", args...)
}

// GetQuota responds to a GetQuota call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetQuota(gomock.Any(), ...).Return(...)
// 	... := client.GetQuota(...)
func (m *MockClient) GetQuota(
	ctx context.Context,
	_OwnerRole *string,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _OwnerRole}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetQuota", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetQuota(
	ctx interface{},
	_OwnerRole interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _OwnerRole}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetQuota", args...)
}

// GetRoleSummary responds to a GetRoleSummary call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetRoleSummary(gomock.Any(), ...).Return(...)
// 	... := client.GetRoleSummary(...)
func (m *MockClient) GetRoleSummary(
	ctx context.Context,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetRoleSummary", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetRoleSummary(
	ctx interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetRoleSummary", args...)
}

// GetTasksStatus responds to a GetTasksStatus call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetTasksStatus(gomock.Any(), ...).Return(...)
// 	... := client.GetTasksStatus(...)
func (m *MockClient) GetTasksStatus(
	ctx context.Context,
	_Query *api.TaskQuery,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Query}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetTasksStatus", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetTasksStatus(
	ctx interface{},
	_Query interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Query}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetTasksStatus", args...)
}

// GetTasksWithoutConfigs responds to a GetTasksWithoutConfigs call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetTasksWithoutConfigs(gomock.Any(), ...).Return(...)
// 	... := client.GetTasksWithoutConfigs(...)
func (m *MockClient) GetTasksWithoutConfigs(
	ctx context.Context,
	_Query *api.TaskQuery,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Query}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetTasksWithoutConfigs", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetTasksWithoutConfigs(
	ctx interface{},
	_Query interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Query}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetTasksWithoutConfigs", args...)
}

// GetTierConfigs responds to a GetTierConfigs call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().GetTierConfigs(gomock.Any(), ...).Return(...)
// 	... := client.GetTierConfigs(...)
func (m *MockClient) GetTierConfigs(
	ctx context.Context,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "GetTierConfigs", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) GetTierConfigs(
	ctx interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "GetTierConfigs", args...)
}

// PopulateJobConfig responds to a PopulateJobConfig call based on the mock expectations. This
// call will fail if the mock does not expect this call. Use EXPECT to expect
// a call to this function.
//
// 	client.EXPECT().PopulateJobConfig(gomock.Any(), ...).Return(...)
// 	... := client.PopulateJobConfig(...)
func (m *MockClient) PopulateJobConfig(
	ctx context.Context,
	_Description *api.JobConfiguration,
	opts ...yarpc.CallOption,
) (success *api.Response, err error) {

	args := []interface{}{ctx, _Description}
	for _, o := range opts {
		args = append(args, o)
	}
	i := 0
	ret := m.ctrl.Call(m, "PopulateJobConfig", args...)
	success, _ = ret[i].(*api.Response)
	i++
	err, _ = ret[i].(error)
	return
}

func (mr *_MockClientRecorder) PopulateJobConfig(
	ctx interface{},
	_Description interface{},
	opts ...interface{},
) *gomock.Call {
	args := append([]interface{}{ctx, _Description}, opts...)
	return mr.mock.ctrl.RecordCall(mr.mock, "PopulateJobConfig", args...)
}
